{"ast":null,"code":"var Search_Graph_Nodes={id:'0030',name:'Search_Graph_Nodes',refLink:['https://www.lintcode.com/problem/search-graph-nodes/description','https://www.jiuzhang.com/solution/search-graph-nodes/'],level:'Medium',tag:[''],notes:\"JAVA only\",jsSolution:\"\\n        // Given a undirected graph, a node and a target, return the nearest node to given node which value of it is target, return NULL if you can't find.\\n\\n        // There is a mapping store the nodes' values in the given parameters.\\n        \\n        // \\u5728\\u7EBF\\u8BC4\\u6D4B\\u5730\\u5740: https://www.lintcode.com/problem/search-graph-nodes/\\n\\n        /**\\n         * Definition for graph node.\\n         * class GraphNode {\\n         *     int label;\\n         *     ArrayList<UndirectedGraphNode> neighbors;\\n         *     UndirectedGraphNode(int x) { \\n         *         label = x; neighbors = new ArrayList<UndirectedGraphNode>(); \\n         *     }\\n         * };\\n         */\\n        public class Solution {\\n            /**\\n             * @param graph a list of Undirected graph node\\n             * @param values a hash mapping, <UndirectedGraphNode, (int)value>\\n             * @param node an Undirected graph node\\n             * @param target an integer\\n             * @return the a node\\n             */\\n            public UndirectedGraphNode searchNode(ArrayList<UndirectedGraphNode> graph,\\n                                                Map<UndirectedGraphNode, Integer> values,\\n                                                UndirectedGraphNode node,\\n                                                int target) {\\n                // Write your code here\\n                Queue<UndirectedGraphNode> queue = new LinkedList<UndirectedGraphNode>();\\n                Set<UndirectedGraphNode> hash = new HashSet<UndirectedGraphNode>();\\n\\n                queue.offer(node);\\n                hash.add(node);\\n\\n                while (!queue.isEmpty()) {\\n                    UndirectedGraphNode head = queue.poll();\\n                    if (values.get(head) == target) {\\n                        return head;\\n                    }\\n                    for (UndirectedGraphNode nei : head.neighbors) {\\n                        if (!hash.contains(nei)){\\n                            queue.offer(nei);\\n                            hash.add(nei);\\n                        }\\n                    }\\n                }\\n                return null;\\n            }\\n        }\\n    \"};export default Search_Graph_Nodes;","map":{"version":3,"sources":["/Users/yabao/Documents/githubspace/Jutsai-Lab/src/apps/bao/baoApp/views/examples/JsLeetcode/js/Breadth_First_Search/Search_Graph_Nodes.js"],"names":["Search_Graph_Nodes","id","name","refLink","level","tag","notes","jsSolution"],"mappings":"AAAA,GAAMA,CAAAA,kBAAkB,CAAG,CACvBC,EAAE,CAAE,MADmB,CAEvBC,IAAI,CAAE,oBAFiB,CAGvBC,OAAO,CAAE,CACL,iEADK,CAEL,uDAFK,CAHc,CAOvBC,KAAK,CAAE,QAPgB,CAQvBC,GAAG,CAAE,CACD,EADC,CARkB,CAWvBC,KAAK,YAXkB,CAYvBC,UAAU,gqEAZa,CAA3B,CAkEA,cAAeP,CAAAA,kBAAf","sourcesContent":["const Search_Graph_Nodes = {\n    id: '0030',\n    name: 'Search_Graph_Nodes',\n    refLink: [\n        'https://www.lintcode.com/problem/search-graph-nodes/description',\n        'https://www.jiuzhang.com/solution/search-graph-nodes/'\n    ],\n    level: 'Medium',\n    tag: [\n        ''\n    ],\n    notes: `JAVA only`,\n    jsSolution: `\n        // Given a undirected graph, a node and a target, return the nearest node to given node which value of it is target, return NULL if you can't find.\n\n        // There is a mapping store the nodes' values in the given parameters.\n        \n        // 在线评测地址: https://www.lintcode.com/problem/search-graph-nodes/\n\n        /**\n         * Definition for graph node.\n         * class GraphNode {\n         *     int label;\n         *     ArrayList<UndirectedGraphNode> neighbors;\n         *     UndirectedGraphNode(int x) { \n         *         label = x; neighbors = new ArrayList<UndirectedGraphNode>(); \n         *     }\n         * };\n         */\n        public class Solution {\n            /**\n             * @param graph a list of Undirected graph node\n             * @param values a hash mapping, <UndirectedGraphNode, (int)value>\n             * @param node an Undirected graph node\n             * @param target an integer\n             * @return the a node\n             */\n            public UndirectedGraphNode searchNode(ArrayList<UndirectedGraphNode> graph,\n                                                Map<UndirectedGraphNode, Integer> values,\n                                                UndirectedGraphNode node,\n                                                int target) {\n                // Write your code here\n                Queue<UndirectedGraphNode> queue = new LinkedList<UndirectedGraphNode>();\n                Set<UndirectedGraphNode> hash = new HashSet<UndirectedGraphNode>();\n\n                queue.offer(node);\n                hash.add(node);\n\n                while (!queue.isEmpty()) {\n                    UndirectedGraphNode head = queue.poll();\n                    if (values.get(head) == target) {\n                        return head;\n                    }\n                    for (UndirectedGraphNode nei : head.neighbors) {\n                        if (!hash.contains(nei)){\n                            queue.offer(nei);\n                            hash.add(nei);\n                        }\n                    }\n                }\n                return null;\n            }\n        }\n    `\n}\n\nexport default Search_Graph_Nodes\n"]},"metadata":{},"sourceType":"module"}