{"ast":null,"code":"const Graph_Valid_Tree = {\n  id: '0028',\n  name: 'Graph_Valid_Tree',\n  refLink: ['https://www.jiuzhang.com/solution/graph-valid-tree/#tag-highlight'],\n  level: 'Medium',\n  tag: [''],\n  notes: `JAVA only`,\n  jsSolution: `\n        // Given n nodes labeled from 0 to n - 1 and a list of undirected edges (each edge is a pair of nodes), write a function to check whether these edges make up a valid tree.\n\n        // 在线评测地址: https://www.lintcode.com/problem/graph-valid-tree/\n\n        // version 1: BFS\n        public class Solution {\n            /**\n             * @param n an integer\n             * @param edges a list of undirected edges\n             * @return true if it's a valid tree, or false\n             */\n            public boolean validTree(int n, int[][] edges) {\n                if (n == 0) {\n                    return false;\n                }\n                \n                if (edges.length != n - 1) {\n                    return false;\n                }\n                \n                Map<Integer, Set<Integer>> graph = initializeGraph(n, edges);\n                \n                // bfs\n                Queue<Integer> queue = new LinkedList<>();\n                Set<Integer> hash = new HashSet<>();\n                \n                queue.offer(0);\n                hash.add(0);\n                while (!queue.isEmpty()) {\n                    int node = queue.poll();\n                    for (Integer neighbor : graph.get(node)) {\n                        if (hash.contains(neighbor)) {\n                            continue;\n                        }\n                        hash.add(neighbor);\n                        queue.offer(neighbor);\n                    }\n                }\n                \n                return (hash.size() == n);\n            }\n            \n            private Map<Integer, Set<Integer>> initializeGraph(int n, int[][] edges) {\n                Map<Integer, Set<Integer>> graph = new HashMap<>();\n                for (int i = 0; i < n; i++) {\n                    graph.put(i, new HashSet<Integer>());\n                }\n                \n                for (int i = 0; i < edges.length; i++) {\n                    int u = edges[i][0];\n                    int v = edges[i][1];\n                    graph.get(u).add(v);\n                    graph.get(v).add(u);\n                }\n                \n                return graph;\n            }\n        }\n\n\n        // version 2: Union Find\n        public class Solution {\n            class UnionFind{\n                HashMap<Integer, Integer> father = new HashMap<Integer, Integer>();\n                UnionFind(int n){\n                    for(int i = 0 ; i < n; i++) {\n                        father.put(i, i); \n                    }\n                }\n                int compressed_find(int x){\n                    int parent =  father.get(x);\n                    while(parent!=father.get(parent)) {\n                        parent = father.get(parent);\n                    }\n                    int temp = -1;\n                    int fa = father.get(x);\n                    while(fa!=father.get(fa)) {\n                        temp = father.get(fa);\n                        father.put(fa, parent) ;\n                        fa = temp;\n                    }\n                    return parent;\n                        \n                }\n                \n                void union(int x, int y){\n                    int fa_x = compressed_find(x);\n                    int fa_y = compressed_find(y);\n                    if(fa_x != fa_y)\n                        father.put(fa_x, fa_y);\n                }\n            }\n            /**\n             * @param n an integer\n             * @param edges a list of undirected edges\n             * @return true if it's a valid tree, or false\n             */\n            public boolean validTree(int n, int[][] edges) {\n                // tree should have n nodes with n-1 edges\n                if (n - 1 != edges.length) {\n                    return false;\n                }\n                \n                UnionFind uf = new UnionFind(n);\n                \n                for (int i = 0; i < edges.length; i++) {\n                    if (uf.compressed_find(edges[i][0]) == uf.compressed_find(edges[i][1])) {\n                        return false;\n                    }\n                    uf.union(edges[i][0], edges[i][1]);\n                }\n                return true;\n            }\n        }\n    `\n};\nexport default Graph_Valid_Tree;","map":{"version":3,"sources":["/Users/yabao/Documents/githubspace/Jutsai-Lab/src/apps/bao/baoApp/views/examples/JsLeetcode/js/Breadth_First_Search/Graph_Valid_Tree.js"],"names":["Graph_Valid_Tree","id","name","refLink","level","tag","notes","jsSolution"],"mappings":"AAAA,MAAMA,gBAAgB,GAAG;AACrBC,EAAAA,EAAE,EAAE,MADiB;AAErBC,EAAAA,IAAI,EAAE,kBAFe;AAGrBC,EAAAA,OAAO,EAAE,CACL,mEADK,CAHY;AAMrBC,EAAAA,KAAK,EAAE,QANc;AAOrBC,EAAAA,GAAG,EAAE,CACD,EADC,CAPgB;AAUrBC,EAAAA,KAAK,EAAG,WAVa;AAWrBC,EAAAA,UAAU,EAAG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAXQ,CAAzB;AAiIA,eAAeP,gBAAf","sourcesContent":["const Graph_Valid_Tree = {\n    id: '0028',\n    name: 'Graph_Valid_Tree',\n    refLink: [\n        'https://www.jiuzhang.com/solution/graph-valid-tree/#tag-highlight',\n    ],\n    level: 'Medium',\n    tag: [\n        ''\n    ],\n    notes: `JAVA only`,\n    jsSolution: `\n        // Given n nodes labeled from 0 to n - 1 and a list of undirected edges (each edge is a pair of nodes), write a function to check whether these edges make up a valid tree.\n\n        // 在线评测地址: https://www.lintcode.com/problem/graph-valid-tree/\n\n        // version 1: BFS\n        public class Solution {\n            /**\n             * @param n an integer\n             * @param edges a list of undirected edges\n             * @return true if it's a valid tree, or false\n             */\n            public boolean validTree(int n, int[][] edges) {\n                if (n == 0) {\n                    return false;\n                }\n                \n                if (edges.length != n - 1) {\n                    return false;\n                }\n                \n                Map<Integer, Set<Integer>> graph = initializeGraph(n, edges);\n                \n                // bfs\n                Queue<Integer> queue = new LinkedList<>();\n                Set<Integer> hash = new HashSet<>();\n                \n                queue.offer(0);\n                hash.add(0);\n                while (!queue.isEmpty()) {\n                    int node = queue.poll();\n                    for (Integer neighbor : graph.get(node)) {\n                        if (hash.contains(neighbor)) {\n                            continue;\n                        }\n                        hash.add(neighbor);\n                        queue.offer(neighbor);\n                    }\n                }\n                \n                return (hash.size() == n);\n            }\n            \n            private Map<Integer, Set<Integer>> initializeGraph(int n, int[][] edges) {\n                Map<Integer, Set<Integer>> graph = new HashMap<>();\n                for (int i = 0; i < n; i++) {\n                    graph.put(i, new HashSet<Integer>());\n                }\n                \n                for (int i = 0; i < edges.length; i++) {\n                    int u = edges[i][0];\n                    int v = edges[i][1];\n                    graph.get(u).add(v);\n                    graph.get(v).add(u);\n                }\n                \n                return graph;\n            }\n        }\n\n\n        // version 2: Union Find\n        public class Solution {\n            class UnionFind{\n                HashMap<Integer, Integer> father = new HashMap<Integer, Integer>();\n                UnionFind(int n){\n                    for(int i = 0 ; i < n; i++) {\n                        father.put(i, i); \n                    }\n                }\n                int compressed_find(int x){\n                    int parent =  father.get(x);\n                    while(parent!=father.get(parent)) {\n                        parent = father.get(parent);\n                    }\n                    int temp = -1;\n                    int fa = father.get(x);\n                    while(fa!=father.get(fa)) {\n                        temp = father.get(fa);\n                        father.put(fa, parent) ;\n                        fa = temp;\n                    }\n                    return parent;\n                        \n                }\n                \n                void union(int x, int y){\n                    int fa_x = compressed_find(x);\n                    int fa_y = compressed_find(y);\n                    if(fa_x != fa_y)\n                        father.put(fa_x, fa_y);\n                }\n            }\n            /**\n             * @param n an integer\n             * @param edges a list of undirected edges\n             * @return true if it's a valid tree, or false\n             */\n            public boolean validTree(int n, int[][] edges) {\n                // tree should have n nodes with n-1 edges\n                if (n - 1 != edges.length) {\n                    return false;\n                }\n                \n                UnionFind uf = new UnionFind(n);\n                \n                for (int i = 0; i < edges.length; i++) {\n                    if (uf.compressed_find(edges[i][0]) == uf.compressed_find(edges[i][1])) {\n                        return false;\n                    }\n                    uf.union(edges[i][0], edges[i][1]);\n                }\n                return true;\n            }\n        }\n    `\n}\n\nexport default Graph_Valid_Tree\n"]},"metadata":{},"sourceType":"module"}