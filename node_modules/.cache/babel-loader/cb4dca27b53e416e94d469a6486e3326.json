{"ast":null,"code":"const Maximum_Depth_of_Binary_Tree = {\n  id: '0017',\n  name: 'Maximum_Depth_of_Binary_Tree',\n  refLink: ['https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/solution/104-er-cha-shu-de-zui-da-shen-du-by-alexer-660/', 'https://www.lintcode.com/problem/maximum-depth-of-binary-tree/description', 'https://www.jiuzhang.com/solution/maximum-depth-of-binary-tree/#tag-other'],\n  level: 'Easy',\n  tag: [],\n  notes: ``,\n  jsSolution: `\n        // Given a binary tree, find its maximum depth.\n\n        // The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\n        \n        // 在线评测地址: https://www.lintcode.com/problem/maximum-depth-of-binary-tree/\n\n\n        解法一：递归 DFS\n        节点的高度 = Max(左子树的高度，右子树的高度) + 1\n        以此类推，最后一个左或右节点高度为0 再反过来相加回去即可\n        时间复杂度：O(n)\n        空间复杂度\n        最坏情况下 O(n) 退化为单链表\n        最好情况下 O(logn) 为平衡二叉树且高度为logn\n        /**\n         * Definition for a binary tree node.\n         * function TreeNode(val) {\n         *     this.val = val;\n         *     this.left = this.right = null;\n         * }\n         */\n        /**\n         * @param {TreeNode} root\n         * @return {number}\n         */\n        var maxDepth = function(root) {\n            function getDepth(root,leftSubtreeDepth,rightSubtreeDepth){\n                if(root != null){\n                    leftSubtreeDepth = getDepth(root.left);\n                    rightSubtreeDepth = getDepth(root.right);\n                    return Math.max(leftSubtreeDepth,rightSubtreeDepth) + 1;   \n                }else{\n                    return 0;\n                }\n            }\n            return getDepth(root);\n        };\n\n        解法二：队列 BFS\n        广度优先遍历 BFS\n        此处即二叉树的层次(序)遍历\n        求最大深度 亦即 求二叉树有几层\n        广度优先代码\n        特点：\"从左到右，从上到下\"\n        队列\n        特点：\"先进先出\"\n        队列实现广度优先\n        遍历二叉树节点，依次将当前节点 和它的左右子节点入队，并再一一出队\n        针对子节点的节点重复上一步操作\n        刚好符合\"先进先出\" => \"先入队再出队\"\n        数组：push -> shift\n        所以二叉树的广度优先即层序遍历用队列实现为\n        /**\n         * Definition for a binary tree node.\n         * function TreeNode(val) {\n         *     this.val = val;\n         *     this.left = this.right = null;\n         * }\n         */\n        /**\n         * @param {TreeNode} root\n         * @return {number}\n         */\n        var maxDepth = function(root) {\n            if(root == null){\n                return 0;\n            }\n            var tmpQueue = [root];\n            var result = [];\n            var currNode = null;\n            while(tmpQueue.length != 0){ --------------------------(1)\n                currNode = tmpQueue.shift();\n                result.push(currNode);\n                if(node.left != null){\n                    tmpQueue.push(node.left);\n                }\n                if(node.right != null){\n                    tmpQueue.push(node.right);\n                }\n            }\n            return result;\n        };\n    `\n};\nexport default Maximum_Depth_of_Binary_Tree;","map":{"version":3,"sources":["/Users/yabao/Documents/githubspace/Jutsai-Lab/src/apps/bao/baoApp/views/examples/JsLeetcode/js/Binary_Tree_Divide_Conquer/Maximum_Depth_of_Binary_Tree.js"],"names":["Maximum_Depth_of_Binary_Tree","id","name","refLink","level","tag","notes","jsSolution"],"mappings":"AAAA,MAAMA,4BAA4B,GAAG;AACjCC,EAAAA,EAAE,EAAE,MAD6B;AAEjCC,EAAAA,IAAI,EAAE,8BAF2B;AAGjCC,EAAAA,OAAO,EAAE,CACL,wHADK,EAEL,2EAFK,EAGL,2EAHK,CAHwB;AAQjCC,EAAAA,KAAK,EAAE,MAR0B;AASjCC,EAAAA,GAAG,EAAE,EAT4B;AAUjCC,EAAAA,KAAK,EAAG,EAVyB;AAWjCC,EAAAA,UAAU,EAAG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAXoB,CAArC;AAiGA,eAAeP,4BAAf","sourcesContent":["const Maximum_Depth_of_Binary_Tree = {\n    id: '0017',\n    name: 'Maximum_Depth_of_Binary_Tree',\n    refLink: [\n        'https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/solution/104-er-cha-shu-de-zui-da-shen-du-by-alexer-660/',\n        'https://www.lintcode.com/problem/maximum-depth-of-binary-tree/description',\n        'https://www.jiuzhang.com/solution/maximum-depth-of-binary-tree/#tag-other'\n    ],\n    level: 'Easy',\n    tag: [],\n    notes: ``,\n    jsSolution: `\n        // Given a binary tree, find its maximum depth.\n\n        // The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\n        \n        // 在线评测地址: https://www.lintcode.com/problem/maximum-depth-of-binary-tree/\n\n\n        解法一：递归 DFS\n        节点的高度 = Max(左子树的高度，右子树的高度) + 1\n        以此类推，最后一个左或右节点高度为0 再反过来相加回去即可\n        时间复杂度：O(n)\n        空间复杂度\n        最坏情况下 O(n) 退化为单链表\n        最好情况下 O(logn) 为平衡二叉树且高度为logn\n        /**\n         * Definition for a binary tree node.\n         * function TreeNode(val) {\n         *     this.val = val;\n         *     this.left = this.right = null;\n         * }\n         */\n        /**\n         * @param {TreeNode} root\n         * @return {number}\n         */\n        var maxDepth = function(root) {\n            function getDepth(root,leftSubtreeDepth,rightSubtreeDepth){\n                if(root != null){\n                    leftSubtreeDepth = getDepth(root.left);\n                    rightSubtreeDepth = getDepth(root.right);\n                    return Math.max(leftSubtreeDepth,rightSubtreeDepth) + 1;   \n                }else{\n                    return 0;\n                }\n            }\n            return getDepth(root);\n        };\n\n        解法二：队列 BFS\n        广度优先遍历 BFS\n        此处即二叉树的层次(序)遍历\n        求最大深度 亦即 求二叉树有几层\n        广度优先代码\n        特点：\"从左到右，从上到下\"\n        队列\n        特点：\"先进先出\"\n        队列实现广度优先\n        遍历二叉树节点，依次将当前节点 和它的左右子节点入队，并再一一出队\n        针对子节点的节点重复上一步操作\n        刚好符合\"先进先出\" => \"先入队再出队\"\n        数组：push -> shift\n        所以二叉树的广度优先即层序遍历用队列实现为\n        /**\n         * Definition for a binary tree node.\n         * function TreeNode(val) {\n         *     this.val = val;\n         *     this.left = this.right = null;\n         * }\n         */\n        /**\n         * @param {TreeNode} root\n         * @return {number}\n         */\n        var maxDepth = function(root) {\n            if(root == null){\n                return 0;\n            }\n            var tmpQueue = [root];\n            var result = [];\n            var currNode = null;\n            while(tmpQueue.length != 0){ --------------------------(1)\n                currNode = tmpQueue.shift();\n                result.push(currNode);\n                if(node.left != null){\n                    tmpQueue.push(node.left);\n                }\n                if(node.right != null){\n                    tmpQueue.push(node.right);\n                }\n            }\n            return result;\n        };\n    `\n}\n\nexport default Maximum_Depth_of_Binary_Tree\n"]},"metadata":{},"sourceType":"module"}