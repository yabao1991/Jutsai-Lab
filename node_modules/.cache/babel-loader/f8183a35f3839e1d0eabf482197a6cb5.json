{"ast":null,"code":"const Number_of_Islands = {\n  id: '0032',\n  name: 'Number_of_Islands',\n  refLink: ['https://leetcode-cn.com/problems/number-of-islands/solution/200-dao-yu-shu-liang-by-alexer-660/', 'https://www.lintcode.com/problem/number-of-islands/description', 'https://www.jiuzhang.com/solution/number-of-islands/#tag-other'],\n  level: 'Medium',\n  tag: [''],\n  notes: ``,\n  jsSolution: `\n        // Given a boolean 2D matrix, 0 is represented as the sea, 1 is represented as the island. If two 1 is adjacent, we consider them in the same island. We only consider up/down/left/right adjacent.\n\n        // Find the number of islands.\n        \n        // 在线评测地址: https://www.lintcode.com/problem/number-of-islands/\n\n\n        解法一：DFS\n        /**\n         * @param {character[][]} grid\n         * @return {number}\n         */\n        var numIslands = function(grid) {\n            if(!grid || grid.length == 0){\n                return 0;\n            }\n            var len = grid.length;\n            var size = grid[0].length;\n            var island = 0;\n            function sink(i,j){\n                // terminator\n                if(grid[i][j] == '0'){\n                    return 0;\n                }\n                // process\n                grid[i][j] = '0';\n                // drill down\n                if(i+1<len && grid[i+1][j] == '1'){\n                    sink(i+1,j);\n                } \n                if(i-1 >= 0 && grid[i-1][j] == '1'){\n                    sink(i-1,j);\n                } \n                if(j+1 < size && grid[i][j+1] == '1'){\n                    sink(i,j+1);\n                } \n                if(j-1 >= 0 && grid[i][j-1] == '1'){\n                    sink(i,j-1);\n                }\n                return 1;\n            }\n            for(var i = 0;i<len;i++){\n                for(var r = 0;r<grid[i].length;r++){\n                    if(grid[i][r] == '1'){\n                        island += sink(i,r);\n                    }\n                }\n            }\n            return island;\n        };\n        优化版\n        判断并推平岛屿函数时 用方向向量替代x+1,x-1,y+1,y-1四种情况\n        /**\n         * @param {character[][]} grid\n         * @return {number}\n         */\n        var numIslands = function(grid) {\n            if(!grid || grid.length == 0){\n                return 0;\n            }\n            var len = grid.length;\n            var size = grid[0].length;\n            var island = 0;\n            // 方向向量\n            var dx = [-1,1,0,0];\n            var dy = [0,0,-1,1];\n            // dfs 推平\n            function sink(i,j){\n                // terminator\n                if(grid[i][j] == '0'){\n                    return 0;\n                }\n                // process\n                grid[i][j] = '0';\n                // drill down\n                for(var k = 0;k< dx.length;k++){\n                    var x = i + dx[k];\n                    var y = j + dy[k];\n                    if(x >= 0 && x < grid.length && y >=0 && y<grid[i].length){\n                        if(grid[x][y] == '1'){\n                            sink(x,y)\n                        }\n                    }\n                }\n                return 1;\n            }\n            for(var i = 0;i<len;i++){\n                for(var r = 0;r<grid[i].length;r++){\n                    if(grid[i][r] == 1){\n                        island += sink(i,r);\n                    }\n                }\n            }\n            return island;\n        };\n        解法二：BFS\n        /**\n         * @param {character[][]} grid\n         * @return {number}\n         */\n        var numIslands = function(grid) {\n            if(!grid || grid.length == 0){\n                return 0;\n            }\n            var len = grid.length;\n            var size = grid[0].length;\n            var island = 0;\n            // 从右到左 队列\n            var queue = [];\n            // 方向向量\n            var dx = [-1,1,0,0];\n            var dy = [0,0,-1,1];\n            // dfs 推平\n            function sink(i,j){\n                // terminator\n                if(grid[i][j] == '0'){\n                    return 0;\n                }\n                // process\n                grid[i][j] = '0';\n                // drill down\n                for(var k = 0;k< dx.length;k++){\n                    var x = i + dx[k];\n                    var y = j + dy[k];\n                    if(x >= 0 && x < grid.length && y >=0 && y<grid[i].length){\n                        if(grid[x][y] == '1'){\n                            queue.push([x,y]);\n                        }\n                    }\n                }\n                return 1;\n            }\n            for(var i = 0;i<len;i++){\n                for(var r = 0;r<grid[i].length;r++){\n                    if(grid[i][r] == 1){\n                        island++;\n                        queue.push([i,r])\n                        while(queue.length>0){\n                            var tmpIsland = queue.shift();\n                            sink(tmpIsland[0],tmpIsland[1]);\n                        }\n                    }\n                }\n            }\n            return island;\n        };\n        解法三：并查集\n        类似题型\n        547. 朋友圈\n        区别\n        此题是m * n的矩阵，不是n * n的矩阵\n        parent和rank数组元素命名要将i和j联系起来\n        union查找合并的时候，也要把两个是陆地的元素传进去\n        /**\n         * @param {character[][]} grid\n         * @return {number}\n         */\n        var numIslands = function(grid) {\n            let m = grid.length;\n            if(m == 0){\n                return 0;\n            }\n            let n = grid[0].length;\n            let count = 0;\n            let parent = [];\n            let rank = [];\n\n\n            let find = (p) => {\n                while(p != parent[p]){\n                    parent[p] = parent[parent[p]];\n                    p = parent[p];\n                }\n                return p;\n            }\n            let union = (p,q) => {\n                let rootP = find(p);\n                let rootQ = find(q);\n                if(rootP == rootQ){\n                    return;\n                }\n                if(rank[rootP] > rank[rootQ]){\n                    parent[rootQ] = rootP;\n                }else if(rank[rootP] < rank[rootQ]){\n                    parent[rootP] = rootQ;\n                }else{\n                    parent[rootP] = rootQ;\n                    rank[rootQ]++;\n                }\n                count--;\n            }\n\n            for(let i = 0;i < m;i++){\n                for(let j = 0;j < n;j++){\n                    if(grid[i][j] == 1){\n                        parent[i * n + j] = i * n + j;\n                        count++;\n                    }\n                    rank[i * n + j] = 0;\n                }\n            }\n\n            for(var i = 0;i<m;i++){\n                for(var j = 0;j<n;j++){\n                    if(grid[i][j] == 1){\n                        grid[i][j] = 0;\n                        i-1>=0 && grid[i-1][j] == 1 && union(i*n + j,(i-1)*n + j);\n                        j-1>=0 && grid[i][j-1] == 1 && union(i*n + j,i*n + j-1);\n                        i+1<m && grid[i+1][j] == 1 && union(i*n + j,(i+1)*n + j);\n                        j+1<n && grid[i][j+1] == 1 && union(i*n + j,i*n + j+1);\n                    }\n                }\n            }\n            return count;\n        };\n    `\n};\nexport default Number_of_Islands;","map":{"version":3,"sources":["/Users/yabao/Documents/githubspace/Jutsai-Lab/src/apps/bao/baoApp/views/examples/JsLeetcode/js/Breadth_First_Search/Number_of_Islands.js"],"names":["Number_of_Islands","id","name","refLink","level","tag","notes","jsSolution"],"mappings":"AAAA,MAAMA,iBAAiB,GAAG;AACtBC,EAAAA,EAAE,EAAE,MADkB;AAEtBC,EAAAA,IAAI,EAAE,mBAFgB;AAGtBC,EAAAA,OAAO,EAAE,CACL,iGADK,EAEL,gEAFK,EAGL,gEAHK,CAHa;AAQtBC,EAAAA,KAAK,EAAE,QARe;AAStBC,EAAAA,GAAG,EAAE,CACD,EADC,CATiB;AAYtBC,EAAAA,KAAK,EAAG,EAZc;AAatBC,EAAAA,UAAU,EAAG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAbS,CAA1B;AAwOA,eAAeP,iBAAf","sourcesContent":["const Number_of_Islands = {\n    id: '0032',\n    name: 'Number_of_Islands',\n    refLink: [\n        'https://leetcode-cn.com/problems/number-of-islands/solution/200-dao-yu-shu-liang-by-alexer-660/',\n        'https://www.lintcode.com/problem/number-of-islands/description',\n        'https://www.jiuzhang.com/solution/number-of-islands/#tag-other'\n    ],\n    level: 'Medium',\n    tag: [\n        ''\n    ],\n    notes: ``,\n    jsSolution: `\n        // Given a boolean 2D matrix, 0 is represented as the sea, 1 is represented as the island. If two 1 is adjacent, we consider them in the same island. We only consider up/down/left/right adjacent.\n\n        // Find the number of islands.\n        \n        // 在线评测地址: https://www.lintcode.com/problem/number-of-islands/\n\n\n        解法一：DFS\n        /**\n         * @param {character[][]} grid\n         * @return {number}\n         */\n        var numIslands = function(grid) {\n            if(!grid || grid.length == 0){\n                return 0;\n            }\n            var len = grid.length;\n            var size = grid[0].length;\n            var island = 0;\n            function sink(i,j){\n                // terminator\n                if(grid[i][j] == '0'){\n                    return 0;\n                }\n                // process\n                grid[i][j] = '0';\n                // drill down\n                if(i+1<len && grid[i+1][j] == '1'){\n                    sink(i+1,j);\n                } \n                if(i-1 >= 0 && grid[i-1][j] == '1'){\n                    sink(i-1,j);\n                } \n                if(j+1 < size && grid[i][j+1] == '1'){\n                    sink(i,j+1);\n                } \n                if(j-1 >= 0 && grid[i][j-1] == '1'){\n                    sink(i,j-1);\n                }\n                return 1;\n            }\n            for(var i = 0;i<len;i++){\n                for(var r = 0;r<grid[i].length;r++){\n                    if(grid[i][r] == '1'){\n                        island += sink(i,r);\n                    }\n                }\n            }\n            return island;\n        };\n        优化版\n        判断并推平岛屿函数时 用方向向量替代x+1,x-1,y+1,y-1四种情况\n        /**\n         * @param {character[][]} grid\n         * @return {number}\n         */\n        var numIslands = function(grid) {\n            if(!grid || grid.length == 0){\n                return 0;\n            }\n            var len = grid.length;\n            var size = grid[0].length;\n            var island = 0;\n            // 方向向量\n            var dx = [-1,1,0,0];\n            var dy = [0,0,-1,1];\n            // dfs 推平\n            function sink(i,j){\n                // terminator\n                if(grid[i][j] == '0'){\n                    return 0;\n                }\n                // process\n                grid[i][j] = '0';\n                // drill down\n                for(var k = 0;k< dx.length;k++){\n                    var x = i + dx[k];\n                    var y = j + dy[k];\n                    if(x >= 0 && x < grid.length && y >=0 && y<grid[i].length){\n                        if(grid[x][y] == '1'){\n                            sink(x,y)\n                        }\n                    }\n                }\n                return 1;\n            }\n            for(var i = 0;i<len;i++){\n                for(var r = 0;r<grid[i].length;r++){\n                    if(grid[i][r] == 1){\n                        island += sink(i,r);\n                    }\n                }\n            }\n            return island;\n        };\n        解法二：BFS\n        /**\n         * @param {character[][]} grid\n         * @return {number}\n         */\n        var numIslands = function(grid) {\n            if(!grid || grid.length == 0){\n                return 0;\n            }\n            var len = grid.length;\n            var size = grid[0].length;\n            var island = 0;\n            // 从右到左 队列\n            var queue = [];\n            // 方向向量\n            var dx = [-1,1,0,0];\n            var dy = [0,0,-1,1];\n            // dfs 推平\n            function sink(i,j){\n                // terminator\n                if(grid[i][j] == '0'){\n                    return 0;\n                }\n                // process\n                grid[i][j] = '0';\n                // drill down\n                for(var k = 0;k< dx.length;k++){\n                    var x = i + dx[k];\n                    var y = j + dy[k];\n                    if(x >= 0 && x < grid.length && y >=0 && y<grid[i].length){\n                        if(grid[x][y] == '1'){\n                            queue.push([x,y]);\n                        }\n                    }\n                }\n                return 1;\n            }\n            for(var i = 0;i<len;i++){\n                for(var r = 0;r<grid[i].length;r++){\n                    if(grid[i][r] == 1){\n                        island++;\n                        queue.push([i,r])\n                        while(queue.length>0){\n                            var tmpIsland = queue.shift();\n                            sink(tmpIsland[0],tmpIsland[1]);\n                        }\n                    }\n                }\n            }\n            return island;\n        };\n        解法三：并查集\n        类似题型\n        547. 朋友圈\n        区别\n        此题是m * n的矩阵，不是n * n的矩阵\n        parent和rank数组元素命名要将i和j联系起来\n        union查找合并的时候，也要把两个是陆地的元素传进去\n        /**\n         * @param {character[][]} grid\n         * @return {number}\n         */\n        var numIslands = function(grid) {\n            let m = grid.length;\n            if(m == 0){\n                return 0;\n            }\n            let n = grid[0].length;\n            let count = 0;\n            let parent = [];\n            let rank = [];\n\n\n            let find = (p) => {\n                while(p != parent[p]){\n                    parent[p] = parent[parent[p]];\n                    p = parent[p];\n                }\n                return p;\n            }\n            let union = (p,q) => {\n                let rootP = find(p);\n                let rootQ = find(q);\n                if(rootP == rootQ){\n                    return;\n                }\n                if(rank[rootP] > rank[rootQ]){\n                    parent[rootQ] = rootP;\n                }else if(rank[rootP] < rank[rootQ]){\n                    parent[rootP] = rootQ;\n                }else{\n                    parent[rootP] = rootQ;\n                    rank[rootQ]++;\n                }\n                count--;\n            }\n\n            for(let i = 0;i < m;i++){\n                for(let j = 0;j < n;j++){\n                    if(grid[i][j] == 1){\n                        parent[i * n + j] = i * n + j;\n                        count++;\n                    }\n                    rank[i * n + j] = 0;\n                }\n            }\n\n            for(var i = 0;i<m;i++){\n                for(var j = 0;j<n;j++){\n                    if(grid[i][j] == 1){\n                        grid[i][j] = 0;\n                        i-1>=0 && grid[i-1][j] == 1 && union(i*n + j,(i-1)*n + j);\n                        j-1>=0 && grid[i][j-1] == 1 && union(i*n + j,i*n + j-1);\n                        i+1<m && grid[i+1][j] == 1 && union(i*n + j,(i+1)*n + j);\n                        j+1<n && grid[i][j+1] == 1 && union(i*n + j,i*n + j+1);\n                    }\n                }\n            }\n            return count;\n        };\n    `\n}\n\nexport default Number_of_Islands\n"]},"metadata":{},"sourceType":"module"}