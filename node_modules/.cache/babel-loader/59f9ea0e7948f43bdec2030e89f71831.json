{"ast":null,"code":"const Sort_List = {\n  id: '0046',\n  name: 'Sort_List',\n  refLink: ['https://leetcode-cn.com/problems/sort-list/solution/148-pai-xu-lian-biao-by-alexer-660/', 'https://www.lintcode.com/problem/sort-list/description', 'https://www.jiuzhang.com/solution/sort-list/#tag-highlight'],\n  level: 'Hard',\n  tag: [],\n  notes: ``,\n  jsSolution: `\n        // Sort a linked list in O(n log n) time using constant space complexity.\n\n        // 在线评测地址: https://www.lintcode.com/problem/sort-list/\n\n        解法一：归并排序 - 递归\n        经典排序算法讲解 - 归并排序 - 递归版\n        跟上述讲解思路一模一样\n        摘抄讲解如下\n        1、把长度为n的输入序列分成两个长度为n/2的子序列\n        2、对这两个子序列分别采用归并排序\n        3、将两个排序好的子序列合并成一个最终的排序序列\n        对应链表\n        1、用双指针法(快慢指针)寻找链表中间节点\n        参看链表各种操作大全 - 求链表的中间节点\n        奇数个节点找到中点，偶数个节点找到中心左边的节点\n        注意\n        找到中点后，要将链表切断，即 mid.next = null\n        因链表性质，左边子序列取左端点即可\n        同数组归并一样，只剩一个节点时终止\n        用于分成左右两边子序列\n        右边子序列为慢指针的next\n        2、递归排序左右子序列\n        3、合并\n        同数组一样，判断值的大小\n        不同的是，用哨兵节点链接合并后的链表，返回即可\n        /**\n         * Definition for singly-linked list.\n         * function ListNode(val) {\n         *     this.val = val;\n         *     this.next = null;\n         * }\n         */\n        /**\n         * @param {ListNode} head\n         * @return {ListNode}\n         */\n        var sortList = function(head) {\n            let mergeList = (left,right) => {\n                let res = new ListNode(0);\n                let pre = res;\n                while(left && right){\n                    if(left.val <= right.val){\n                        pre.next = left;\n                        left = left.next;\n                    }else{\n                        pre.next = right;\n                        right = right.next;\n                    }\n                    pre = pre.next;\n                }\n                pre.next = left ? left : right;\n                return res.next;\n            }\n            let mergeSort = (node) => {\n                if(!node || !node.next) return node;\n                let mid = node;\n                let fast = node.next;\n                while(fast && fast.next){\n                    mid = mid.next;\n                    fast = fast.next.next;\n                }\n                let rightList = mid.next;\n                mid.next = null;\n                let left = node;\n                let right = rightList;\n                return mergeList(mergeSort(left),mergeSort(right));\n            }\n            return mergeSort(head);\n        };\n        解法二：归并排序 - 非递归\n        经典排序算法讲解 - 归并排序 - 非递归版\n        跟上述讲解思路一模一样\n        /**\n         * Definition for singly-linked list.\n         * function ListNode(val) {\n         *     this.val = val;\n         *     this.next = null;\n         * }\n         */\n        /**\n         * @param {ListNode} head\n         * @return {ListNode}\n         */\n        var sortList = function(head) {\n            // 哨兵节点\n            let preHead = new ListNode(0);\n            preHead.next = head;\n            // 求链表长度\n            let n = 0;\n            let curr = head;\n            while(curr){\n                curr = curr.next;\n                n++;\n            }\n            // 分割i长度的链表，返回剩余的链表\n            let split = (node,i) => {\n                while(i != 1 && node){\n                    node = node.next;\n                    i--;\n                }\n                let rest = node ? node.next : null;\n                if(node) node.next = null;\n                return rest;\n            }\n            // 合并\n            let merge = (left,right,pre) => {\n                let curr = pre;\n                while(left && right){\n                    if(left.val <= right.val){\n                        curr.next = left;\n                        left = left.next;\n                    }else{\n                        curr.next = right;\n                        right = right.next;\n                    }\n                    curr = curr.next;\n                }\n                curr.next = left || right;\n                while(curr.next) curr = curr.next;\n                return curr;\n            }\n            // 合并 2*i 个\n            for(let i = 1;i < n;i *= 2){\n                let pre = preHead;\n                let curr = preHead.next;\n                // 分割左右两部分链表，并合并\n                while(curr){\n                    let left = curr;\n                    let right = split(left,i);\n                    curr = split(right,i);\n                    pre = merge(left,right,pre);\n                }\n            }\n            return preHead.next;\n        };\n    `\n};\nexport default Sort_List;","map":{"version":3,"sources":["/Users/yabao/Documents/githubspace/Jutsai-Lab/src/apps/bao/baoApp/views/examples/JsLeetcode/js/Linked_List_Array/Sort_List.js"],"names":["Sort_List","id","name","refLink","level","tag","notes","jsSolution"],"mappings":"AAAA,MAAMA,SAAS,GAAG;AACdC,EAAAA,EAAE,EAAE,MADU;AAEdC,EAAAA,IAAI,EAAE,WAFQ;AAGdC,EAAAA,OAAO,EAAE,CACL,yFADK,EAEL,wDAFK,EAGL,4DAHK,CAHK;AAQdC,EAAAA,KAAK,EAAE,MARO;AASdC,EAAAA,GAAG,EAAE,EATS;AAUdC,EAAAA,KAAK,EAAG,EAVM;AAWdC,EAAAA,UAAU,EAAG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAXC,CAAlB;AAsJA,eAAeP,SAAf","sourcesContent":["const Sort_List = {\n    id: '0046',\n    name: 'Sort_List',\n    refLink: [\n        'https://leetcode-cn.com/problems/sort-list/solution/148-pai-xu-lian-biao-by-alexer-660/',\n        'https://www.lintcode.com/problem/sort-list/description',\n        'https://www.jiuzhang.com/solution/sort-list/#tag-highlight'\n    ],\n    level: 'Hard',\n    tag: [],\n    notes: ``,\n    jsSolution: `\n        // Sort a linked list in O(n log n) time using constant space complexity.\n\n        // 在线评测地址: https://www.lintcode.com/problem/sort-list/\n\n        解法一：归并排序 - 递归\n        经典排序算法讲解 - 归并排序 - 递归版\n        跟上述讲解思路一模一样\n        摘抄讲解如下\n        1、把长度为n的输入序列分成两个长度为n/2的子序列\n        2、对这两个子序列分别采用归并排序\n        3、将两个排序好的子序列合并成一个最终的排序序列\n        对应链表\n        1、用双指针法(快慢指针)寻找链表中间节点\n        参看链表各种操作大全 - 求链表的中间节点\n        奇数个节点找到中点，偶数个节点找到中心左边的节点\n        注意\n        找到中点后，要将链表切断，即 mid.next = null\n        因链表性质，左边子序列取左端点即可\n        同数组归并一样，只剩一个节点时终止\n        用于分成左右两边子序列\n        右边子序列为慢指针的next\n        2、递归排序左右子序列\n        3、合并\n        同数组一样，判断值的大小\n        不同的是，用哨兵节点链接合并后的链表，返回即可\n        /**\n         * Definition for singly-linked list.\n         * function ListNode(val) {\n         *     this.val = val;\n         *     this.next = null;\n         * }\n         */\n        /**\n         * @param {ListNode} head\n         * @return {ListNode}\n         */\n        var sortList = function(head) {\n            let mergeList = (left,right) => {\n                let res = new ListNode(0);\n                let pre = res;\n                while(left && right){\n                    if(left.val <= right.val){\n                        pre.next = left;\n                        left = left.next;\n                    }else{\n                        pre.next = right;\n                        right = right.next;\n                    }\n                    pre = pre.next;\n                }\n                pre.next = left ? left : right;\n                return res.next;\n            }\n            let mergeSort = (node) => {\n                if(!node || !node.next) return node;\n                let mid = node;\n                let fast = node.next;\n                while(fast && fast.next){\n                    mid = mid.next;\n                    fast = fast.next.next;\n                }\n                let rightList = mid.next;\n                mid.next = null;\n                let left = node;\n                let right = rightList;\n                return mergeList(mergeSort(left),mergeSort(right));\n            }\n            return mergeSort(head);\n        };\n        解法二：归并排序 - 非递归\n        经典排序算法讲解 - 归并排序 - 非递归版\n        跟上述讲解思路一模一样\n        /**\n         * Definition for singly-linked list.\n         * function ListNode(val) {\n         *     this.val = val;\n         *     this.next = null;\n         * }\n         */\n        /**\n         * @param {ListNode} head\n         * @return {ListNode}\n         */\n        var sortList = function(head) {\n            // 哨兵节点\n            let preHead = new ListNode(0);\n            preHead.next = head;\n            // 求链表长度\n            let n = 0;\n            let curr = head;\n            while(curr){\n                curr = curr.next;\n                n++;\n            }\n            // 分割i长度的链表，返回剩余的链表\n            let split = (node,i) => {\n                while(i != 1 && node){\n                    node = node.next;\n                    i--;\n                }\n                let rest = node ? node.next : null;\n                if(node) node.next = null;\n                return rest;\n            }\n            // 合并\n            let merge = (left,right,pre) => {\n                let curr = pre;\n                while(left && right){\n                    if(left.val <= right.val){\n                        curr.next = left;\n                        left = left.next;\n                    }else{\n                        curr.next = right;\n                        right = right.next;\n                    }\n                    curr = curr.next;\n                }\n                curr.next = left || right;\n                while(curr.next) curr = curr.next;\n                return curr;\n            }\n            // 合并 2*i 个\n            for(let i = 1;i < n;i *= 2){\n                let pre = preHead;\n                let curr = preHead.next;\n                // 分割左右两部分链表，并合并\n                while(curr){\n                    let left = curr;\n                    let right = split(left,i);\n                    curr = split(right,i);\n                    pre = merge(left,right,pre);\n                }\n            }\n            return preHead.next;\n        };\n    `\n}\n\nexport default Sort_List\n"]},"metadata":{},"sourceType":"module"}