{"ast":null,"code":"const Linked_List_Cycle_II = {\n  id: '0045',\n  name: 'Linked_List_Cycle_II',\n  refLink: ['https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/142-huan-xing-lian-biao-ii-by-alexer-660/', 'https://www.lintcode.com/problem/linked-list-cycle-ii/description', 'https://www.jiuzhang.com/solution/linked-list-cycle-ii/'],\n  level: 'Hard',\n  tag: [],\n  notes: ``,\n  jsSolution: `\n        // Given a linked list, return the node where the cycle begins.\n\n        // If there is no cycle, return null.\n        \n        // 在线评测地址: https://www.lintcode.com/problem/linked-list-cycle-ii/\n\n        解法一：标记法\n        思路同-141. 环形链表-解法二\n        /**\n         * Definition for singly-linked list.\n         * function ListNode(val) {\n         *     this.val = val;\n         *     this.next = null;\n         * }\n         */\n\n        /**\n         * @param {ListNode} head\n         * @return {ListNode}\n         */\n        var detectCycle = function(head) {\n            while(head && head.next){\n                if(head.flag){\n                    return head;\n                }else{\n                    head.flag = 1;\n                    head = head.next;\n                }\n            }\n            return null;\n        };\n        解法二：数组判重\n        思路同-141. 环形链表-解法一\n        /**\n         * Definition for singly-linked list.\n         * function ListNode(val) {\n         *     this.val = val;\n         *     this.next = null;\n         * }\n         */\n\n        /**\n         * @param {ListNode} head\n         * @return {ListNode}\n         */\n        var detectCycle = function(head) {\n            let res = [];\n            while(head != null){\n                if(res.includes(head)){\n                    return head;\n                }else{\n                    res.push(head);\n                }\n                head = head.next;\n            }\n            return null;\n        };\n        解法三：双指针\n        思路\n        图解\n        截屏2020-01-05下午3.33.09.png\n        公式\n        S：初始点到环的入口点A的距离\n        m：环的入口点到快慢双指针在环内的相遇点B的距离\n        L：环的周长\n        如果 S == L - m\n        那么可以设置两个步数相同的指针分别从，链表入口节点和快慢双指针相遇节点同时出发\n        当他们第一次相遇时，即是环的入口节点A所在\n        因此，我们需要证明 S == L - m\n        已知快指针的行走距离是慢指针行走距离的两倍\n        那么他们在环内第一次相遇时\n        慢指针走过了：S + xL\n        快指针走过了：S + yL\n        那么，设C为指针走过的距离\n        C(快) - C(慢) = (y-x)L = nL\n        C(慢) = S + m\n        因为C(快) == 2C(慢)\n        所以C(快) - C(慢) == C(慢)\n        S + m = nL\n        S = nL - m\n        而L为环的周长 ，n为任意正整数\n        所以 S == L - m 成立\n        解即为反证法的操作\n        判断链表是否有环\n        思路同-141. 环形链表-解法三\n        /**\n         * Definition for singly-linked list.\n         * function ListNode(val) {\n         *     this.val = val;\n         *     this.next = null;\n         * }\n         */\n\n        /**\n         * @param {ListNode} head\n         * @return {ListNode}\n         */\n        var detectCycle = function(head) {\n            if(!head || !head.next) return null;\n            let slow = head;\n            let fast = head;\n            let start = head;\n            while (fast != null && fast.next != null) {\n                slow = slow.next;\n                fast = fast.next.next;\n                if (slow == fast) {\n                    while (start != slow) {\n                        slow = slow.next;\n                        start = start.next;\n                    }\n                    return slow;\n                }\n            }\n            return null;\n        };\n    `\n};\nexport default Linked_List_Cycle_II;","map":{"version":3,"sources":["/Users/yabao/Documents/githubspace/Jutsai-Lab/src/apps/bao/baoApp/views/examples/JsLeetcode/js/Linked_List_Array/Linked_List_Cycle_II.js"],"names":["Linked_List_Cycle_II","id","name","refLink","level","tag","notes","jsSolution"],"mappings":"AAAA,MAAMA,oBAAoB,GAAG;AACzBC,EAAAA,EAAE,EAAE,MADqB;AAEzBC,EAAAA,IAAI,EAAE,sBAFmB;AAGzBC,EAAAA,OAAO,EAAE,CACL,0GADK,EAEL,mEAFK,EAGL,yDAHK,CAHgB;AAQzBC,EAAAA,KAAK,EAAE,MARkB;AASzBC,EAAAA,GAAG,EAAE,EAToB;AAUzBC,EAAAA,KAAK,EAAG,EAViB;AAWzBC,EAAAA,UAAU,EAAG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAXY,CAA7B;AAkIA,eAAeP,oBAAf","sourcesContent":["const Linked_List_Cycle_II = {\n    id: '0045',\n    name: 'Linked_List_Cycle_II',\n    refLink: [\n        'https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/142-huan-xing-lian-biao-ii-by-alexer-660/',\n        'https://www.lintcode.com/problem/linked-list-cycle-ii/description',\n        'https://www.jiuzhang.com/solution/linked-list-cycle-ii/'\n    ],\n    level: 'Hard',\n    tag: [],\n    notes: ``,\n    jsSolution: `\n        // Given a linked list, return the node where the cycle begins.\n\n        // If there is no cycle, return null.\n        \n        // 在线评测地址: https://www.lintcode.com/problem/linked-list-cycle-ii/\n\n        解法一：标记法\n        思路同-141. 环形链表-解法二\n        /**\n         * Definition for singly-linked list.\n         * function ListNode(val) {\n         *     this.val = val;\n         *     this.next = null;\n         * }\n         */\n\n        /**\n         * @param {ListNode} head\n         * @return {ListNode}\n         */\n        var detectCycle = function(head) {\n            while(head && head.next){\n                if(head.flag){\n                    return head;\n                }else{\n                    head.flag = 1;\n                    head = head.next;\n                }\n            }\n            return null;\n        };\n        解法二：数组判重\n        思路同-141. 环形链表-解法一\n        /**\n         * Definition for singly-linked list.\n         * function ListNode(val) {\n         *     this.val = val;\n         *     this.next = null;\n         * }\n         */\n\n        /**\n         * @param {ListNode} head\n         * @return {ListNode}\n         */\n        var detectCycle = function(head) {\n            let res = [];\n            while(head != null){\n                if(res.includes(head)){\n                    return head;\n                }else{\n                    res.push(head);\n                }\n                head = head.next;\n            }\n            return null;\n        };\n        解法三：双指针\n        思路\n        图解\n        截屏2020-01-05下午3.33.09.png\n        公式\n        S：初始点到环的入口点A的距离\n        m：环的入口点到快慢双指针在环内的相遇点B的距离\n        L：环的周长\n        如果 S == L - m\n        那么可以设置两个步数相同的指针分别从，链表入口节点和快慢双指针相遇节点同时出发\n        当他们第一次相遇时，即是环的入口节点A所在\n        因此，我们需要证明 S == L - m\n        已知快指针的行走距离是慢指针行走距离的两倍\n        那么他们在环内第一次相遇时\n        慢指针走过了：S + xL\n        快指针走过了：S + yL\n        那么，设C为指针走过的距离\n        C(快) - C(慢) = (y-x)L = nL\n        C(慢) = S + m\n        因为C(快) == 2C(慢)\n        所以C(快) - C(慢) == C(慢)\n        S + m = nL\n        S = nL - m\n        而L为环的周长 ，n为任意正整数\n        所以 S == L - m 成立\n        解即为反证法的操作\n        判断链表是否有环\n        思路同-141. 环形链表-解法三\n        /**\n         * Definition for singly-linked list.\n         * function ListNode(val) {\n         *     this.val = val;\n         *     this.next = null;\n         * }\n         */\n\n        /**\n         * @param {ListNode} head\n         * @return {ListNode}\n         */\n        var detectCycle = function(head) {\n            if(!head || !head.next) return null;\n            let slow = head;\n            let fast = head;\n            let start = head;\n            while (fast != null && fast.next != null) {\n                slow = slow.next;\n                fast = fast.next.next;\n                if (slow == fast) {\n                    while (start != slow) {\n                        slow = slow.next;\n                        start = start.next;\n                    }\n                    return slow;\n                }\n            }\n            return null;\n        };\n    `\n}\n\nexport default Linked_List_Cycle_II\n"]},"metadata":{},"sourceType":"module"}