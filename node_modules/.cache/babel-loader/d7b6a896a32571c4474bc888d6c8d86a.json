{"ast":null,"code":"var Linked_List_Cycle_II={id:'0045',name:'Linked_List_Cycle_II',refLink:['https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/142-huan-xing-lian-biao-ii-by-alexer-660/','https://www.lintcode.com/problem/linked-list-cycle-ii/description','https://www.jiuzhang.com/solution/linked-list-cycle-ii/'],level:'Hard',tag:[],notes:\"\",jsSolution:\"\\n        // Given a linked list, return the node where the cycle begins.\\n\\n        // If there is no cycle, return null.\\n        \\n        // \\u5728\\u7EBF\\u8BC4\\u6D4B\\u5730\\u5740: https://www.lintcode.com/problem/linked-list-cycle-ii/\\n\\n        \\u89E3\\u6CD5\\u4E00\\uFF1A\\u6807\\u8BB0\\u6CD5\\n        \\u601D\\u8DEF\\u540C-141. \\u73AF\\u5F62\\u94FE\\u8868-\\u89E3\\u6CD5\\u4E8C\\n        /**\\n         * Definition for singly-linked list.\\n         * function ListNode(val) {\\n         *     this.val = val;\\n         *     this.next = null;\\n         * }\\n         */\\n\\n        /**\\n         * @param {ListNode} head\\n         * @return {ListNode}\\n         */\\n        var detectCycle = function(head) {\\n            while(head && head.next){\\n                if(head.flag){\\n                    return head;\\n                }else{\\n                    head.flag = 1;\\n                    head = head.next;\\n                }\\n            }\\n            return null;\\n        };\\n        \\u89E3\\u6CD5\\u4E8C\\uFF1A\\u6570\\u7EC4\\u5224\\u91CD\\n        \\u601D\\u8DEF\\u540C-141. \\u73AF\\u5F62\\u94FE\\u8868-\\u89E3\\u6CD5\\u4E00\\n        /**\\n         * Definition for singly-linked list.\\n         * function ListNode(val) {\\n         *     this.val = val;\\n         *     this.next = null;\\n         * }\\n         */\\n\\n        /**\\n         * @param {ListNode} head\\n         * @return {ListNode}\\n         */\\n        var detectCycle = function(head) {\\n            let res = [];\\n            while(head != null){\\n                if(res.includes(head)){\\n                    return head;\\n                }else{\\n                    res.push(head);\\n                }\\n                head = head.next;\\n            }\\n            return null;\\n        };\\n        \\u89E3\\u6CD5\\u4E09\\uFF1A\\u53CC\\u6307\\u9488\\n        \\u601D\\u8DEF\\n        \\u56FE\\u89E3\\n        \\u622A\\u5C4F2020-01-05\\u4E0B\\u53483.33.09.png\\n        \\u516C\\u5F0F\\n        S\\uFF1A\\u521D\\u59CB\\u70B9\\u5230\\u73AF\\u7684\\u5165\\u53E3\\u70B9A\\u7684\\u8DDD\\u79BB\\n        m\\uFF1A\\u73AF\\u7684\\u5165\\u53E3\\u70B9\\u5230\\u5FEB\\u6162\\u53CC\\u6307\\u9488\\u5728\\u73AF\\u5185\\u7684\\u76F8\\u9047\\u70B9B\\u7684\\u8DDD\\u79BB\\n        L\\uFF1A\\u73AF\\u7684\\u5468\\u957F\\n        \\u5982\\u679C S == L - m\\n        \\u90A3\\u4E48\\u53EF\\u4EE5\\u8BBE\\u7F6E\\u4E24\\u4E2A\\u6B65\\u6570\\u76F8\\u540C\\u7684\\u6307\\u9488\\u5206\\u522B\\u4ECE\\uFF0C\\u94FE\\u8868\\u5165\\u53E3\\u8282\\u70B9\\u548C\\u5FEB\\u6162\\u53CC\\u6307\\u9488\\u76F8\\u9047\\u8282\\u70B9\\u540C\\u65F6\\u51FA\\u53D1\\n        \\u5F53\\u4ED6\\u4EEC\\u7B2C\\u4E00\\u6B21\\u76F8\\u9047\\u65F6\\uFF0C\\u5373\\u662F\\u73AF\\u7684\\u5165\\u53E3\\u8282\\u70B9A\\u6240\\u5728\\n        \\u56E0\\u6B64\\uFF0C\\u6211\\u4EEC\\u9700\\u8981\\u8BC1\\u660E S == L - m\\n        \\u5DF2\\u77E5\\u5FEB\\u6307\\u9488\\u7684\\u884C\\u8D70\\u8DDD\\u79BB\\u662F\\u6162\\u6307\\u9488\\u884C\\u8D70\\u8DDD\\u79BB\\u7684\\u4E24\\u500D\\n        \\u90A3\\u4E48\\u4ED6\\u4EEC\\u5728\\u73AF\\u5185\\u7B2C\\u4E00\\u6B21\\u76F8\\u9047\\u65F6\\n        \\u6162\\u6307\\u9488\\u8D70\\u8FC7\\u4E86\\uFF1AS + xL\\n        \\u5FEB\\u6307\\u9488\\u8D70\\u8FC7\\u4E86\\uFF1AS + yL\\n        \\u90A3\\u4E48\\uFF0C\\u8BBEC\\u4E3A\\u6307\\u9488\\u8D70\\u8FC7\\u7684\\u8DDD\\u79BB\\n        C(\\u5FEB) - C(\\u6162) = (y-x)L = nL\\n        C(\\u6162) = S + m\\n        \\u56E0\\u4E3AC(\\u5FEB) == 2C(\\u6162)\\n        \\u6240\\u4EE5C(\\u5FEB) - C(\\u6162) == C(\\u6162)\\n        S + m = nL\\n        S = nL - m\\n        \\u800CL\\u4E3A\\u73AF\\u7684\\u5468\\u957F \\uFF0Cn\\u4E3A\\u4EFB\\u610F\\u6B63\\u6574\\u6570\\n        \\u6240\\u4EE5 S == L - m \\u6210\\u7ACB\\n        \\u89E3\\u5373\\u4E3A\\u53CD\\u8BC1\\u6CD5\\u7684\\u64CD\\u4F5C\\n        \\u5224\\u65AD\\u94FE\\u8868\\u662F\\u5426\\u6709\\u73AF\\n        \\u601D\\u8DEF\\u540C-141. \\u73AF\\u5F62\\u94FE\\u8868-\\u89E3\\u6CD5\\u4E09\\n        /**\\n         * Definition for singly-linked list.\\n         * function ListNode(val) {\\n         *     this.val = val;\\n         *     this.next = null;\\n         * }\\n         */\\n\\n        /**\\n         * @param {ListNode} head\\n         * @return {ListNode}\\n         */\\n        var detectCycle = function(head) {\\n            if(!head || !head.next) return null;\\n            let slow = head;\\n            let fast = head;\\n            let start = head;\\n            while (fast != null && fast.next != null) {\\n                slow = slow.next;\\n                fast = fast.next.next;\\n                if (slow == fast) {\\n                    while (start != slow) {\\n                        slow = slow.next;\\n                        start = start.next;\\n                    }\\n                    return slow;\\n                }\\n            }\\n            return null;\\n        };\\n    \"};export default Linked_List_Cycle_II;","map":{"version":3,"sources":["/Users/yabao/Documents/githubspace/Jutsai-Lab/src/apps/bao/baoApp/views/examples/JsLeetcode/js/Linked_List_Array/Linked_List_Cycle_II.js"],"names":["Linked_List_Cycle_II","id","name","refLink","level","tag","notes","jsSolution"],"mappings":"AAAA,GAAMA,CAAAA,oBAAoB,CAAG,CACzBC,EAAE,CAAE,MADqB,CAEzBC,IAAI,CAAE,sBAFmB,CAGzBC,OAAO,CAAE,CACL,0GADK,CAEL,mEAFK,CAGL,yDAHK,CAHgB,CAQzBC,KAAK,CAAE,MARkB,CASzBC,GAAG,CAAE,EAToB,CAUzBC,KAAK,GAVoB,CAWzBC,UAAU,u8IAXe,CAA7B,CAkIA,cAAeP,CAAAA,oBAAf","sourcesContent":["const Linked_List_Cycle_II = {\n    id: '0045',\n    name: 'Linked_List_Cycle_II',\n    refLink: [\n        'https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/142-huan-xing-lian-biao-ii-by-alexer-660/',\n        'https://www.lintcode.com/problem/linked-list-cycle-ii/description',\n        'https://www.jiuzhang.com/solution/linked-list-cycle-ii/'\n    ],\n    level: 'Hard',\n    tag: [],\n    notes: ``,\n    jsSolution: `\n        // Given a linked list, return the node where the cycle begins.\n\n        // If there is no cycle, return null.\n        \n        // 在线评测地址: https://www.lintcode.com/problem/linked-list-cycle-ii/\n\n        解法一：标记法\n        思路同-141. 环形链表-解法二\n        /**\n         * Definition for singly-linked list.\n         * function ListNode(val) {\n         *     this.val = val;\n         *     this.next = null;\n         * }\n         */\n\n        /**\n         * @param {ListNode} head\n         * @return {ListNode}\n         */\n        var detectCycle = function(head) {\n            while(head && head.next){\n                if(head.flag){\n                    return head;\n                }else{\n                    head.flag = 1;\n                    head = head.next;\n                }\n            }\n            return null;\n        };\n        解法二：数组判重\n        思路同-141. 环形链表-解法一\n        /**\n         * Definition for singly-linked list.\n         * function ListNode(val) {\n         *     this.val = val;\n         *     this.next = null;\n         * }\n         */\n\n        /**\n         * @param {ListNode} head\n         * @return {ListNode}\n         */\n        var detectCycle = function(head) {\n            let res = [];\n            while(head != null){\n                if(res.includes(head)){\n                    return head;\n                }else{\n                    res.push(head);\n                }\n                head = head.next;\n            }\n            return null;\n        };\n        解法三：双指针\n        思路\n        图解\n        截屏2020-01-05下午3.33.09.png\n        公式\n        S：初始点到环的入口点A的距离\n        m：环的入口点到快慢双指针在环内的相遇点B的距离\n        L：环的周长\n        如果 S == L - m\n        那么可以设置两个步数相同的指针分别从，链表入口节点和快慢双指针相遇节点同时出发\n        当他们第一次相遇时，即是环的入口节点A所在\n        因此，我们需要证明 S == L - m\n        已知快指针的行走距离是慢指针行走距离的两倍\n        那么他们在环内第一次相遇时\n        慢指针走过了：S + xL\n        快指针走过了：S + yL\n        那么，设C为指针走过的距离\n        C(快) - C(慢) = (y-x)L = nL\n        C(慢) = S + m\n        因为C(快) == 2C(慢)\n        所以C(快) - C(慢) == C(慢)\n        S + m = nL\n        S = nL - m\n        而L为环的周长 ，n为任意正整数\n        所以 S == L - m 成立\n        解即为反证法的操作\n        判断链表是否有环\n        思路同-141. 环形链表-解法三\n        /**\n         * Definition for singly-linked list.\n         * function ListNode(val) {\n         *     this.val = val;\n         *     this.next = null;\n         * }\n         */\n\n        /**\n         * @param {ListNode} head\n         * @return {ListNode}\n         */\n        var detectCycle = function(head) {\n            if(!head || !head.next) return null;\n            let slow = head;\n            let fast = head;\n            let start = head;\n            while (fast != null && fast.next != null) {\n                slow = slow.next;\n                fast = fast.next.next;\n                if (slow == fast) {\n                    while (start != slow) {\n                        slow = slow.next;\n                        start = start.next;\n                    }\n                    return slow;\n                }\n            }\n            return null;\n        };\n    `\n}\n\nexport default Linked_List_Cycle_II\n"]},"metadata":{},"sourceType":"module"}