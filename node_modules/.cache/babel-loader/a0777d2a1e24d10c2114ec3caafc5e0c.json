{"ast":null,"code":"const Zombie_in_Matrix = {\n  id: '0033',\n  name: 'Zombie_in_Matrix',\n  refLink: ['https://www.lintcode.com/problem/zombie-in-matrix/description', 'https://www.jiuzhang.com/solution/zombie-in-matrix/#tag-highlight'],\n  level: 'Medium',\n  tag: [''],\n  notes: `JAVA only`,\n  jsSolution: `\n        // Given a 2D grid, each cell is either a wall 2, a zombie 1 or people 0 (the number zero, one, two).Zombies can turn the nearest people(up/down/left/right) into zombies every day, but can not through wall. How long will it take to turn all people into zombies? Return -1 if can not turn all people into zombies.\n\n        // 在线评测地址: https://www.lintcode.com/problem/zombie-in-matrix/\n\n\n        class Coordinate {\n            int x, y;\n            public Coordinate(int x, int y) {\n                this.x = x;\n                this.y = y;\n            }\n        }\n        \n        public class Solution {\n            public int PEOPLE = 0;\n            public int ZOMBIE = 1;\n            public int WALL = 2;\n            \n            public int[] deltaX = {1, 0, 0, -1};\n            public int[] deltaY = {0, 1, -1, 0};\n             \n            /**\n             * @param grid a 2D integer grid\n             * @return an integer\n             */\n            public int zombie(int[][] grid) {\n                if (grid == null || grid.length == 0 || grid[0].length == 0) {\n                    return 0;\n                }\n                \n                int n = grid.length;\n                int m = grid[0].length;\n                \n                // initialize the queue & count people\n                int people = 0;\n                Queue<Coordinate> queue = new LinkedList<>();\n                for (int i = 0; i < n; i++) {\n                    for (int j = 0; j < m; j++) {\n                        if (grid[i][j] == PEOPLE) {\n                            people++;\n                        } else if (grid[i][j] == ZOMBIE) {\n                            queue.offer(new Coordinate(i, j));\n                        }\n                    }\n                }\n                \n                // corner case\n                if (people == 0) {\n                    return 0;\n                }\n                \n                // bfs\n                int days = 0;\n                while (!queue.isEmpty()) {\n                    days++;\n                    int size = queue.size();\n                    for (int i = 0; i < size; i++) {\n                        Coordinate zb = queue.poll();\n                        for (int direction = 0; direction < 4; direction++) {\n                            Coordinate adj = new Coordinate(\n                                zb.x + deltaX[direction],\n                                zb.y + deltaY[direction]\n                            );\n                            \n                            if (!isPeople(adj, grid)) {\n                                continue;\n                            }\n                            \n                            grid[adj.x][adj.y] = ZOMBIE;\n                            people--;\n                            if (people == 0) {\n                                return days;\n                            }\n                            queue.offer(adj);\n                        }\n                    }\n                }\n                \n                return -1;\n            }\n            \n            private boolean isPeople(Coordinate coor, int[][] grid) {\n                int n = grid.length;\n                int m = grid[0].length;\n                \n                if (coor.x < 0 || coor.x >= n) {\n                    return false;\n                }\n                if (coor.y < 0 || coor.y >= m) {\n                    return false;\n                }\n                return (grid[coor.x][coor.y] == PEOPLE);\n            }\n        }\n        \n        //version 硅谷算法班\n        public class Solution {\n            /**\n             * @param grid: a 2D integer grid\n             * @return: an integer\n             */\n            public int zombie(int[][] grid) {\n                // write your code here\n                if (grid == null || grid.length == 0 || grid[0].length == 0) {\n                    return 0;\n                }\n                Queue<Integer> qx = new LinkedList<>();\n                Queue<Integer> qy = new LinkedList<>();\n                boolean[][] v = new boolean[grid.length][grid[0].length];\n        \n                for (int i = 0; i < grid.length; i++) {\n                    for (int j = 0; j < grid[0].length; j++) {\n                        if (grid[i][j] == 1) {\n                            qx.offer(i);\n                            qy.offer(j);\n                            v[i][j] = true;\n                        }\n                    }\n                }\n        \n                int[] dx = {1, -1, 0, 0};\n                int[] dy = {0, 0, 1, -1};\n        \n                int dist = 0;\n                while (!qx.isEmpty()) {\n                    dist++;\n                    int size = qx.size();\n                    for (int i = 0; i < size; i++) {\n                        int cx = qx.poll();\n                        int cy = qy.poll();\n                        for (int k = 0; k < 4; k++) {\n                            int nx = cx + dx[k];\n                            int ny = cy + dy[k];\n                            if (0 <= nx && nx < grid.length && 0 <= ny && ny < grid[0].length && grid[nx][ny] == 0 && !v[nx][ny]) {\n                                qx.offer(nx);\n                                qy.offer(ny);\n                                v[nx][ny] = true;\n                            }\n                        }\n                    }\n                }\n                dist--;\n        \n                for (int i = 0; i < grid.length; i++) {\n                    for (int j = 0; j < grid[0].length; j++) {\n                        if (grid[i][j] == 0 && !v[i][j]) {\n                            return -1;\n                        }\n                    }\n                }\n        \n                return dist;\n            }\n        }\n    `\n};\nexport default Zombie_in_Matrix;","map":{"version":3,"sources":["/Users/yabao/Documents/githubspace/Jutsai-Lab/src/apps/bao/baoApp/views/examples/JsLeetcode/js/Breadth_First_Search/Zombie_in_Matrix.js"],"names":["Zombie_in_Matrix","id","name","refLink","level","tag","notes","jsSolution"],"mappings":"AAAA,MAAMA,gBAAgB,GAAG;AACrBC,EAAAA,EAAE,EAAE,MADiB;AAErBC,EAAAA,IAAI,EAAE,kBAFe;AAGrBC,EAAAA,OAAO,EAAE,CACL,+DADK,EAEL,mEAFK,CAHY;AAOrBC,EAAAA,KAAK,EAAE,QAPc;AAQrBC,EAAAA,GAAG,EAAE,CACD,EADC,CARgB;AAWrBC,EAAAA,KAAK,EAAG,WAXa;AAYrBC,EAAAA,UAAU,EAAG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAZQ,CAAzB;AA0KA,eAAeP,gBAAf","sourcesContent":["const Zombie_in_Matrix = {\n    id: '0033',\n    name: 'Zombie_in_Matrix',\n    refLink: [\n        'https://www.lintcode.com/problem/zombie-in-matrix/description',\n        'https://www.jiuzhang.com/solution/zombie-in-matrix/#tag-highlight'\n    ],\n    level: 'Medium',\n    tag: [\n        ''\n    ],\n    notes: `JAVA only`,\n    jsSolution: `\n        // Given a 2D grid, each cell is either a wall 2, a zombie 1 or people 0 (the number zero, one, two).Zombies can turn the nearest people(up/down/left/right) into zombies every day, but can not through wall. How long will it take to turn all people into zombies? Return -1 if can not turn all people into zombies.\n\n        // 在线评测地址: https://www.lintcode.com/problem/zombie-in-matrix/\n\n\n        class Coordinate {\n            int x, y;\n            public Coordinate(int x, int y) {\n                this.x = x;\n                this.y = y;\n            }\n        }\n        \n        public class Solution {\n            public int PEOPLE = 0;\n            public int ZOMBIE = 1;\n            public int WALL = 2;\n            \n            public int[] deltaX = {1, 0, 0, -1};\n            public int[] deltaY = {0, 1, -1, 0};\n             \n            /**\n             * @param grid a 2D integer grid\n             * @return an integer\n             */\n            public int zombie(int[][] grid) {\n                if (grid == null || grid.length == 0 || grid[0].length == 0) {\n                    return 0;\n                }\n                \n                int n = grid.length;\n                int m = grid[0].length;\n                \n                // initialize the queue & count people\n                int people = 0;\n                Queue<Coordinate> queue = new LinkedList<>();\n                for (int i = 0; i < n; i++) {\n                    for (int j = 0; j < m; j++) {\n                        if (grid[i][j] == PEOPLE) {\n                            people++;\n                        } else if (grid[i][j] == ZOMBIE) {\n                            queue.offer(new Coordinate(i, j));\n                        }\n                    }\n                }\n                \n                // corner case\n                if (people == 0) {\n                    return 0;\n                }\n                \n                // bfs\n                int days = 0;\n                while (!queue.isEmpty()) {\n                    days++;\n                    int size = queue.size();\n                    for (int i = 0; i < size; i++) {\n                        Coordinate zb = queue.poll();\n                        for (int direction = 0; direction < 4; direction++) {\n                            Coordinate adj = new Coordinate(\n                                zb.x + deltaX[direction],\n                                zb.y + deltaY[direction]\n                            );\n                            \n                            if (!isPeople(adj, grid)) {\n                                continue;\n                            }\n                            \n                            grid[adj.x][adj.y] = ZOMBIE;\n                            people--;\n                            if (people == 0) {\n                                return days;\n                            }\n                            queue.offer(adj);\n                        }\n                    }\n                }\n                \n                return -1;\n            }\n            \n            private boolean isPeople(Coordinate coor, int[][] grid) {\n                int n = grid.length;\n                int m = grid[0].length;\n                \n                if (coor.x < 0 || coor.x >= n) {\n                    return false;\n                }\n                if (coor.y < 0 || coor.y >= m) {\n                    return false;\n                }\n                return (grid[coor.x][coor.y] == PEOPLE);\n            }\n        }\n        \n        //version 硅谷算法班\n        public class Solution {\n            /**\n             * @param grid: a 2D integer grid\n             * @return: an integer\n             */\n            public int zombie(int[][] grid) {\n                // write your code here\n                if (grid == null || grid.length == 0 || grid[0].length == 0) {\n                    return 0;\n                }\n                Queue<Integer> qx = new LinkedList<>();\n                Queue<Integer> qy = new LinkedList<>();\n                boolean[][] v = new boolean[grid.length][grid[0].length];\n        \n                for (int i = 0; i < grid.length; i++) {\n                    for (int j = 0; j < grid[0].length; j++) {\n                        if (grid[i][j] == 1) {\n                            qx.offer(i);\n                            qy.offer(j);\n                            v[i][j] = true;\n                        }\n                    }\n                }\n        \n                int[] dx = {1, -1, 0, 0};\n                int[] dy = {0, 0, 1, -1};\n        \n                int dist = 0;\n                while (!qx.isEmpty()) {\n                    dist++;\n                    int size = qx.size();\n                    for (int i = 0; i < size; i++) {\n                        int cx = qx.poll();\n                        int cy = qy.poll();\n                        for (int k = 0; k < 4; k++) {\n                            int nx = cx + dx[k];\n                            int ny = cy + dy[k];\n                            if (0 <= nx && nx < grid.length && 0 <= ny && ny < grid[0].length && grid[nx][ny] == 0 && !v[nx][ny]) {\n                                qx.offer(nx);\n                                qy.offer(ny);\n                                v[nx][ny] = true;\n                            }\n                        }\n                    }\n                }\n                dist--;\n        \n                for (int i = 0; i < grid.length; i++) {\n                    for (int j = 0; j < grid[0].length; j++) {\n                        if (grid[i][j] == 0 && !v[i][j]) {\n                            return -1;\n                        }\n                    }\n                }\n        \n                return dist;\n            }\n        }\n    `\n}\n\nexport default Zombie_in_Matrix\n"]},"metadata":{},"sourceType":"module"}