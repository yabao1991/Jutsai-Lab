{"ast":null,"code":"var Reverse_Nodes_in_k_Group={id:'0042',name:'Reverse_Nodes_in_k_Group',refLink:['https://leetcode-cn.com/problems/reverse-nodes-in-k-group/solution/25-k-ge-yi-zu-fan-zhuan-lian-biao-by-alexer-660/','https://www.lintcode.com/problem/reverse-nodes-in-k-group/description','https://www.jiuzhang.com/solution/reverse-nodes-in-k-group/'],level:'Hard',tag:[],notes:\"\",jsSolution:\"\\n        // Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.\\n\\n        // If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.\\n        \\n        // You may not alter the values in the nodes, only nodes itself may be changed.\\n        // Only constant memory is allowed.\\n        \\n        // \\u5728\\u7EBF\\u8BC4\\u6D4B\\u5730\\u5740: https://www.lintcode.com/problem/reverse-nodes-in-k-group/\\n\\n        \\u89E3\\u6CD5\\u4E00\\uFF1A\\u8FED\\u4EE3\\n        \\u601D\\u8DEF\\u540C206. \\u53CD\\u8F6C\\u94FE\\u8868 - \\u89E3\\u6CD5\\u4E00\\n        \\u533A\\u522B\\n        \\u9650\\u5236k\\u4E2A\\n        \\u7528\\u8BA1\\u6570\\u5B9E\\u73B0\\uFF0C\\u5B9E\\u65F6\\u66F4\\u65B0\\u94FE\\u8868\\u9700\\u8981\\u53CD\\u8F6C\\u90E8\\u5206\\u7684\\u5934\\u3001\\u5C3E\\u8282\\u70B9\\n        /**\\n         * Definition for singly-linked list.\\n         * function ListNode(val) {\\n         *     this.val = val;\\n         *     this.next = null;\\n         * }\\n         */\\n        /**\\n         * @param {ListNode} head\\n         * @param {number} k\\n         * @return {ListNode}\\n         */\\n        var reverseKGroup = function(head, k) {\\n            let cur = head;\\n            let count = 0;\\n            // \\u6C42k\\u4E2A\\u5F85\\u53CD\\u8F6C\\u5143\\u7D20\\u7684\\u9996\\u8282\\u70B9\\u548C\\u5C3E\\u8282\\u70B9\\n            while(cur != null && count != k){\\n                cur = cur.next;\\n                count++;\\n            }\\n            // \\u8DB3\\u591Fk\\u4E2A\\u8282\\u70B9\\uFF0C\\u53BB\\u53CD\\u8F6C\\n            if(count == k){\\n                // \\u9012\\u5F52\\u94FE\\u63A5\\u540E\\u7EEDk\\u4E2A\\u53CD\\u8F6C\\u7684\\u94FE\\u8868\\u5934\\u8282\\u70B9\\n                cur = reverseKGroup(cur,k);\\n                while(count != 0){\\n                    count--;\\n                    // \\u53CD\\u8F6C\\u94FE\\u8868\\n                    let tmp = head.next;\\n                    head.next = cur;\\n                    cur = head;\\n                    head = tmp;\\n                }\\n                head = cur;\\n            }\\n            return head;\\n        };\\n        \\u89E3\\u6CD5\\u4E8C\\uFF1A\\u9012\\u5F52 II\\n        \\u540C\\u89E3\\u6CD5\\u4E00\\n        \\u533A\\u522B\\n        while\\u6539\\u6210for\\n        /**\\n         * Definition for singly-linked list.\\n         * function ListNode(val) {\\n         *     this.val = val;\\n         *     this.next = null;\\n         * }\\n         */\\n        /**\\n         * @param {ListNode} head\\n         * @param {number} k\\n         * @return {ListNode}\\n         */\\n        var reverseKGroup = function(head, k) {\\n            if(!head) return null;\\n            // \\u53CD\\u8F6C\\u94FE\\u8868\\n            let reverse = (a,b) => {\\n                let pre;\\n                let cur = a;\\n                let next = b;\\n                while(cur != b){\\n                    next = cur.next;\\n                    cur.next = pre;\\n                    pre = cur;\\n                    cur = next;\\n                }\\n                return pre;\\n            }\\n            // \\u53CD\\u8F6C\\u533A\\u95F4a-b\\u7684k\\u4E2A\\u5F85\\u53CD\\u8F6C\\u7684\\u5143\\u7D20\\n            let a = head;\\n            let b = head;\\n            for(let i = 0;i < k;i++){\\n                // \\u4E0D\\u8DB3k\\u4E2A\\uFF0C\\u4E0D\\u9700\\u8981\\u53CD\\u8F6C\\n                if(!b) return head;\\n                b = b.next;\\n            }\\n            // \\u53CD\\u8F6C\\u524Dk\\u4E2A\\u5143\\u7D20\\n            let newHead = reverse(a,b);\\n            // \\u9012\\u5F52\\u94FE\\u63A5\\u540E\\u7EED\\u53CD\\u8F6C\\u94FE\\u8868\\n            a.next = reverseKGroup(b,k);\\n            return newHead;\\n        };\\n        \\u89E3\\u6CD5\\u4E09\\uFF1A\\u6808\\u89E3\\n        \\u601D\\u8DEF\\u540C206. \\u53CD\\u8F6C\\u94FE\\u8868 - \\u89E3\\u6CD5\\u56DB\\n        \\u533A\\u522B\\n        \\u53CD\\u8F6Ck\\u4E2A\\n        /**\\n         * Definition for singly-linked list.\\n         * function ListNode(val) {\\n         *     this.val = val;\\n         *     this.next = null;\\n         * }\\n         */\\n        /**\\n         * @param {ListNode} head\\n         * @param {number} k\\n         * @return {ListNode}\\n         */\\n        var reverseKGroup = function(head, k) {\\n            let stack = [];\\n            let preHead = new ListNode(0);\\n            let pre = preHead;\\n            // \\u5FAA\\u73AF\\u94FE\\u63A5\\u540E\\u7EED\\u53CD\\u8F6C\\u94FE\\u8868\\n            while(true){\\n                let count = 0;\\n                let tmp = head;\\n                while(tmp && count < k){\\n                    stack.push(tmp);\\n                    tmp = tmp.next;\\n                    count++;\\n                }\\n                // \\u4E0D\\u591Fk\\u4E2A\\uFF0C\\u76F4\\u63A5\\u94FE\\u63A5\\u5269\\u4E0B\\u94FE\\u8868\\u8FD4\\u56DE\\n                if(count != k){\\n                    pre.next = head;\\n                    break;\\n                }\\n                // \\u51FA\\u6808\\u5373\\u662F\\u53CD\\u8F6C\\n                while(stack.length > 0){\\n                    pre.next = stack.pop();\\n                    pre = pre.next;\\n                }\\n                pre.next = tmp;\\n                head = tmp;\\n            }\\n            return preHead.next;\\n        };\\n    \"};export default Reverse_Nodes_in_k_Group;","map":{"version":3,"sources":["/Users/yabao/Documents/githubspace/Jutsai-Lab/src/apps/bao/baoApp/views/examples/JsLeetcode/js/Linked_List_Array/Reverse_Nodes_in_k_Group.js"],"names":["Reverse_Nodes_in_k_Group","id","name","refLink","level","tag","notes","jsSolution"],"mappings":"AAAA,GAAMA,CAAAA,wBAAwB,CAAG,CAC7BC,EAAE,CAAE,MADyB,CAE7BC,IAAI,CAAE,0BAFuB,CAG7BC,OAAO,CAAE,CACL,qHADK,CAEL,uEAFK,CAGL,6DAHK,CAHoB,CAQ7BC,KAAK,CAAE,MARsB,CAS7BC,GAAG,CAAE,EATwB,CAU7BC,KAAK,GAVwB,CAW7BC,UAAU,8hKAXmB,CAAjC,CA0JA,cAAeP,CAAAA,wBAAf","sourcesContent":["const Reverse_Nodes_in_k_Group = { \n    id: '0042',\n    name: 'Reverse_Nodes_in_k_Group',\n    refLink: [\n        'https://leetcode-cn.com/problems/reverse-nodes-in-k-group/solution/25-k-ge-yi-zu-fan-zhuan-lian-biao-by-alexer-660/',\n        'https://www.lintcode.com/problem/reverse-nodes-in-k-group/description',\n        'https://www.jiuzhang.com/solution/reverse-nodes-in-k-group/'\n    ],\n    level: 'Hard',\n    tag: [],\n    notes: ``,\n    jsSolution: `\n        // Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.\n\n        // If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.\n        \n        // You may not alter the values in the nodes, only nodes itself may be changed.\n        // Only constant memory is allowed.\n        \n        // 在线评测地址: https://www.lintcode.com/problem/reverse-nodes-in-k-group/\n\n        解法一：迭代\n        思路同206. 反转链表 - 解法一\n        区别\n        限制k个\n        用计数实现，实时更新链表需要反转部分的头、尾节点\n        /**\n         * Definition for singly-linked list.\n         * function ListNode(val) {\n         *     this.val = val;\n         *     this.next = null;\n         * }\n         */\n        /**\n         * @param {ListNode} head\n         * @param {number} k\n         * @return {ListNode}\n         */\n        var reverseKGroup = function(head, k) {\n            let cur = head;\n            let count = 0;\n            // 求k个待反转元素的首节点和尾节点\n            while(cur != null && count != k){\n                cur = cur.next;\n                count++;\n            }\n            // 足够k个节点，去反转\n            if(count == k){\n                // 递归链接后续k个反转的链表头节点\n                cur = reverseKGroup(cur,k);\n                while(count != 0){\n                    count--;\n                    // 反转链表\n                    let tmp = head.next;\n                    head.next = cur;\n                    cur = head;\n                    head = tmp;\n                }\n                head = cur;\n            }\n            return head;\n        };\n        解法二：递归 II\n        同解法一\n        区别\n        while改成for\n        /**\n         * Definition for singly-linked list.\n         * function ListNode(val) {\n         *     this.val = val;\n         *     this.next = null;\n         * }\n         */\n        /**\n         * @param {ListNode} head\n         * @param {number} k\n         * @return {ListNode}\n         */\n        var reverseKGroup = function(head, k) {\n            if(!head) return null;\n            // 反转链表\n            let reverse = (a,b) => {\n                let pre;\n                let cur = a;\n                let next = b;\n                while(cur != b){\n                    next = cur.next;\n                    cur.next = pre;\n                    pre = cur;\n                    cur = next;\n                }\n                return pre;\n            }\n            // 反转区间a-b的k个待反转的元素\n            let a = head;\n            let b = head;\n            for(let i = 0;i < k;i++){\n                // 不足k个，不需要反转\n                if(!b) return head;\n                b = b.next;\n            }\n            // 反转前k个元素\n            let newHead = reverse(a,b);\n            // 递归链接后续反转链表\n            a.next = reverseKGroup(b,k);\n            return newHead;\n        };\n        解法三：栈解\n        思路同206. 反转链表 - 解法四\n        区别\n        反转k个\n        /**\n         * Definition for singly-linked list.\n         * function ListNode(val) {\n         *     this.val = val;\n         *     this.next = null;\n         * }\n         */\n        /**\n         * @param {ListNode} head\n         * @param {number} k\n         * @return {ListNode}\n         */\n        var reverseKGroup = function(head, k) {\n            let stack = [];\n            let preHead = new ListNode(0);\n            let pre = preHead;\n            // 循环链接后续反转链表\n            while(true){\n                let count = 0;\n                let tmp = head;\n                while(tmp && count < k){\n                    stack.push(tmp);\n                    tmp = tmp.next;\n                    count++;\n                }\n                // 不够k个，直接链接剩下链表返回\n                if(count != k){\n                    pre.next = head;\n                    break;\n                }\n                // 出栈即是反转\n                while(stack.length > 0){\n                    pre.next = stack.pop();\n                    pre = pre.next;\n                }\n                pre.next = tmp;\n                head = tmp;\n            }\n            return preHead.next;\n        };\n    `\n}\n\nexport default Reverse_Nodes_in_k_Group\n"]},"metadata":{},"sourceType":"module"}