{"ast":null,"code":"const Search_Graph_Nodes = {\n  id: '0030',\n  name: 'Search_Graph_Nodes',\n  refLink: ['https://www.lintcode.com/problem/search-graph-nodes/description', 'https://www.jiuzhang.com/solution/search-graph-nodes/'],\n  level: 'Medium',\n  tag: [''],\n  notes: `JAVA only`,\n  jsSolution: `\n        // Given a undirected graph, a node and a target, return the nearest node to given node which value of it is target, return NULL if you can't find.\n\n        // There is a mapping store the nodes' values in the given parameters.\n        \n        // 在线评测地址: https://www.lintcode.com/problem/search-graph-nodes/\n\n        /**\n         * Definition for graph node.\n         * class GraphNode {\n         *     int label;\n         *     ArrayList<UndirectedGraphNode> neighbors;\n         *     UndirectedGraphNode(int x) { \n         *         label = x; neighbors = new ArrayList<UndirectedGraphNode>(); \n         *     }\n         * };\n         */\n        public class Solution {\n            /**\n             * @param graph a list of Undirected graph node\n             * @param values a hash mapping, <UndirectedGraphNode, (int)value>\n             * @param node an Undirected graph node\n             * @param target an integer\n             * @return the a node\n             */\n            public UndirectedGraphNode searchNode(ArrayList<UndirectedGraphNode> graph,\n                                                Map<UndirectedGraphNode, Integer> values,\n                                                UndirectedGraphNode node,\n                                                int target) {\n                // Write your code here\n                Queue<UndirectedGraphNode> queue = new LinkedList<UndirectedGraphNode>();\n                Set<UndirectedGraphNode> hash = new HashSet<UndirectedGraphNode>();\n\n                queue.offer(node);\n                hash.add(node);\n\n                while (!queue.isEmpty()) {\n                    UndirectedGraphNode head = queue.poll();\n                    if (values.get(head) == target) {\n                        return head;\n                    }\n                    for (UndirectedGraphNode nei : head.neighbors) {\n                        if (!hash.contains(nei)){\n                            queue.offer(nei);\n                            hash.add(nei);\n                        }\n                    }\n                }\n                return null;\n            }\n        }\n    `\n};\nexport default Search_Graph_Nodes;","map":{"version":3,"sources":["/Users/yabao/Documents/githubspace/Jutsai-Lab/src/apps/bao/baoApp/views/examples/JsLeetcode/js/Breadth_First_Search/Search_Graph_Nodes.js"],"names":["Search_Graph_Nodes","id","name","refLink","level","tag","notes","jsSolution"],"mappings":"AAAA,MAAMA,kBAAkB,GAAG;AACvBC,EAAAA,EAAE,EAAE,MADmB;AAEvBC,EAAAA,IAAI,EAAE,oBAFiB;AAGvBC,EAAAA,OAAO,EAAE,CACL,iEADK,EAEL,uDAFK,CAHc;AAOvBC,EAAAA,KAAK,EAAE,QAPgB;AAQvBC,EAAAA,GAAG,EAAE,CACD,EADC,CARkB;AAWvBC,EAAAA,KAAK,EAAG,WAXe;AAYvBC,EAAAA,UAAU,EAAG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAZU,CAA3B;AAkEA,eAAeP,kBAAf","sourcesContent":["const Search_Graph_Nodes = {\n    id: '0030',\n    name: 'Search_Graph_Nodes',\n    refLink: [\n        'https://www.lintcode.com/problem/search-graph-nodes/description',\n        'https://www.jiuzhang.com/solution/search-graph-nodes/'\n    ],\n    level: 'Medium',\n    tag: [\n        ''\n    ],\n    notes: `JAVA only`,\n    jsSolution: `\n        // Given a undirected graph, a node and a target, return the nearest node to given node which value of it is target, return NULL if you can't find.\n\n        // There is a mapping store the nodes' values in the given parameters.\n        \n        // 在线评测地址: https://www.lintcode.com/problem/search-graph-nodes/\n\n        /**\n         * Definition for graph node.\n         * class GraphNode {\n         *     int label;\n         *     ArrayList<UndirectedGraphNode> neighbors;\n         *     UndirectedGraphNode(int x) { \n         *         label = x; neighbors = new ArrayList<UndirectedGraphNode>(); \n         *     }\n         * };\n         */\n        public class Solution {\n            /**\n             * @param graph a list of Undirected graph node\n             * @param values a hash mapping, <UndirectedGraphNode, (int)value>\n             * @param node an Undirected graph node\n             * @param target an integer\n             * @return the a node\n             */\n            public UndirectedGraphNode searchNode(ArrayList<UndirectedGraphNode> graph,\n                                                Map<UndirectedGraphNode, Integer> values,\n                                                UndirectedGraphNode node,\n                                                int target) {\n                // Write your code here\n                Queue<UndirectedGraphNode> queue = new LinkedList<UndirectedGraphNode>();\n                Set<UndirectedGraphNode> hash = new HashSet<UndirectedGraphNode>();\n\n                queue.offer(node);\n                hash.add(node);\n\n                while (!queue.isEmpty()) {\n                    UndirectedGraphNode head = queue.poll();\n                    if (values.get(head) == target) {\n                        return head;\n                    }\n                    for (UndirectedGraphNode nei : head.neighbors) {\n                        if (!hash.contains(nei)){\n                            queue.offer(nei);\n                            hash.add(nei);\n                        }\n                    }\n                }\n                return null;\n            }\n        }\n    `\n}\n\nexport default Search_Graph_Nodes\n"]},"metadata":{},"sourceType":"module"}