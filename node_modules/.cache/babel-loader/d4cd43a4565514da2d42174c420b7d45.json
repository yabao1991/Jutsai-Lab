{"ast":null,"code":"const Word_Ladder = {\n  id: '0040',\n  name: 'Word_Ladder',\n  refLink: ['https://www.jiuzhang.com/solution/word-ladder/#tag-other-lang-javascript', 'https://www.lintcode.com/problem/word-ladder/description', 'https://leetcode-cn.com/problems/word-ladder/solution/127-dan-ci-jie-long-by-alexer-660/'],\n  level: 'Medium',\n  tag: [],\n  notes: ``,\n  jsSolution: `\n        // Given two words (start and end), and a dictionary, find the shortest transformation sequence from start to end, output the length of the sequence.\n        // Transformation rule such that:\n        \n        // Only one letter can be changed at a time\n        // Each intermediate word must exist in the dictionary. (Start and end words do not need to appear in the dictionary )\n        // 在线评测地址: https://www.lintcode.com/problem/word-ladder/\n\n        var ladderLength = function(beginWord, endWord, wordList) {\n            let queue = [beginWord];\n            let visitedMap  = {};\n            let count = 0;\n            while(queue.length != 0){\n                count ++;\n                const length = queue.length;\n                for(let i = 0; i < length; i ++){\n                    let node = queue.pop();\n                    if(node == endWord){\n                        return count;\n                    }\n                    const nextList = findNext(node, wordList, visitedMap);\n                    for(let j = 0; j < nextList.length; j ++){\n                        if(nextList[j] == endWord){\n                            return count + 1;\n                        }\n                        visitedMap[nextList[j]] = true;\n                        queue.unshift(nextList[j]);\n                    }\n                }\n            }\n            return 0;\n        };\n        function findNext(word, arr, visitedMap){\n            let result = [];\n            for(let i = 0;i < arr.length; i ++){\n                let ele = arr[i];\n                if(visitedMap[ele]){\n                    continue;\n                }\n                let diff = 0;\n                for(let j = 0;j < word.length; j ++){\n                    if(word.charAt(j) != ele.charAt(j)){\n                        diff ++;\n                    }\n                }\n                if(diff == 1){\n                    result.push(ele);\n                }\n            }\n            return result;\n        }\n\n        解法一：BFS\n        时间复杂度：O(M * N) ,M为单词长度，,N为单词列表长度\n        空间复杂度：O(M * N) ,M长度的单词化为邻接单词形式时需要M，N同上\n        用广度优先搜索搜索从beginWord到endWord的最短路径问题\n        思路分析\n        一个最短转换序列是 \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\",\n\n        从起点\"hit\"变换到终点\"cog\"\n        每次变换\n        只能变动其中一个单词\n        且必须在字典中\n        因此每次变换，其实就是走了一步\n        每次变换前后的单词差异只有其中一个字符\n        设唯一不同的字符为*\n        \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\"\n\n        hit ----> h*t <-----hot\n        dot ----> *ot <-----hot\n        dot ----> do* <-----dog\n        dog ----> *og <-----cog\n        我们把相差唯一一个字符的两个单词称为邻接单词\n        因此 单词'xyz'的所有邻接单词为\n        '*yz'\n        'x*z'\n        'xy*'\n        因为单词的下一个变换单词即是邻接单词\n        例如我们要从'hit'变换到'hot'\n        hit的邻接单词形式有\n        *it\n        h*t\n        hi*\n        hot的邻接单词形式有\n        *ot\n        h*t\n        ho*\n        我们寻找他们相同的邻接单词形式\n        为h*t\n        反过来\n        符合h*t形式的单词有\n        hit\n        hot\n        因此在代码中，此处便是寻找下一邻接单词的关键逻辑\n        代码逻辑\n        求出wordList中的所有单词的所有邻接单词形式\n        将具有相同邻接单词形式的单词放在一个集合里\n        形如 hash[邻接单词形式] = [单词1,单词2,...,单词n]\n        当我们在寻找下一个邻接单词是谁时，我们通过求当前单词的邻接单词的形式，去枚举上一步的所有邻接单词形式的集合\n        存在则在邻接单词形式对应的单词集合里，遍历寻找符合的目标单词\n        找到，则返回\n        没找到，当前寻址步数++，继续寻址\n        我们将从起点 beginWord --> endWord 的寻址路线，抽象为队列\n        初始值是起点，入队\n        出队，通过邻接单词形式变换寻址，逻辑如上\n        核心逻辑在第一步\n        解题技巧\n        每个邻接单词形式对应的单词既有可能相同，会出现循环寻址即环的形式\n        例如 h*t -> hot、*ot -> hot\n        因此维护一个访问记录数组，访问比较过的单词，下次不再访问\n        /**\n         * @param {string} beginWord\n         * @param {string} endWord\n         * @param {string[]} wordList\n         * @return {number}\n         */\n        var ladderLength = function(beginWord, endWord, wordList) {\n            if(!endWord || wordList.indexOf(endWord) == -1){\n                return 0;\n            }\n            // 各个通用状态对应所有单词\n            var comboDicts = {};\n            var len = beginWord.length;\n            for(var i = 0;i<wordList.length;i++){\n                for(var r = 0;r<len;r++){\n                    var newWord = wordList[i].substring(0,r)+'*'+wordList[i].substring(r+1,len);\n                    (!comboDicts[newWord]) && (comboDicts[newWord] = []);\n                    comboDicts[newWord].push(wordList[i]);\n                }\n            }\n            // Queue for BFS\n            var queue = [[beginWord,1]];\n            // visited\n            var visited = {beginWord:true};\n            while(queue.length > 0){\n                var currNode = queue.shift();\n                var currWord = currNode[0];\n                var currLevel = currNode[1];\n                for(var i = 0;i < len;i++){\n                    // 通用状态\n                    var newWord = currWord.substring(0,i)+'*'+currWord.substring(i+1,len);\n                    if(newWord in comboDicts){\n                        var tmpWords = comboDicts[newWord];\n                        for(var z = 0;z<tmpWords.length;z++){\n                            if(tmpWords[z] == endWord){\n                                return currLevel + 1;\n                            }\n                            if(!visited[tmpWords[z]]){\n                                visited[tmpWords[z]] = true;\n                                queue.push([tmpWords[z],currLevel+1]);\n                            }\n                        }\n                    }\n                }\n            }\n            return 0;\n        };\n        解法二：DFS\n        思路同433. 最小基因变化-解法三\n        这个方法会超时\n        /**\n         * @param {string} beginWord\n         * @param {string} endWord\n         * @param {string[]} wordList\n         * @return {number}\n         */\n        var ladderLength = function(beginWord, endWord, wordList) {\n            if(!endWord || wordList.indexOf(endWord) == -1){\n                return 0;\n            }\n            var visited = {};\n            var minLevel = Number.MAX_SAFE_INTEGER;\n            var level = 1;\n            function recurse(beginWord,level){\n                if(beginWord == endWord){\n                    minLevel = Math.min(minLevel,level);\n                }\n                for(var i = 0;i<wordList.length;i++){\n                    var tmpWord = wordList[i];\n                    var diff = 0;\n                    for(var r = 0;r<tmpWord.length;r++){\n                        if(beginWord[r] != tmpWord[r]){\n                            diff++;\n                            if(diff > 1){\n                                break;\n                            }\n                        }\n                    }\n                    if(diff == 1 && !visited[tmpWord]){\n                        visited[tmpWord] = true;\n                        recurse(tmpWord,level+1);\n                        visited[tmpWord] = false;\n                    }\n                }\n            }\n            recurse(beginWord,level);\n            return (minLevel ^ Number.MAX_SAFE_INTEGER) == 0 ? 0 : minLevel;\n        };\n        解法三：双端BFS\n        时间复杂度：O(M*N)\n        空间复杂度：O(M*N)\n        核心思想是解法一\n        类似双指针的思想\n        同时从头尾两个部分搜索遍历\n        搜索终止条件为\n        一个节点被两个人搜索过\n        类似相遇问题\n        /**\n         * @param {string} beginWord\n         * @param {string} endWord\n         * @param {string[]} wordList\n         * @return {number}\n         */\n        var ladderLength = function(beginWord, endWord, wordList) {\n            if(!endWord || wordList.indexOf(endWord) == -1){\n                return 0;\n            }\n            // 各个通用状态对应所有单词\n            var comboDicts = {};\n            var len = beginWord.length;\n            for(var i = 0;i<wordList.length;i++){\n                for(var r = 0;r<len;r++){\n                    var newWord = wordList[i].substring(0,r)+'*'+wordList[i].substring(r+1,len);\n                    (!comboDicts[newWord]) && (comboDicts[newWord] = []);\n                    comboDicts[newWord].push(wordList[i]);\n                }\n            }\n            \n            function visitWord(currQueue,currVisited,othersVisited){\n                var currNode = currQueue.shift();\n                var currWord = currNode[0];\n                var currLevel = currNode[1];\n                for(var i = 0;i < len;i++){\n                    // 通用状态\n                    var newWord = currWord.substring(0,i)+'*'+currWord.substring(i+1,len);\n                    if(newWord in comboDicts){\n                        var tmpWords = comboDicts[newWord];\n                        for(var z = 0;z<tmpWords.length;z++){\n                            if(othersVisited[tmpWords[z]] != undefined){\n                                return currLevel + othersVisited[tmpWords[z]];\n                            }\n                            if(currVisited[tmpWords[z]] == undefined){\n                                currVisited[tmpWords[z]] = currLevel + 1;\n                                currQueue.push([tmpWords[z],currLevel+1]);\n                            }\n                        }\n                    }\n                }\n                return -1;\n            }\n            \n            // Queue for BFS from beginWord\n            var queueBegin = [[beginWord,1]];\n            // Queue for BFS from endWord\n            var queueEnd  = [[endWord,1]];\n            // visited begin and end\n            var visitedBegin = {};\n            visitedBegin[beginWord] = 1;\n            var visitedEnd = {};\n            visitedEnd[endWord] = 1;\n            while(queueBegin.length > 0 && queueEnd.length > 0){\n                // fromBegin\n                var ans = visitWord(queueBegin,visitedBegin,visitedEnd);\n                if(ans > -1){\n                    return ans;\n                }\n                // formEnd\n                ans = visitWord(queueEnd,visitedEnd,visitedBegin);\n                if(ans > -1){\n                    return ans;\n                }\n            }\n            return 0;\n        };\n        解法四：BFS-2\n        思路同433. 最小基因变化-解法一\n        /**\n         * @param {string} beginWord\n         * @param {string} endWord\n         * @param {string[]} wordList\n         * @return {number}\n         */\n        var ladderLength = function(beginWord, endWord, wordList) {\n            if(!endWord || wordList.indexOf(endWord) == -1){\n                return 0;\n            }\n            var wordListHash = {};\n            for(var i = 0;i<wordList.length;i++){\n                wordListHash[wordList[i]] = true;\n            }\n            var genes = 'abcdefghigklmnopqrstuvwxyz';\n            var level = 0;\n            var queue = [[beginWord,1]];\n            while(queue.length != 0){\n                var curr = queue.pop();\n                level = curr[1]\n                if(curr[0] == endWord){\n                    return level;\n                }\n                var arrCurr = curr[0];\n                for(var i = 0;i<arrCurr.length;i++){\n                    for(var r = 0;r<genes.length;r++){\n                        if(genes[r] != arrCurr[i]){\n                            var strCurr = (arrCurr.slice(0,i))+genes[r]+(arrCurr.slice(i+1));\n                            if(wordListHash[strCurr]){\n                                queue.unshift([strCurr,level+1]);\n                                wordListHash[strCurr] = false;\n                            }\n                        }\n                    }\n                }\n            }\n            return 0;\n        };\n        或者这样写也可\n        /**\n        * @param {string} beginWord\n        * @param {string} endWord\n        * @param {string[]} wordList\n        * @return {number}\n        */\n        var ladderLength = function(beginWord, endWord, wordList) {\n            let comboDicts = new Set(wordList);\n            if(!comboDicts.has(endWord)){\n                return 0;\n            }\n            let level = 0;\n            let queue = [[beginWord,1]];\n            while(queue.length != 0){\n                let currNode = queue.pop();\n                let currLeter = currNode[0];\n                level = currNode[1];\n                if(currNode[0] == endWord){\n                    return level;\n                }\n                for(let i = 0;i < currLeter.length;i++){\n                    for(r = 0;r < 26;r++){\n                        let genTmp = String.fromCharCode(97+r);\n                        if( genTmp != currLeter[i]){\n                            let str = currLeter.slice(0,i)+genTmp+currLeter.slice(i+1);\n                            if(comboDicts.has(str)){\n                                queue.unshift([str,level+1]);\n                                comboDicts.delete(str);\n                            }\n                        }\n                    }\n                }\n            }\n            return 0;\n        }; \n        解法五：双端BFS升级版\n        此解法时间复杂度比以上更低\n        解法一和解法二共同的核心思想\n        用邻接单词形式【yz、xz、xy*】作为键\n        用符合邻接单词形式的单词作为值\n        寻址共同的邻接单词形式为前提，遍历对应的值\n        找到返回前一步步数加1\n        没找到继续遍历\n        此解法的核心思想\n        借用了433. 最小基因变化-解法一 的思路\n        通过直接重新组合上一步单词\n        下一步变换为可能且符合条件的单词，在其中遍历寻找\n        找到返回...\n        没找到步数++，继续遍历\n        单端亦可以用此思路\n        双端则需要加上本题解法三的思路\n        合并两道题解的思路即为如下解法\n        /**\n         * @param {string} beginWord\n         * @param {string} endWord\n         * @param {string[]} wordList\n         * @return {number}\n         */\n        var ladderLength = function(beginWord, endWord, wordList) {\n            var comboDicts = new Set(wordList);\n            if(!comboDicts.has(endWord)){\n                return 0;\n            }\n            var len = beginWord.length;\n            \n            function gens(word){\n                var result = [];\n                var len = word.length;\n                for(var i = 0;i<len;i++){\n                    for(var j = 0;j < 26;j++){\n                        var newWord = word.substring(0,i)+String.fromCharCode(j+97)+word.substring(i+1);\n                        if(comboDicts.has(newWord) && newWord != word){\n                            result.push(newWord);\n                        }\n                    }\n                }\n                return result;\n            }\n            \n            function visitWord(currQueue,currVisited,othersVisited){\n                var currNode = currQueue.shift();\n                var tmpWords = gens(currNode[0]);\n                var currLevel = currNode[1];\n                var tmpLen = tmpWords.length;\n                for(var i = 0;i< tmpLen;i++){\n                    if(othersVisited[tmpWords[i]] != undefined){\n                        return currLevel + othersVisited[tmpWords[i]];\n                    }\n                    if(currVisited[tmpWords[i]] == undefined){\n                        currVisited[tmpWords[i]] = currLevel + 1;\n                        currQueue.push([tmpWords[i],currLevel + 1])\n                    }\n                } \n                return -1;\n            }\n            \n            // Queue for BFS from beginWord\n            var queueBegin = [[beginWord,1]];\n            // Queue for BFS from endWord\n            var queueEnd  = [[endWord,1]];\n            // visited begin and end\n            var visitedBegin = {};\n            visitedBegin[beginWord] = 1;\n            var visitedEnd = {};\n            visitedEnd[endWord] = 1;\n            while(queueBegin.length > 0 && queueEnd.length > 0){\n                // fromBegin\n                var ans = visitWord(queueBegin,visitedBegin,visitedEnd);\n                if(ans > -1){\n                    return ans;\n                }\n                // formEnd\n                ans = visitWord(queueEnd,visitedEnd,visitedBegin);\n                if(ans > -1){\n                    return ans;\n                }\n            }\n            return 0;\n        };\n        解法六：双端BFS强化版\n        其实是解法四：BFS-2 第二种写法的另类版\n        将queue换成set\n        Set 对象搜索、删除、插入时间复杂度为O(1)\n        beginSet、endSet各自向一边扩散\n        visited：节点是否已经访问过\n        BFS\n        beginSet、endSet相当于两个queue\n        扩散过程中，优先选择小的set\n        交换set\n        因上面作了交换，每次只需从beginSet开始扩散即可\n        定义一个temp Set\n        相当于向queue不断加入扩散中被选中的元素\n        因此一轮遍历完，直接将beginSet替换为temp即可\n        每次遍历到一个单词\n        遍历单词的每个字符，并尝试替换为与当前不相同的其余25个字符\n        如果从尾部扩散出的endSet有了新组合的单词\n        说明首尾相遇，直接返回当前level+1即可\n        否则，如果新组合单词未在访问备忘录visited中出现，且出现在单词库wordList中时\n        加入tempSet，用于下一轮扩散单词遍历组合操作\n        并且加入备忘录visited\n        继续下一轮queue temp set遍历\n        /**\n         * @param {string} beginWord\n         * @param {string} endWord\n         * @param {string[]} wordList\n         * @return {number}\n         */\n        let ladderLength = function(beginWord, endWord, wordList) {\n            let wordListSet = new Set(wordList);\n            if(!wordListSet.has(endWord)){\n                return 0;\n            }\n            let beginSet = new Set();\n            beginSet.add(beginWord);\n            let endSet = new Set();\n            endSet.add(endWord)\n            let visited = new Set();\n            let level = 1;\n            // BFS\n            while (beginSet.size > 0 && endSet.size > 0) {\n                if(beginSet.size > endSet.size){\n                    let tmp = beginSet;\n                    beginSet = endSet;\n                    endSet = tmp;\n                }\n                let temp = new Set();\n                for(let key of beginSet){\n                    for(let i = 0;i < key.length;i++){\n                        for(let j = 0;j < 26;j++){\n                        let tmp = key.slice(0,i)+String.fromCharCode(97+j)+key.slice(i+1);\n                        if(endSet.has(tmp)){\n                            return level + 1;\n                        }\n                        if(!visited.has(tmp) && wordListSet.has(tmp)){\n                                temp.add(tmp);\n                                visited.add(tmp);\n                        }\n                        }\n                    }\n                }\n                beginSet = temp;\n                level++;\n            }\n            return 0;\n        }\n        解法七：双端BFS终极版\n        将解法六的visited去掉，直接操作原数组\n        并对部分变量命名作了语义化处理，更容易理解\n        此解法是所有解法中最快的\n        /**\n         * @param {string} beginWord\n         * @param {string} endWord\n         * @param {string[]} wordList\n         * @return {number}\n         */\n        let ladderLength = function(beginWord, endWord, wordList) {\n            let wordListSet = new Set(wordList);\n            if(!wordListSet.has(endWord)){\n                return 0;\n            }\n            let beginSet = new Set();\n            beginSet.add(beginWord);\n            let endSet = new Set();\n            endSet.add(endWord)\n            let level = 1;\n            // BFS\n            while (beginSet.size > 0) {\n                let next_beginSet = new Set();\n                for(let key of beginSet){\n                    for(let i = 0;i < key.length;i++){\n                        for(let j = 0;j < 26;j++){\n                        let s =  String.fromCharCode(97+j);\n                        if(s != key[i]){\n                                let new_word = key.slice(0,i)+s+key.slice(i+1);\n                                if(endSet.has(new_word)){\n                                    return level + 1;\n                                }\n                                if(wordListSet.has(new_word)){\n                                    next_beginSet.add(new_word);\n                                    wordListSet.delete(new_word);\n                                }\n                        }\n                        }\n                    }\n                }\n                beginSet = next_beginSet;\n                level++;\n                if(beginSet.size > endSet.size){\n                    let tmp = beginSet;\n                    beginSet = endSet;\n                    endSet = tmp;\n                }\n            }\n            return 0;\n        }\n        解法八：双端BFS灭世版\n        解法七的交换操作去掉中间变量缓存，直接用ES6的交换语法糖\n        所幸性能直接飙升，击败百分百。\n        截屏2019-11-23下午11.47.38.png\n        /**\n         * @param {string} beginWord\n         * @param {string} endWord\n         * @param {string[]} wordList\n         * @return {number}\n         */\n        let ladderLength = function(beginWord, endWord, wordList) {\n            let wordListSet = new Set(wordList);\n            if(!wordListSet.has(endWord)){\n                return 0;\n            }\n            let beginSet = new Set();\n            beginSet.add(beginWord);\n            let endSet = new Set();\n            endSet.add(endWord)\n            let level = 1;\n            // BFS\n            while (beginSet.size > 0) {\n                let next_beginSet = new Set();\n                for(let key of beginSet){\n                    for(let i = 0;i < key.length;i++){\n                        for(let j = 0;j < 26;j++){\n                        let s =  String.fromCharCode(97+j);\n                        if(s != key[i]){\n                                let new_word = key.slice(0,i)+s+key.slice(i+1);\n                                if(endSet.has(new_word)){\n                                    return level + 1;\n                                }\n                                if(wordListSet.has(new_word)){\n                                    next_beginSet.add(new_word);\n                                    wordListSet.delete(new_word);\n                                }\n                        }\n                        }\n                    }\n                }\n                beginSet = next_beginSet;\n                level++;\n                if(beginSet.size > endSet.size){\n                    [beginSet,endSet] = [endSet,beginSet]\n                }\n            }\n            return 0;\n        }\n    `\n};\nexport default Word_Ladder;","map":{"version":3,"sources":["/Users/yabao/Documents/githubspace/Jutsai-Lab/src/apps/bao/baoApp/views/examples/JsLeetcode/js/Depth_First_Search/Word_Ladder.js"],"names":["Word_Ladder","id","name","refLink","level","tag","notes","jsSolution"],"mappings":"AAAA,MAAMA,WAAW,GAAG;AAChBC,EAAAA,EAAE,EAAE,MADY;AAEhBC,EAAAA,IAAI,EAAE,aAFU;AAGhBC,EAAAA,OAAO,EAAE,CACL,0EADK,EAEL,0DAFK,EAGL,0FAHK,CAHO;AAQhBC,EAAAA,KAAK,EAAE,QARS;AAShBC,EAAAA,GAAG,EAAE,EATW;AAUhBC,EAAAA,KAAK,EAAG,EAVQ;AAWhBC,EAAAA,UAAU,EAAG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAXG,CAApB;AAomBA,eAAeP,WAAf","sourcesContent":["const Word_Ladder = {\n    id: '0040',\n    name: 'Word_Ladder',\n    refLink: [\n        'https://www.jiuzhang.com/solution/word-ladder/#tag-other-lang-javascript',\n        'https://www.lintcode.com/problem/word-ladder/description',\n        'https://leetcode-cn.com/problems/word-ladder/solution/127-dan-ci-jie-long-by-alexer-660/'\n    ],\n    level: 'Medium',\n    tag: [],\n    notes: ``,\n    jsSolution: `\n        // Given two words (start and end), and a dictionary, find the shortest transformation sequence from start to end, output the length of the sequence.\n        // Transformation rule such that:\n        \n        // Only one letter can be changed at a time\n        // Each intermediate word must exist in the dictionary. (Start and end words do not need to appear in the dictionary )\n        // 在线评测地址: https://www.lintcode.com/problem/word-ladder/\n\n        var ladderLength = function(beginWord, endWord, wordList) {\n            let queue = [beginWord];\n            let visitedMap  = {};\n            let count = 0;\n            while(queue.length != 0){\n                count ++;\n                const length = queue.length;\n                for(let i = 0; i < length; i ++){\n                    let node = queue.pop();\n                    if(node == endWord){\n                        return count;\n                    }\n                    const nextList = findNext(node, wordList, visitedMap);\n                    for(let j = 0; j < nextList.length; j ++){\n                        if(nextList[j] == endWord){\n                            return count + 1;\n                        }\n                        visitedMap[nextList[j]] = true;\n                        queue.unshift(nextList[j]);\n                    }\n                }\n            }\n            return 0;\n        };\n        function findNext(word, arr, visitedMap){\n            let result = [];\n            for(let i = 0;i < arr.length; i ++){\n                let ele = arr[i];\n                if(visitedMap[ele]){\n                    continue;\n                }\n                let diff = 0;\n                for(let j = 0;j < word.length; j ++){\n                    if(word.charAt(j) != ele.charAt(j)){\n                        diff ++;\n                    }\n                }\n                if(diff == 1){\n                    result.push(ele);\n                }\n            }\n            return result;\n        }\n\n        解法一：BFS\n        时间复杂度：O(M * N) ,M为单词长度，,N为单词列表长度\n        空间复杂度：O(M * N) ,M长度的单词化为邻接单词形式时需要M，N同上\n        用广度优先搜索搜索从beginWord到endWord的最短路径问题\n        思路分析\n        一个最短转换序列是 \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\",\n\n        从起点\"hit\"变换到终点\"cog\"\n        每次变换\n        只能变动其中一个单词\n        且必须在字典中\n        因此每次变换，其实就是走了一步\n        每次变换前后的单词差异只有其中一个字符\n        设唯一不同的字符为*\n        \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\"\n\n        hit ----> h*t <-----hot\n        dot ----> *ot <-----hot\n        dot ----> do* <-----dog\n        dog ----> *og <-----cog\n        我们把相差唯一一个字符的两个单词称为邻接单词\n        因此 单词'xyz'的所有邻接单词为\n        '*yz'\n        'x*z'\n        'xy*'\n        因为单词的下一个变换单词即是邻接单词\n        例如我们要从'hit'变换到'hot'\n        hit的邻接单词形式有\n        *it\n        h*t\n        hi*\n        hot的邻接单词形式有\n        *ot\n        h*t\n        ho*\n        我们寻找他们相同的邻接单词形式\n        为h*t\n        反过来\n        符合h*t形式的单词有\n        hit\n        hot\n        因此在代码中，此处便是寻找下一邻接单词的关键逻辑\n        代码逻辑\n        求出wordList中的所有单词的所有邻接单词形式\n        将具有相同邻接单词形式的单词放在一个集合里\n        形如 hash[邻接单词形式] = [单词1,单词2,...,单词n]\n        当我们在寻找下一个邻接单词是谁时，我们通过求当前单词的邻接单词的形式，去枚举上一步的所有邻接单词形式的集合\n        存在则在邻接单词形式对应的单词集合里，遍历寻找符合的目标单词\n        找到，则返回\n        没找到，当前寻址步数++，继续寻址\n        我们将从起点 beginWord --> endWord 的寻址路线，抽象为队列\n        初始值是起点，入队\n        出队，通过邻接单词形式变换寻址，逻辑如上\n        核心逻辑在第一步\n        解题技巧\n        每个邻接单词形式对应的单词既有可能相同，会出现循环寻址即环的形式\n        例如 h*t -> hot、*ot -> hot\n        因此维护一个访问记录数组，访问比较过的单词，下次不再访问\n        /**\n         * @param {string} beginWord\n         * @param {string} endWord\n         * @param {string[]} wordList\n         * @return {number}\n         */\n        var ladderLength = function(beginWord, endWord, wordList) {\n            if(!endWord || wordList.indexOf(endWord) == -1){\n                return 0;\n            }\n            // 各个通用状态对应所有单词\n            var comboDicts = {};\n            var len = beginWord.length;\n            for(var i = 0;i<wordList.length;i++){\n                for(var r = 0;r<len;r++){\n                    var newWord = wordList[i].substring(0,r)+'*'+wordList[i].substring(r+1,len);\n                    (!comboDicts[newWord]) && (comboDicts[newWord] = []);\n                    comboDicts[newWord].push(wordList[i]);\n                }\n            }\n            // Queue for BFS\n            var queue = [[beginWord,1]];\n            // visited\n            var visited = {beginWord:true};\n            while(queue.length > 0){\n                var currNode = queue.shift();\n                var currWord = currNode[0];\n                var currLevel = currNode[1];\n                for(var i = 0;i < len;i++){\n                    // 通用状态\n                    var newWord = currWord.substring(0,i)+'*'+currWord.substring(i+1,len);\n                    if(newWord in comboDicts){\n                        var tmpWords = comboDicts[newWord];\n                        for(var z = 0;z<tmpWords.length;z++){\n                            if(tmpWords[z] == endWord){\n                                return currLevel + 1;\n                            }\n                            if(!visited[tmpWords[z]]){\n                                visited[tmpWords[z]] = true;\n                                queue.push([tmpWords[z],currLevel+1]);\n                            }\n                        }\n                    }\n                }\n            }\n            return 0;\n        };\n        解法二：DFS\n        思路同433. 最小基因变化-解法三\n        这个方法会超时\n        /**\n         * @param {string} beginWord\n         * @param {string} endWord\n         * @param {string[]} wordList\n         * @return {number}\n         */\n        var ladderLength = function(beginWord, endWord, wordList) {\n            if(!endWord || wordList.indexOf(endWord) == -1){\n                return 0;\n            }\n            var visited = {};\n            var minLevel = Number.MAX_SAFE_INTEGER;\n            var level = 1;\n            function recurse(beginWord,level){\n                if(beginWord == endWord){\n                    minLevel = Math.min(minLevel,level);\n                }\n                for(var i = 0;i<wordList.length;i++){\n                    var tmpWord = wordList[i];\n                    var diff = 0;\n                    for(var r = 0;r<tmpWord.length;r++){\n                        if(beginWord[r] != tmpWord[r]){\n                            diff++;\n                            if(diff > 1){\n                                break;\n                            }\n                        }\n                    }\n                    if(diff == 1 && !visited[tmpWord]){\n                        visited[tmpWord] = true;\n                        recurse(tmpWord,level+1);\n                        visited[tmpWord] = false;\n                    }\n                }\n            }\n            recurse(beginWord,level);\n            return (minLevel ^ Number.MAX_SAFE_INTEGER) == 0 ? 0 : minLevel;\n        };\n        解法三：双端BFS\n        时间复杂度：O(M*N)\n        空间复杂度：O(M*N)\n        核心思想是解法一\n        类似双指针的思想\n        同时从头尾两个部分搜索遍历\n        搜索终止条件为\n        一个节点被两个人搜索过\n        类似相遇问题\n        /**\n         * @param {string} beginWord\n         * @param {string} endWord\n         * @param {string[]} wordList\n         * @return {number}\n         */\n        var ladderLength = function(beginWord, endWord, wordList) {\n            if(!endWord || wordList.indexOf(endWord) == -1){\n                return 0;\n            }\n            // 各个通用状态对应所有单词\n            var comboDicts = {};\n            var len = beginWord.length;\n            for(var i = 0;i<wordList.length;i++){\n                for(var r = 0;r<len;r++){\n                    var newWord = wordList[i].substring(0,r)+'*'+wordList[i].substring(r+1,len);\n                    (!comboDicts[newWord]) && (comboDicts[newWord] = []);\n                    comboDicts[newWord].push(wordList[i]);\n                }\n            }\n            \n            function visitWord(currQueue,currVisited,othersVisited){\n                var currNode = currQueue.shift();\n                var currWord = currNode[0];\n                var currLevel = currNode[1];\n                for(var i = 0;i < len;i++){\n                    // 通用状态\n                    var newWord = currWord.substring(0,i)+'*'+currWord.substring(i+1,len);\n                    if(newWord in comboDicts){\n                        var tmpWords = comboDicts[newWord];\n                        for(var z = 0;z<tmpWords.length;z++){\n                            if(othersVisited[tmpWords[z]] != undefined){\n                                return currLevel + othersVisited[tmpWords[z]];\n                            }\n                            if(currVisited[tmpWords[z]] == undefined){\n                                currVisited[tmpWords[z]] = currLevel + 1;\n                                currQueue.push([tmpWords[z],currLevel+1]);\n                            }\n                        }\n                    }\n                }\n                return -1;\n            }\n            \n            // Queue for BFS from beginWord\n            var queueBegin = [[beginWord,1]];\n            // Queue for BFS from endWord\n            var queueEnd  = [[endWord,1]];\n            // visited begin and end\n            var visitedBegin = {};\n            visitedBegin[beginWord] = 1;\n            var visitedEnd = {};\n            visitedEnd[endWord] = 1;\n            while(queueBegin.length > 0 && queueEnd.length > 0){\n                // fromBegin\n                var ans = visitWord(queueBegin,visitedBegin,visitedEnd);\n                if(ans > -1){\n                    return ans;\n                }\n                // formEnd\n                ans = visitWord(queueEnd,visitedEnd,visitedBegin);\n                if(ans > -1){\n                    return ans;\n                }\n            }\n            return 0;\n        };\n        解法四：BFS-2\n        思路同433. 最小基因变化-解法一\n        /**\n         * @param {string} beginWord\n         * @param {string} endWord\n         * @param {string[]} wordList\n         * @return {number}\n         */\n        var ladderLength = function(beginWord, endWord, wordList) {\n            if(!endWord || wordList.indexOf(endWord) == -1){\n                return 0;\n            }\n            var wordListHash = {};\n            for(var i = 0;i<wordList.length;i++){\n                wordListHash[wordList[i]] = true;\n            }\n            var genes = 'abcdefghigklmnopqrstuvwxyz';\n            var level = 0;\n            var queue = [[beginWord,1]];\n            while(queue.length != 0){\n                var curr = queue.pop();\n                level = curr[1]\n                if(curr[0] == endWord){\n                    return level;\n                }\n                var arrCurr = curr[0];\n                for(var i = 0;i<arrCurr.length;i++){\n                    for(var r = 0;r<genes.length;r++){\n                        if(genes[r] != arrCurr[i]){\n                            var strCurr = (arrCurr.slice(0,i))+genes[r]+(arrCurr.slice(i+1));\n                            if(wordListHash[strCurr]){\n                                queue.unshift([strCurr,level+1]);\n                                wordListHash[strCurr] = false;\n                            }\n                        }\n                    }\n                }\n            }\n            return 0;\n        };\n        或者这样写也可\n        /**\n        * @param {string} beginWord\n        * @param {string} endWord\n        * @param {string[]} wordList\n        * @return {number}\n        */\n        var ladderLength = function(beginWord, endWord, wordList) {\n            let comboDicts = new Set(wordList);\n            if(!comboDicts.has(endWord)){\n                return 0;\n            }\n            let level = 0;\n            let queue = [[beginWord,1]];\n            while(queue.length != 0){\n                let currNode = queue.pop();\n                let currLeter = currNode[0];\n                level = currNode[1];\n                if(currNode[0] == endWord){\n                    return level;\n                }\n                for(let i = 0;i < currLeter.length;i++){\n                    for(r = 0;r < 26;r++){\n                        let genTmp = String.fromCharCode(97+r);\n                        if( genTmp != currLeter[i]){\n                            let str = currLeter.slice(0,i)+genTmp+currLeter.slice(i+1);\n                            if(comboDicts.has(str)){\n                                queue.unshift([str,level+1]);\n                                comboDicts.delete(str);\n                            }\n                        }\n                    }\n                }\n            }\n            return 0;\n        }; \n        解法五：双端BFS升级版\n        此解法时间复杂度比以上更低\n        解法一和解法二共同的核心思想\n        用邻接单词形式【yz、xz、xy*】作为键\n        用符合邻接单词形式的单词作为值\n        寻址共同的邻接单词形式为前提，遍历对应的值\n        找到返回前一步步数加1\n        没找到继续遍历\n        此解法的核心思想\n        借用了433. 最小基因变化-解法一 的思路\n        通过直接重新组合上一步单词\n        下一步变换为可能且符合条件的单词，在其中遍历寻找\n        找到返回...\n        没找到步数++，继续遍历\n        单端亦可以用此思路\n        双端则需要加上本题解法三的思路\n        合并两道题解的思路即为如下解法\n        /**\n         * @param {string} beginWord\n         * @param {string} endWord\n         * @param {string[]} wordList\n         * @return {number}\n         */\n        var ladderLength = function(beginWord, endWord, wordList) {\n            var comboDicts = new Set(wordList);\n            if(!comboDicts.has(endWord)){\n                return 0;\n            }\n            var len = beginWord.length;\n            \n            function gens(word){\n                var result = [];\n                var len = word.length;\n                for(var i = 0;i<len;i++){\n                    for(var j = 0;j < 26;j++){\n                        var newWord = word.substring(0,i)+String.fromCharCode(j+97)+word.substring(i+1);\n                        if(comboDicts.has(newWord) && newWord != word){\n                            result.push(newWord);\n                        }\n                    }\n                }\n                return result;\n            }\n            \n            function visitWord(currQueue,currVisited,othersVisited){\n                var currNode = currQueue.shift();\n                var tmpWords = gens(currNode[0]);\n                var currLevel = currNode[1];\n                var tmpLen = tmpWords.length;\n                for(var i = 0;i< tmpLen;i++){\n                    if(othersVisited[tmpWords[i]] != undefined){\n                        return currLevel + othersVisited[tmpWords[i]];\n                    }\n                    if(currVisited[tmpWords[i]] == undefined){\n                        currVisited[tmpWords[i]] = currLevel + 1;\n                        currQueue.push([tmpWords[i],currLevel + 1])\n                    }\n                } \n                return -1;\n            }\n            \n            // Queue for BFS from beginWord\n            var queueBegin = [[beginWord,1]];\n            // Queue for BFS from endWord\n            var queueEnd  = [[endWord,1]];\n            // visited begin and end\n            var visitedBegin = {};\n            visitedBegin[beginWord] = 1;\n            var visitedEnd = {};\n            visitedEnd[endWord] = 1;\n            while(queueBegin.length > 0 && queueEnd.length > 0){\n                // fromBegin\n                var ans = visitWord(queueBegin,visitedBegin,visitedEnd);\n                if(ans > -1){\n                    return ans;\n                }\n                // formEnd\n                ans = visitWord(queueEnd,visitedEnd,visitedBegin);\n                if(ans > -1){\n                    return ans;\n                }\n            }\n            return 0;\n        };\n        解法六：双端BFS强化版\n        其实是解法四：BFS-2 第二种写法的另类版\n        将queue换成set\n        Set 对象搜索、删除、插入时间复杂度为O(1)\n        beginSet、endSet各自向一边扩散\n        visited：节点是否已经访问过\n        BFS\n        beginSet、endSet相当于两个queue\n        扩散过程中，优先选择小的set\n        交换set\n        因上面作了交换，每次只需从beginSet开始扩散即可\n        定义一个temp Set\n        相当于向queue不断加入扩散中被选中的元素\n        因此一轮遍历完，直接将beginSet替换为temp即可\n        每次遍历到一个单词\n        遍历单词的每个字符，并尝试替换为与当前不相同的其余25个字符\n        如果从尾部扩散出的endSet有了新组合的单词\n        说明首尾相遇，直接返回当前level+1即可\n        否则，如果新组合单词未在访问备忘录visited中出现，且出现在单词库wordList中时\n        加入tempSet，用于下一轮扩散单词遍历组合操作\n        并且加入备忘录visited\n        继续下一轮queue temp set遍历\n        /**\n         * @param {string} beginWord\n         * @param {string} endWord\n         * @param {string[]} wordList\n         * @return {number}\n         */\n        let ladderLength = function(beginWord, endWord, wordList) {\n            let wordListSet = new Set(wordList);\n            if(!wordListSet.has(endWord)){\n                return 0;\n            }\n            let beginSet = new Set();\n            beginSet.add(beginWord);\n            let endSet = new Set();\n            endSet.add(endWord)\n            let visited = new Set();\n            let level = 1;\n            // BFS\n            while (beginSet.size > 0 && endSet.size > 0) {\n                if(beginSet.size > endSet.size){\n                    let tmp = beginSet;\n                    beginSet = endSet;\n                    endSet = tmp;\n                }\n                let temp = new Set();\n                for(let key of beginSet){\n                    for(let i = 0;i < key.length;i++){\n                        for(let j = 0;j < 26;j++){\n                        let tmp = key.slice(0,i)+String.fromCharCode(97+j)+key.slice(i+1);\n                        if(endSet.has(tmp)){\n                            return level + 1;\n                        }\n                        if(!visited.has(tmp) && wordListSet.has(tmp)){\n                                temp.add(tmp);\n                                visited.add(tmp);\n                        }\n                        }\n                    }\n                }\n                beginSet = temp;\n                level++;\n            }\n            return 0;\n        }\n        解法七：双端BFS终极版\n        将解法六的visited去掉，直接操作原数组\n        并对部分变量命名作了语义化处理，更容易理解\n        此解法是所有解法中最快的\n        /**\n         * @param {string} beginWord\n         * @param {string} endWord\n         * @param {string[]} wordList\n         * @return {number}\n         */\n        let ladderLength = function(beginWord, endWord, wordList) {\n            let wordListSet = new Set(wordList);\n            if(!wordListSet.has(endWord)){\n                return 0;\n            }\n            let beginSet = new Set();\n            beginSet.add(beginWord);\n            let endSet = new Set();\n            endSet.add(endWord)\n            let level = 1;\n            // BFS\n            while (beginSet.size > 0) {\n                let next_beginSet = new Set();\n                for(let key of beginSet){\n                    for(let i = 0;i < key.length;i++){\n                        for(let j = 0;j < 26;j++){\n                        let s =  String.fromCharCode(97+j);\n                        if(s != key[i]){\n                                let new_word = key.slice(0,i)+s+key.slice(i+1);\n                                if(endSet.has(new_word)){\n                                    return level + 1;\n                                }\n                                if(wordListSet.has(new_word)){\n                                    next_beginSet.add(new_word);\n                                    wordListSet.delete(new_word);\n                                }\n                        }\n                        }\n                    }\n                }\n                beginSet = next_beginSet;\n                level++;\n                if(beginSet.size > endSet.size){\n                    let tmp = beginSet;\n                    beginSet = endSet;\n                    endSet = tmp;\n                }\n            }\n            return 0;\n        }\n        解法八：双端BFS灭世版\n        解法七的交换操作去掉中间变量缓存，直接用ES6的交换语法糖\n        所幸性能直接飙升，击败百分百。\n        截屏2019-11-23下午11.47.38.png\n        /**\n         * @param {string} beginWord\n         * @param {string} endWord\n         * @param {string[]} wordList\n         * @return {number}\n         */\n        let ladderLength = function(beginWord, endWord, wordList) {\n            let wordListSet = new Set(wordList);\n            if(!wordListSet.has(endWord)){\n                return 0;\n            }\n            let beginSet = new Set();\n            beginSet.add(beginWord);\n            let endSet = new Set();\n            endSet.add(endWord)\n            let level = 1;\n            // BFS\n            while (beginSet.size > 0) {\n                let next_beginSet = new Set();\n                for(let key of beginSet){\n                    for(let i = 0;i < key.length;i++){\n                        for(let j = 0;j < 26;j++){\n                        let s =  String.fromCharCode(97+j);\n                        if(s != key[i]){\n                                let new_word = key.slice(0,i)+s+key.slice(i+1);\n                                if(endSet.has(new_word)){\n                                    return level + 1;\n                                }\n                                if(wordListSet.has(new_word)){\n                                    next_beginSet.add(new_word);\n                                    wordListSet.delete(new_word);\n                                }\n                        }\n                        }\n                    }\n                }\n                beginSet = next_beginSet;\n                level++;\n                if(beginSet.size > endSet.size){\n                    [beginSet,endSet] = [endSet,beginSet]\n                }\n            }\n            return 0;\n        }\n    `\n}\n\nexport default Word_Ladder\n"]},"metadata":{},"sourceType":"module"}