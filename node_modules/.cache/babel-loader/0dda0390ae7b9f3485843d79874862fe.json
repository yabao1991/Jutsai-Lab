{"ast":null,"code":"var Word_Ladder_II={id:'0041',name:'Word_Ladder_II',refLink:['https://www.lintcode.com/problem/word-ladder-ii/description','https://leetcode-cn.com/problems/word-ladder-ii/solution/javascript-jian-dan-yi-dong-bfs-dfs-by-jsyt/'],level:'Hard',tag:[],notes:\"\",jsSolution:\"\\n        // Given two words (start and end), and a dictionary, find all shortest transformation sequence(s) from start to end, output sequence in dictionary order.\\n        // Transformation rule such that:\\n        \\n        // Only one letter can be changed at a time\\n        // Each intermediate word must exist in the dictionary\\n        // \\u5728\\u7EBF\\u8BC4\\u6D4B\\u5730\\u5740: https://www.lintcode.com/problem/word-ladder-ii/\\n\\n        \\u5148\\u7528 BFS \\u6C42\\u51FA\\u6700\\u77ED\\u8DDD\\u79BB\\n        \\u518D\\u7528 DFS \\u6C42\\u51FA\\u6700\\u77ED\\u8DDD\\u79BB\\u8DEF\\u5F84\\n\\n        \\u4EE3\\u7801\\n        /**\\n         * @param {string} beginWord\\n         * @param {string} endWord\\n         * @param {string[]} wordList\\n         * @return {string[][]}\\n         */\\n        var findLadders = function(beginWord, endWord, wordList) {\\n            let wordSet = new Set(wordList);\\n            if (!wordSet.has(endWord)) return [];\\n            wordSet.delete(beginWord);\\n            let beginSet = new Set([beginWord]);\\n            let map = new Map();\\n            let distance = 0;\\n            let minDistance = 0;\\n            while(beginSet.size) {\\n                if (beginSet.has(endWord)) break;\\n                let trySet = new Set();\\n                for (let word of beginSet) {\\n                    let mapSet = new Set();\\n                    for (let i = 0; i < word.length; i++) {\\n                        for (let j = 0; j < 26; j++) {\\n                            let tryWord = word.slice(0, i) + String.fromCharCode(97 + j) + word.slice(i + 1);\\n                            if (!minDistance && tryWord === endWord) minDistance = distance + 1;\\n                            if (wordSet.has(tryWord)) {\\n                                trySet.add(tryWord);\\n                                mapSet.add(tryWord);\\n                            }\\n                        }\\n                    }\\n                    map.set(word, mapSet);\\n                }\\n                distance++;\\n                for (let w of trySet) {\\n                    wordSet.delete(w);\\n                }\\n                beginSet = trySet;\\n            }\\n            let ans = [];\\n            let path = [beginWord];\\n            dfs(beginWord, endWord, ans, path, map, minDistance, 0);\\n            return ans;\\n        };\\n\\n        function dfs (beginWord, endWord, ans, path, map, minDistance, distance) {\\n            if (distance > minDistance) return ;\\n            if (beginWord === endWord) {\\n                ans.push(path.slice());\\n            }\\n            let words = map.get(beginWord)\\n            if (words) {\\n                for (let word of words) {\\n                    path.push(word)\\n                    dfs(word, endWord, ans, path, map, minDistance, distance + 1);\\n                    path.pop();\\n                }\\n            }\\n        }\\n    \"};export default Word_Ladder_II;","map":{"version":3,"sources":["/Users/yabao/Documents/githubspace/Jutsai-Lab/src/apps/bao/baoApp/views/examples/JsLeetcode/js/Depth_First_Search/Word_Ladder_II.js"],"names":["Word_Ladder_II","id","name","refLink","level","tag","notes","jsSolution"],"mappings":"AAAA,GAAMA,CAAAA,cAAc,CAAG,CACnBC,EAAE,CAAE,MADe,CAEnBC,IAAI,CAAE,gBAFa,CAGnBC,OAAO,CAAE,CACL,6DADK,CAEL,uGAFK,CAHU,CAOnBC,KAAK,CAAE,MAPY,CAQnBC,GAAG,CAAE,EARc,CASnBC,KAAK,GATc,CAUnBC,UAAU,m0FAVS,CAAvB,CAkFA,cAAeP,CAAAA,cAAf","sourcesContent":["const Word_Ladder_II = {\n    id: '0041',\n    name: 'Word_Ladder_II',\n    refLink: [\n        'https://www.lintcode.com/problem/word-ladder-ii/description',\n        'https://leetcode-cn.com/problems/word-ladder-ii/solution/javascript-jian-dan-yi-dong-bfs-dfs-by-jsyt/'\n    ],\n    level: 'Hard',\n    tag: [],\n    notes: ``,\n    jsSolution: `\n        // Given two words (start and end), and a dictionary, find all shortest transformation sequence(s) from start to end, output sequence in dictionary order.\n        // Transformation rule such that:\n        \n        // Only one letter can be changed at a time\n        // Each intermediate word must exist in the dictionary\n        // 在线评测地址: https://www.lintcode.com/problem/word-ladder-ii/\n\n        先用 BFS 求出最短距离\n        再用 DFS 求出最短距离路径\n\n        代码\n        /**\n         * @param {string} beginWord\n         * @param {string} endWord\n         * @param {string[]} wordList\n         * @return {string[][]}\n         */\n        var findLadders = function(beginWord, endWord, wordList) {\n            let wordSet = new Set(wordList);\n            if (!wordSet.has(endWord)) return [];\n            wordSet.delete(beginWord);\n            let beginSet = new Set([beginWord]);\n            let map = new Map();\n            let distance = 0;\n            let minDistance = 0;\n            while(beginSet.size) {\n                if (beginSet.has(endWord)) break;\n                let trySet = new Set();\n                for (let word of beginSet) {\n                    let mapSet = new Set();\n                    for (let i = 0; i < word.length; i++) {\n                        for (let j = 0; j < 26; j++) {\n                            let tryWord = word.slice(0, i) + String.fromCharCode(97 + j) + word.slice(i + 1);\n                            if (!minDistance && tryWord === endWord) minDistance = distance + 1;\n                            if (wordSet.has(tryWord)) {\n                                trySet.add(tryWord);\n                                mapSet.add(tryWord);\n                            }\n                        }\n                    }\n                    map.set(word, mapSet);\n                }\n                distance++;\n                for (let w of trySet) {\n                    wordSet.delete(w);\n                }\n                beginSet = trySet;\n            }\n            let ans = [];\n            let path = [beginWord];\n            dfs(beginWord, endWord, ans, path, map, minDistance, 0);\n            return ans;\n        };\n\n        function dfs (beginWord, endWord, ans, path, map, minDistance, distance) {\n            if (distance > minDistance) return ;\n            if (beginWord === endWord) {\n                ans.push(path.slice());\n            }\n            let words = map.get(beginWord)\n            if (words) {\n                for (let word of words) {\n                    path.push(word)\n                    dfs(word, endWord, ans, path, map, minDistance, distance + 1);\n                    path.pop();\n                }\n            }\n        }\n    `\n}\n\nexport default Word_Ladder_II\n"]},"metadata":{},"sourceType":"module"}