{"ast":null,"code":"var Knight_Shortest_Path={id:'0034',name:'Knight_Shortest_Path',refLink:['https://www.lintcode.com/problem/knight-shortest-path/description','https://www.jiuzhang.com/solution/knight-shortest-path/'],level:'Medium',tag:[''],notes:\"\",jsSolution:\"\\n        // Given a knight in a chessboard (a binary matrix with 0 as empty and 1 as barrier) with a source position, find the shortest path to a destination position, return the length of the route.\\n        // Return -1 if destination cannot be reached.\\n        \\n        // \\u5728\\u7EBF\\u8BC4\\u6D4B\\u5730\\u5740: https://www.lintcode.com/problem/knight-shortest-path/\\n\\n\\n        public class Solution {\\n            int n, m; // size of the chessboard\\n            int[] deltaX = {1, 1, 2, 2, -1, -1, -2, -2};\\n            int[] deltaY = {2, -2, 1, -1, 2, -2, 1, -1};\\n            /**\\n             * @param grid a chessboard included 0 (false) and 1 (true)\\n             * @param source, destination a point\\n             * @return the shortest path \\n             */\\n            public int shortestPath(boolean[][] grid, Point source, Point destination) {\\n                if (grid == null || grid.length == 0 || grid[0].length == 0) {\\n                    return -1;\\n                }\\n                \\n                n = grid.length;\\n                m = grid[0].length;\\n                \\n                Queue<Point> queue = new LinkedList<>();\\n                queue.offer(source);\\n                \\n                int steps = 0;\\n                while (!queue.isEmpty()) {\\n                    int size = queue.size();\\n                    for (int i = 0; i < size; i++) {\\n                        Point point = queue.poll();\\n                        if (point.x == destination.x && point.y == destination.y) {\\n                            return steps;\\n                        }\\n                        \\n                        for (int direction = 0; direction < 8; direction++) {\\n                            Point nextPoint = new Point(\\n                                point.x + deltaX[direction],\\n                                point.y + deltaY[direction]\\n                            );\\n                            \\n                            if (!inBound(nextPoint, grid)) {\\n                                continue;\\n                            }\\n                            \\n                            queue.offer(nextPoint);\\n                            // mark the point not accessible\\n                            grid[nextPoint.x][nextPoint.y] = true;\\n                        }\\n                    }\\n                    steps++;\\n                }\\n                \\n                return -1;\\n            }\\n            \\n            private boolean inBound(Point point, boolean[][] grid) {\\n                if (point.x < 0 || point.x >= n) {\\n                    return false;\\n                }\\n                if (point.y < 0 || point.y >= m) {\\n                    return false;\\n                }\\n                return (grid[point.x][point.y] == false);\\n            }\\n        }\\n        \\n        //version \\u7845\\u8C37\\u7B97\\u6CD5\\u73ED\\n        public class Solution {\\n            /**\\n             * @param grid: a chessboard included 0 (false) and 1 (true)\\n             * @param source: a point\\n             * @param destination: a point\\n             * @return: the shortest path\\n             */\\n            public int shortestPath(boolean[][] grid, Point source, Point destination) {\\n                // write your code here\\n                if (grid == null || grid.length == 0 || grid[0].length == 0) {\\n                    return -1;\\n                }\\n        \\n                int[] dx = {1, 1, -1, -1, 2, 2, -2, -2};\\n                int[] dy = {2, -2, 2, -2, 1, -1, 1, -1};\\n        \\n                Queue<Point> q = new LinkedList<>();\\n                boolean[][] v = new boolean[grid.length][grid[0].length];  //Set<Point> v will TLE\\n        \\n                q.offer(source);\\n                v[source.x][source.y] = true;\\n        \\n                if (source.x == destination.x && source.y == destination.y) {\\n                    return 0;\\n                }\\n        \\n                int dist = 0;\\n        \\n                while (!q.isEmpty()) {\\n                    dist++;\\n                    int size = q.size();\\n                    for (int i = 0; i < size; i++) {\\n                        Point cur = q.poll();\\n                        for (int k = 0; k < 8; k++) {\\n                            int nx = cur.x + dx[k];\\n                            int ny = cur.y + dy[k];\\n                            if (0 <= nx && nx < grid.length && 0 <= ny && ny < grid[0].length && !grid[nx][ny] && !v[nx][ny]) {\\n                                if (nx == destination.x && ny == destination.y) {\\n                                    return dist;\\n                                }\\n                                q.offer(new Point(nx, ny));\\n                                v[nx][ny] = true;\\n                            }\\n                        }\\n                    }\\n        \\n                }\\n                return -1;\\n            }\\n        }\\n    \"};export default Knight_Shortest_Path;","map":{"version":3,"sources":["/Users/yabao/Documents/githubspace/Jutsai-Lab/src/apps/bao/baoApp/views/examples/JsLeetcode/js/Breadth_First_Search/Knight_Shortest_Path.js"],"names":["Knight_Shortest_Path","id","name","refLink","level","tag","notes","jsSolution"],"mappings":"AAAA,GAAMA,CAAAA,oBAAoB,CAAG,CACzBC,EAAE,CAAE,MADqB,CAEzBC,IAAI,CAAE,sBAFmB,CAGzBC,OAAO,CAAE,CACL,mEADK,CAEL,yDAFK,CAHgB,CAOzBC,KAAK,CAAE,QAPkB,CAQzBC,GAAG,CAAE,CACD,EADC,CARoB,CAWzBC,KAAK,GAXoB,CAYzBC,UAAU,y1JAZe,CAA7B,CAsIA,cAAeP,CAAAA,oBAAf","sourcesContent":["const Knight_Shortest_Path = {\n    id: '0034',\n    name: 'Knight_Shortest_Path',\n    refLink: [\n        'https://www.lintcode.com/problem/knight-shortest-path/description',\n        'https://www.jiuzhang.com/solution/knight-shortest-path/'\n    ],\n    level: 'Medium',\n    tag: [\n        ''\n    ],\n    notes: ``,\n    jsSolution: `\n        // Given a knight in a chessboard (a binary matrix with 0 as empty and 1 as barrier) with a source position, find the shortest path to a destination position, return the length of the route.\n        // Return -1 if destination cannot be reached.\n        \n        // 在线评测地址: https://www.lintcode.com/problem/knight-shortest-path/\n\n\n        public class Solution {\n            int n, m; // size of the chessboard\n            int[] deltaX = {1, 1, 2, 2, -1, -1, -2, -2};\n            int[] deltaY = {2, -2, 1, -1, 2, -2, 1, -1};\n            /**\n             * @param grid a chessboard included 0 (false) and 1 (true)\n             * @param source, destination a point\n             * @return the shortest path \n             */\n            public int shortestPath(boolean[][] grid, Point source, Point destination) {\n                if (grid == null || grid.length == 0 || grid[0].length == 0) {\n                    return -1;\n                }\n                \n                n = grid.length;\n                m = grid[0].length;\n                \n                Queue<Point> queue = new LinkedList<>();\n                queue.offer(source);\n                \n                int steps = 0;\n                while (!queue.isEmpty()) {\n                    int size = queue.size();\n                    for (int i = 0; i < size; i++) {\n                        Point point = queue.poll();\n                        if (point.x == destination.x && point.y == destination.y) {\n                            return steps;\n                        }\n                        \n                        for (int direction = 0; direction < 8; direction++) {\n                            Point nextPoint = new Point(\n                                point.x + deltaX[direction],\n                                point.y + deltaY[direction]\n                            );\n                            \n                            if (!inBound(nextPoint, grid)) {\n                                continue;\n                            }\n                            \n                            queue.offer(nextPoint);\n                            // mark the point not accessible\n                            grid[nextPoint.x][nextPoint.y] = true;\n                        }\n                    }\n                    steps++;\n                }\n                \n                return -1;\n            }\n            \n            private boolean inBound(Point point, boolean[][] grid) {\n                if (point.x < 0 || point.x >= n) {\n                    return false;\n                }\n                if (point.y < 0 || point.y >= m) {\n                    return false;\n                }\n                return (grid[point.x][point.y] == false);\n            }\n        }\n        \n        //version 硅谷算法班\n        public class Solution {\n            /**\n             * @param grid: a chessboard included 0 (false) and 1 (true)\n             * @param source: a point\n             * @param destination: a point\n             * @return: the shortest path\n             */\n            public int shortestPath(boolean[][] grid, Point source, Point destination) {\n                // write your code here\n                if (grid == null || grid.length == 0 || grid[0].length == 0) {\n                    return -1;\n                }\n        \n                int[] dx = {1, 1, -1, -1, 2, 2, -2, -2};\n                int[] dy = {2, -2, 2, -2, 1, -1, 1, -1};\n        \n                Queue<Point> q = new LinkedList<>();\n                boolean[][] v = new boolean[grid.length][grid[0].length];  //Set<Point> v will TLE\n        \n                q.offer(source);\n                v[source.x][source.y] = true;\n        \n                if (source.x == destination.x && source.y == destination.y) {\n                    return 0;\n                }\n        \n                int dist = 0;\n        \n                while (!q.isEmpty()) {\n                    dist++;\n                    int size = q.size();\n                    for (int i = 0; i < size; i++) {\n                        Point cur = q.poll();\n                        for (int k = 0; k < 8; k++) {\n                            int nx = cur.x + dx[k];\n                            int ny = cur.y + dy[k];\n                            if (0 <= nx && nx < grid.length && 0 <= ny && ny < grid[0].length && !grid[nx][ny] && !v[nx][ny]) {\n                                if (nx == destination.x && ny == destination.y) {\n                                    return dist;\n                                }\n                                q.offer(new Point(nx, ny));\n                                v[nx][ny] = true;\n                            }\n                        }\n                    }\n        \n                }\n                return -1;\n            }\n        }\n    `\n}\n\nexport default Knight_Shortest_Path\n"]},"metadata":{},"sourceType":"module"}