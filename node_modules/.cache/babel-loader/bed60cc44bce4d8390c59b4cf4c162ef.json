{"ast":null,"code":"const Reverse_Nodes_in_k_Group = {\n  id: '0042',\n  name: 'Reverse_Nodes_in_k_Group',\n  refLink: ['https://leetcode-cn.com/problems/reverse-nodes-in-k-group/solution/25-k-ge-yi-zu-fan-zhuan-lian-biao-by-alexer-660/', 'https://www.lintcode.com/problem/reverse-nodes-in-k-group/description', 'https://www.jiuzhang.com/solution/reverse-nodes-in-k-group/'],\n  level: 'Hard',\n  tag: [],\n  notes: ``,\n  jsSolution: `\n        // Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.\n\n        // If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.\n        \n        // You may not alter the values in the nodes, only nodes itself may be changed.\n        // Only constant memory is allowed.\n        \n        // 在线评测地址: https://www.lintcode.com/problem/reverse-nodes-in-k-group/\n\n        解法一：迭代\n        思路同206. 反转链表 - 解法一\n        区别\n        限制k个\n        用计数实现，实时更新链表需要反转部分的头、尾节点\n        /**\n         * Definition for singly-linked list.\n         * function ListNode(val) {\n         *     this.val = val;\n         *     this.next = null;\n         * }\n         */\n        /**\n         * @param {ListNode} head\n         * @param {number} k\n         * @return {ListNode}\n         */\n        var reverseKGroup = function(head, k) {\n            let cur = head;\n            let count = 0;\n            // 求k个待反转元素的首节点和尾节点\n            while(cur != null && count != k){\n                cur = cur.next;\n                count++;\n            }\n            // 足够k个节点，去反转\n            if(count == k){\n                // 递归链接后续k个反转的链表头节点\n                cur = reverseKGroup(cur,k);\n                while(count != 0){\n                    count--;\n                    // 反转链表\n                    let tmp = head.next;\n                    head.next = cur;\n                    cur = head;\n                    head = tmp;\n                }\n                head = cur;\n            }\n            return head;\n        };\n        解法二：递归 II\n        同解法一\n        区别\n        while改成for\n        /**\n         * Definition for singly-linked list.\n         * function ListNode(val) {\n         *     this.val = val;\n         *     this.next = null;\n         * }\n         */\n        /**\n         * @param {ListNode} head\n         * @param {number} k\n         * @return {ListNode}\n         */\n        var reverseKGroup = function(head, k) {\n            if(!head) return null;\n            // 反转链表\n            let reverse = (a,b) => {\n                let pre;\n                let cur = a;\n                let next = b;\n                while(cur != b){\n                    next = cur.next;\n                    cur.next = pre;\n                    pre = cur;\n                    cur = next;\n                }\n                return pre;\n            }\n            // 反转区间a-b的k个待反转的元素\n            let a = head;\n            let b = head;\n            for(let i = 0;i < k;i++){\n                // 不足k个，不需要反转\n                if(!b) return head;\n                b = b.next;\n            }\n            // 反转前k个元素\n            let newHead = reverse(a,b);\n            // 递归链接后续反转链表\n            a.next = reverseKGroup(b,k);\n            return newHead;\n        };\n        解法三：栈解\n        思路同206. 反转链表 - 解法四\n        区别\n        反转k个\n        /**\n         * Definition for singly-linked list.\n         * function ListNode(val) {\n         *     this.val = val;\n         *     this.next = null;\n         * }\n         */\n        /**\n         * @param {ListNode} head\n         * @param {number} k\n         * @return {ListNode}\n         */\n        var reverseKGroup = function(head, k) {\n            let stack = [];\n            let preHead = new ListNode(0);\n            let pre = preHead;\n            // 循环链接后续反转链表\n            while(true){\n                let count = 0;\n                let tmp = head;\n                while(tmp && count < k){\n                    stack.push(tmp);\n                    tmp = tmp.next;\n                    count++;\n                }\n                // 不够k个，直接链接剩下链表返回\n                if(count != k){\n                    pre.next = head;\n                    break;\n                }\n                // 出栈即是反转\n                while(stack.length > 0){\n                    pre.next = stack.pop();\n                    pre = pre.next;\n                }\n                pre.next = tmp;\n                head = tmp;\n            }\n            return preHead.next;\n        };\n    `\n};\nexport default Reverse_Nodes_in_k_Group;","map":{"version":3,"sources":["/Users/yabao/Documents/githubspace/Jutsai-Lab/src/apps/bao/baoApp/views/examples/JsLeetcode/js/Linked_List_Array/Reverse_Nodes_in_k_Group.js"],"names":["Reverse_Nodes_in_k_Group","id","name","refLink","level","tag","notes","jsSolution"],"mappings":"AAAA,MAAMA,wBAAwB,GAAG;AAC7BC,EAAAA,EAAE,EAAE,MADyB;AAE7BC,EAAAA,IAAI,EAAE,0BAFuB;AAG7BC,EAAAA,OAAO,EAAE,CACL,qHADK,EAEL,uEAFK,EAGL,6DAHK,CAHoB;AAQ7BC,EAAAA,KAAK,EAAE,MARsB;AAS7BC,EAAAA,GAAG,EAAE,EATwB;AAU7BC,EAAAA,KAAK,EAAG,EAVqB;AAW7BC,EAAAA,UAAU,EAAG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAXgB,CAAjC;AA0JA,eAAeP,wBAAf","sourcesContent":["const Reverse_Nodes_in_k_Group = { \n    id: '0042',\n    name: 'Reverse_Nodes_in_k_Group',\n    refLink: [\n        'https://leetcode-cn.com/problems/reverse-nodes-in-k-group/solution/25-k-ge-yi-zu-fan-zhuan-lian-biao-by-alexer-660/',\n        'https://www.lintcode.com/problem/reverse-nodes-in-k-group/description',\n        'https://www.jiuzhang.com/solution/reverse-nodes-in-k-group/'\n    ],\n    level: 'Hard',\n    tag: [],\n    notes: ``,\n    jsSolution: `\n        // Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.\n\n        // If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.\n        \n        // You may not alter the values in the nodes, only nodes itself may be changed.\n        // Only constant memory is allowed.\n        \n        // 在线评测地址: https://www.lintcode.com/problem/reverse-nodes-in-k-group/\n\n        解法一：迭代\n        思路同206. 反转链表 - 解法一\n        区别\n        限制k个\n        用计数实现，实时更新链表需要反转部分的头、尾节点\n        /**\n         * Definition for singly-linked list.\n         * function ListNode(val) {\n         *     this.val = val;\n         *     this.next = null;\n         * }\n         */\n        /**\n         * @param {ListNode} head\n         * @param {number} k\n         * @return {ListNode}\n         */\n        var reverseKGroup = function(head, k) {\n            let cur = head;\n            let count = 0;\n            // 求k个待反转元素的首节点和尾节点\n            while(cur != null && count != k){\n                cur = cur.next;\n                count++;\n            }\n            // 足够k个节点，去反转\n            if(count == k){\n                // 递归链接后续k个反转的链表头节点\n                cur = reverseKGroup(cur,k);\n                while(count != 0){\n                    count--;\n                    // 反转链表\n                    let tmp = head.next;\n                    head.next = cur;\n                    cur = head;\n                    head = tmp;\n                }\n                head = cur;\n            }\n            return head;\n        };\n        解法二：递归 II\n        同解法一\n        区别\n        while改成for\n        /**\n         * Definition for singly-linked list.\n         * function ListNode(val) {\n         *     this.val = val;\n         *     this.next = null;\n         * }\n         */\n        /**\n         * @param {ListNode} head\n         * @param {number} k\n         * @return {ListNode}\n         */\n        var reverseKGroup = function(head, k) {\n            if(!head) return null;\n            // 反转链表\n            let reverse = (a,b) => {\n                let pre;\n                let cur = a;\n                let next = b;\n                while(cur != b){\n                    next = cur.next;\n                    cur.next = pre;\n                    pre = cur;\n                    cur = next;\n                }\n                return pre;\n            }\n            // 反转区间a-b的k个待反转的元素\n            let a = head;\n            let b = head;\n            for(let i = 0;i < k;i++){\n                // 不足k个，不需要反转\n                if(!b) return head;\n                b = b.next;\n            }\n            // 反转前k个元素\n            let newHead = reverse(a,b);\n            // 递归链接后续反转链表\n            a.next = reverseKGroup(b,k);\n            return newHead;\n        };\n        解法三：栈解\n        思路同206. 反转链表 - 解法四\n        区别\n        反转k个\n        /**\n         * Definition for singly-linked list.\n         * function ListNode(val) {\n         *     this.val = val;\n         *     this.next = null;\n         * }\n         */\n        /**\n         * @param {ListNode} head\n         * @param {number} k\n         * @return {ListNode}\n         */\n        var reverseKGroup = function(head, k) {\n            let stack = [];\n            let preHead = new ListNode(0);\n            let pre = preHead;\n            // 循环链接后续反转链表\n            while(true){\n                let count = 0;\n                let tmp = head;\n                while(tmp && count < k){\n                    stack.push(tmp);\n                    tmp = tmp.next;\n                    count++;\n                }\n                // 不够k个，直接链接剩下链表返回\n                if(count != k){\n                    pre.next = head;\n                    break;\n                }\n                // 出栈即是反转\n                while(stack.length > 0){\n                    pre.next = stack.pop();\n                    pre = pre.next;\n                }\n                pre.next = tmp;\n                head = tmp;\n            }\n            return preHead.next;\n        };\n    `\n}\n\nexport default Reverse_Nodes_in_k_Group\n"]},"metadata":{},"sourceType":"module"}