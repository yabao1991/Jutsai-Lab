{"ast":null,"code":"var Sort_List={id:'0046',name:'Sort_List',refLink:['https://leetcode-cn.com/problems/sort-list/solution/148-pai-xu-lian-biao-by-alexer-660/','https://www.lintcode.com/problem/sort-list/description','https://www.jiuzhang.com/solution/sort-list/#tag-highlight'],level:'Hard',tag:[],notes:\"\",jsSolution:\"\\n        // Sort a linked list in O(n log n) time using constant space complexity.\\n\\n        // \\u5728\\u7EBF\\u8BC4\\u6D4B\\u5730\\u5740: https://www.lintcode.com/problem/sort-list/\\n\\n        \\u89E3\\u6CD5\\u4E00\\uFF1A\\u5F52\\u5E76\\u6392\\u5E8F - \\u9012\\u5F52\\n        \\u7ECF\\u5178\\u6392\\u5E8F\\u7B97\\u6CD5\\u8BB2\\u89E3 - \\u5F52\\u5E76\\u6392\\u5E8F - \\u9012\\u5F52\\u7248\\n        \\u8DDF\\u4E0A\\u8FF0\\u8BB2\\u89E3\\u601D\\u8DEF\\u4E00\\u6A21\\u4E00\\u6837\\n        \\u6458\\u6284\\u8BB2\\u89E3\\u5982\\u4E0B\\n        1\\u3001\\u628A\\u957F\\u5EA6\\u4E3An\\u7684\\u8F93\\u5165\\u5E8F\\u5217\\u5206\\u6210\\u4E24\\u4E2A\\u957F\\u5EA6\\u4E3An/2\\u7684\\u5B50\\u5E8F\\u5217\\n        2\\u3001\\u5BF9\\u8FD9\\u4E24\\u4E2A\\u5B50\\u5E8F\\u5217\\u5206\\u522B\\u91C7\\u7528\\u5F52\\u5E76\\u6392\\u5E8F\\n        3\\u3001\\u5C06\\u4E24\\u4E2A\\u6392\\u5E8F\\u597D\\u7684\\u5B50\\u5E8F\\u5217\\u5408\\u5E76\\u6210\\u4E00\\u4E2A\\u6700\\u7EC8\\u7684\\u6392\\u5E8F\\u5E8F\\u5217\\n        \\u5BF9\\u5E94\\u94FE\\u8868\\n        1\\u3001\\u7528\\u53CC\\u6307\\u9488\\u6CD5(\\u5FEB\\u6162\\u6307\\u9488)\\u5BFB\\u627E\\u94FE\\u8868\\u4E2D\\u95F4\\u8282\\u70B9\\n        \\u53C2\\u770B\\u94FE\\u8868\\u5404\\u79CD\\u64CD\\u4F5C\\u5927\\u5168 - \\u6C42\\u94FE\\u8868\\u7684\\u4E2D\\u95F4\\u8282\\u70B9\\n        \\u5947\\u6570\\u4E2A\\u8282\\u70B9\\u627E\\u5230\\u4E2D\\u70B9\\uFF0C\\u5076\\u6570\\u4E2A\\u8282\\u70B9\\u627E\\u5230\\u4E2D\\u5FC3\\u5DE6\\u8FB9\\u7684\\u8282\\u70B9\\n        \\u6CE8\\u610F\\n        \\u627E\\u5230\\u4E2D\\u70B9\\u540E\\uFF0C\\u8981\\u5C06\\u94FE\\u8868\\u5207\\u65AD\\uFF0C\\u5373 mid.next = null\\n        \\u56E0\\u94FE\\u8868\\u6027\\u8D28\\uFF0C\\u5DE6\\u8FB9\\u5B50\\u5E8F\\u5217\\u53D6\\u5DE6\\u7AEF\\u70B9\\u5373\\u53EF\\n        \\u540C\\u6570\\u7EC4\\u5F52\\u5E76\\u4E00\\u6837\\uFF0C\\u53EA\\u5269\\u4E00\\u4E2A\\u8282\\u70B9\\u65F6\\u7EC8\\u6B62\\n        \\u7528\\u4E8E\\u5206\\u6210\\u5DE6\\u53F3\\u4E24\\u8FB9\\u5B50\\u5E8F\\u5217\\n        \\u53F3\\u8FB9\\u5B50\\u5E8F\\u5217\\u4E3A\\u6162\\u6307\\u9488\\u7684next\\n        2\\u3001\\u9012\\u5F52\\u6392\\u5E8F\\u5DE6\\u53F3\\u5B50\\u5E8F\\u5217\\n        3\\u3001\\u5408\\u5E76\\n        \\u540C\\u6570\\u7EC4\\u4E00\\u6837\\uFF0C\\u5224\\u65AD\\u503C\\u7684\\u5927\\u5C0F\\n        \\u4E0D\\u540C\\u7684\\u662F\\uFF0C\\u7528\\u54E8\\u5175\\u8282\\u70B9\\u94FE\\u63A5\\u5408\\u5E76\\u540E\\u7684\\u94FE\\u8868\\uFF0C\\u8FD4\\u56DE\\u5373\\u53EF\\n        /**\\n         * Definition for singly-linked list.\\n         * function ListNode(val) {\\n         *     this.val = val;\\n         *     this.next = null;\\n         * }\\n         */\\n        /**\\n         * @param {ListNode} head\\n         * @return {ListNode}\\n         */\\n        var sortList = function(head) {\\n            let mergeList = (left,right) => {\\n                let res = new ListNode(0);\\n                let pre = res;\\n                while(left && right){\\n                    if(left.val <= right.val){\\n                        pre.next = left;\\n                        left = left.next;\\n                    }else{\\n                        pre.next = right;\\n                        right = right.next;\\n                    }\\n                    pre = pre.next;\\n                }\\n                pre.next = left ? left : right;\\n                return res.next;\\n            }\\n            let mergeSort = (node) => {\\n                if(!node || !node.next) return node;\\n                let mid = node;\\n                let fast = node.next;\\n                while(fast && fast.next){\\n                    mid = mid.next;\\n                    fast = fast.next.next;\\n                }\\n                let rightList = mid.next;\\n                mid.next = null;\\n                let left = node;\\n                let right = rightList;\\n                return mergeList(mergeSort(left),mergeSort(right));\\n            }\\n            return mergeSort(head);\\n        };\\n        \\u89E3\\u6CD5\\u4E8C\\uFF1A\\u5F52\\u5E76\\u6392\\u5E8F - \\u975E\\u9012\\u5F52\\n        \\u7ECF\\u5178\\u6392\\u5E8F\\u7B97\\u6CD5\\u8BB2\\u89E3 - \\u5F52\\u5E76\\u6392\\u5E8F - \\u975E\\u9012\\u5F52\\u7248\\n        \\u8DDF\\u4E0A\\u8FF0\\u8BB2\\u89E3\\u601D\\u8DEF\\u4E00\\u6A21\\u4E00\\u6837\\n        /**\\n         * Definition for singly-linked list.\\n         * function ListNode(val) {\\n         *     this.val = val;\\n         *     this.next = null;\\n         * }\\n         */\\n        /**\\n         * @param {ListNode} head\\n         * @return {ListNode}\\n         */\\n        var sortList = function(head) {\\n            // \\u54E8\\u5175\\u8282\\u70B9\\n            let preHead = new ListNode(0);\\n            preHead.next = head;\\n            // \\u6C42\\u94FE\\u8868\\u957F\\u5EA6\\n            let n = 0;\\n            let curr = head;\\n            while(curr){\\n                curr = curr.next;\\n                n++;\\n            }\\n            // \\u5206\\u5272i\\u957F\\u5EA6\\u7684\\u94FE\\u8868\\uFF0C\\u8FD4\\u56DE\\u5269\\u4F59\\u7684\\u94FE\\u8868\\n            let split = (node,i) => {\\n                while(i != 1 && node){\\n                    node = node.next;\\n                    i--;\\n                }\\n                let rest = node ? node.next : null;\\n                if(node) node.next = null;\\n                return rest;\\n            }\\n            // \\u5408\\u5E76\\n            let merge = (left,right,pre) => {\\n                let curr = pre;\\n                while(left && right){\\n                    if(left.val <= right.val){\\n                        curr.next = left;\\n                        left = left.next;\\n                    }else{\\n                        curr.next = right;\\n                        right = right.next;\\n                    }\\n                    curr = curr.next;\\n                }\\n                curr.next = left || right;\\n                while(curr.next) curr = curr.next;\\n                return curr;\\n            }\\n            // \\u5408\\u5E76 2*i \\u4E2A\\n            for(let i = 1;i < n;i *= 2){\\n                let pre = preHead;\\n                let curr = preHead.next;\\n                // \\u5206\\u5272\\u5DE6\\u53F3\\u4E24\\u90E8\\u5206\\u94FE\\u8868\\uFF0C\\u5E76\\u5408\\u5E76\\n                while(curr){\\n                    let left = curr;\\n                    let right = split(left,i);\\n                    curr = split(right,i);\\n                    pre = merge(left,right,pre);\\n                }\\n            }\\n            return preHead.next;\\n        };\\n    \"};export default Sort_List;","map":{"version":3,"sources":["/Users/yabao/Documents/githubspace/Jutsai-Lab/src/apps/bao/baoApp/views/examples/JsLeetcode/js/Linked_List_Array/Sort_List.js"],"names":["Sort_List","id","name","refLink","level","tag","notes","jsSolution"],"mappings":"AAAA,GAAMA,CAAAA,SAAS,CAAG,CACdC,EAAE,CAAE,MADU,CAEdC,IAAI,CAAE,WAFQ,CAGdC,OAAO,CAAE,CACL,yFADK,CAEL,wDAFK,CAGL,4DAHK,CAHK,CAQdC,KAAK,CAAE,MARO,CASdC,GAAG,CAAE,EATS,CAUdC,KAAK,GAVS,CAWdC,UAAU,sgMAXI,CAAlB,CAsJA,cAAeP,CAAAA,SAAf","sourcesContent":["const Sort_List = {\n    id: '0046',\n    name: 'Sort_List',\n    refLink: [\n        'https://leetcode-cn.com/problems/sort-list/solution/148-pai-xu-lian-biao-by-alexer-660/',\n        'https://www.lintcode.com/problem/sort-list/description',\n        'https://www.jiuzhang.com/solution/sort-list/#tag-highlight'\n    ],\n    level: 'Hard',\n    tag: [],\n    notes: ``,\n    jsSolution: `\n        // Sort a linked list in O(n log n) time using constant space complexity.\n\n        // 在线评测地址: https://www.lintcode.com/problem/sort-list/\n\n        解法一：归并排序 - 递归\n        经典排序算法讲解 - 归并排序 - 递归版\n        跟上述讲解思路一模一样\n        摘抄讲解如下\n        1、把长度为n的输入序列分成两个长度为n/2的子序列\n        2、对这两个子序列分别采用归并排序\n        3、将两个排序好的子序列合并成一个最终的排序序列\n        对应链表\n        1、用双指针法(快慢指针)寻找链表中间节点\n        参看链表各种操作大全 - 求链表的中间节点\n        奇数个节点找到中点，偶数个节点找到中心左边的节点\n        注意\n        找到中点后，要将链表切断，即 mid.next = null\n        因链表性质，左边子序列取左端点即可\n        同数组归并一样，只剩一个节点时终止\n        用于分成左右两边子序列\n        右边子序列为慢指针的next\n        2、递归排序左右子序列\n        3、合并\n        同数组一样，判断值的大小\n        不同的是，用哨兵节点链接合并后的链表，返回即可\n        /**\n         * Definition for singly-linked list.\n         * function ListNode(val) {\n         *     this.val = val;\n         *     this.next = null;\n         * }\n         */\n        /**\n         * @param {ListNode} head\n         * @return {ListNode}\n         */\n        var sortList = function(head) {\n            let mergeList = (left,right) => {\n                let res = new ListNode(0);\n                let pre = res;\n                while(left && right){\n                    if(left.val <= right.val){\n                        pre.next = left;\n                        left = left.next;\n                    }else{\n                        pre.next = right;\n                        right = right.next;\n                    }\n                    pre = pre.next;\n                }\n                pre.next = left ? left : right;\n                return res.next;\n            }\n            let mergeSort = (node) => {\n                if(!node || !node.next) return node;\n                let mid = node;\n                let fast = node.next;\n                while(fast && fast.next){\n                    mid = mid.next;\n                    fast = fast.next.next;\n                }\n                let rightList = mid.next;\n                mid.next = null;\n                let left = node;\n                let right = rightList;\n                return mergeList(mergeSort(left),mergeSort(right));\n            }\n            return mergeSort(head);\n        };\n        解法二：归并排序 - 非递归\n        经典排序算法讲解 - 归并排序 - 非递归版\n        跟上述讲解思路一模一样\n        /**\n         * Definition for singly-linked list.\n         * function ListNode(val) {\n         *     this.val = val;\n         *     this.next = null;\n         * }\n         */\n        /**\n         * @param {ListNode} head\n         * @return {ListNode}\n         */\n        var sortList = function(head) {\n            // 哨兵节点\n            let preHead = new ListNode(0);\n            preHead.next = head;\n            // 求链表长度\n            let n = 0;\n            let curr = head;\n            while(curr){\n                curr = curr.next;\n                n++;\n            }\n            // 分割i长度的链表，返回剩余的链表\n            let split = (node,i) => {\n                while(i != 1 && node){\n                    node = node.next;\n                    i--;\n                }\n                let rest = node ? node.next : null;\n                if(node) node.next = null;\n                return rest;\n            }\n            // 合并\n            let merge = (left,right,pre) => {\n                let curr = pre;\n                while(left && right){\n                    if(left.val <= right.val){\n                        curr.next = left;\n                        left = left.next;\n                    }else{\n                        curr.next = right;\n                        right = right.next;\n                    }\n                    curr = curr.next;\n                }\n                curr.next = left || right;\n                while(curr.next) curr = curr.next;\n                return curr;\n            }\n            // 合并 2*i 个\n            for(let i = 1;i < n;i *= 2){\n                let pre = preHead;\n                let curr = preHead.next;\n                // 分割左右两部分链表，并合并\n                while(curr){\n                    let left = curr;\n                    let right = split(left,i);\n                    curr = split(right,i);\n                    pre = merge(left,right,pre);\n                }\n            }\n            return preHead.next;\n        };\n    `\n}\n\nexport default Sort_List\n"]},"metadata":{},"sourceType":"module"}