{"ast":null,"code":"const Clone_Graph = {\n  id: '0029',\n  name: 'Clone_Graph',\n  refLink: ['https://www.lintcode.com/problem/clone-graph/description', 'https://www.jiuzhang.com/solution/clone-graph/', 'https://leetcode-cn.com/problems/clone-graph/solution/jsshen-du-bian-li-jian-ji-ban-ben-by-armin/'],\n  level: 'Medium',\n  tag: [''],\n  notes: `JAVA only`,\n  jsSolution: `\n        // Clone an undirected graph. Each node in the graph contains a label and a list of its neighbors. Nodes are labeled uniquely.\n\n        // You need to return a deep copied graph, which has the same structure as the original graph, and any changes to the new graph will not have any effect on the original graph.\n        \n        // 在线评测地址: https://www.lintcode.com/problem/clone-graph/\n\n\n        从原图给定的点找到所有点\n        复制所有的点\n        复制所有的边\n        /**\n        * 本参考程序来自九章算法，由 @ 提供。版权所有，转发请注明出处。\n        * - 九章算法致力于帮助更多中国人找到好的工作，教师团队均来自硅谷和国内的一线大公司在职工程师。\n        * - 现有的面试培训课程包括：九章算法班，系统设计班，算法强化班，Java入门与基础算法班，Android 项目实战班，\n        * - Big Data 项目实战班，算法面试高频题班, 动态规划专题班\n        * - 更多详情请见官方网站：http://www.jiuzhang.com/?source=code\n        */ \n\n        /**\n         * Definition for undirected graph.\n         * class UndirectedGraphNode {\n         *     int label;\n         *     ArrayList<UndirectedGraphNode> neighbors;\n         *     UndirectedGraphNode(int x) { label = x; neighbors = new ArrayList<UndirectedGraphNode>(); }\n         * };\n         */\n        public class Solution {\n            /**\n             * @param node: A undirected graph node\n             * @return: A undirected graph node\n             */\n            public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) {\n                if (node == null) {\n                    return node;\n                }\n\n                // use bfs algorithm to traverse the graph and get all nodes.\n                ArrayList<UndirectedGraphNode> nodes = getNodes(node);\n\n                // copy nodes, store the old->new mapping information in a hash map\n                HashMap<UndirectedGraphNode, UndirectedGraphNode> mapping = new HashMap<>();\n                for (UndirectedGraphNode n : nodes) {\n                    mapping.put(n, new UndirectedGraphNode(n.label));\n                }\n\n                // copy neighbors(edges)\n                for (UndirectedGraphNode n : nodes) {\n                    UndirectedGraphNode newNode = mapping.get(n);\n                    for (UndirectedGraphNode neighbor : n.neighbors) {\n                        UndirectedGraphNode newNeighbor = mapping.get(neighbor);\n                        newNode.neighbors.add(newNeighbor);\n                    }\n                }\n\n                return mapping.get(node);\n            }\n\n            private ArrayList<UndirectedGraphNode> getNodes(UndirectedGraphNode node) {\n                Queue<UndirectedGraphNode> queue = new LinkedList<UndirectedGraphNode>();\n                HashSet<UndirectedGraphNode> set = new HashSet<>();\n\n                queue.offer(node);\n                set.add(node);\n                while (!queue.isEmpty()) {\n                    UndirectedGraphNode head = queue.poll();\n                    for (UndirectedGraphNode neighbor : head.neighbors) {\n                        if (!set.contains(neighbor)) {\n                            set.add(neighbor);\n                            queue.offer(neighbor);\n                        }\n                    }\n                }\n\n                return new ArrayList<UndirectedGraphNode>(set);\n            }\n        }\n    `\n};\nexport default Clone_Graph;","map":{"version":3,"sources":["/Users/yabao/Documents/githubspace/Jutsai-Lab/src/apps/bao/baoApp/views/examples/JsLeetcode/js/Breadth_First_Search/Clone_Graph.js"],"names":["Clone_Graph","id","name","refLink","level","tag","notes","jsSolution"],"mappings":"AAAA,MAAMA,WAAW,GAAG;AAChBC,EAAAA,EAAE,EAAE,MADY;AAEhBC,EAAAA,IAAI,EAAE,aAFU;AAGhBC,EAAAA,OAAO,EAAE,CACL,0DADK,EAEL,gDAFK,EAGL,mGAHK,CAHO;AAQhBC,EAAAA,KAAK,EAAE,QARS;AAShBC,EAAAA,GAAG,EAAE,CACD,EADC,CATW;AAYhBC,EAAAA,KAAK,EAAG,WAZQ;AAahBC,EAAAA,UAAU,EAAG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAbG,CAApB;AA6FA,eAAeP,WAAf","sourcesContent":["const Clone_Graph = {\n    id: '0029',\n    name: 'Clone_Graph',\n    refLink: [\n        'https://www.lintcode.com/problem/clone-graph/description',\n        'https://www.jiuzhang.com/solution/clone-graph/',\n        'https://leetcode-cn.com/problems/clone-graph/solution/jsshen-du-bian-li-jian-ji-ban-ben-by-armin/'\n    ],\n    level: 'Medium',\n    tag: [\n        ''\n    ],\n    notes: `JAVA only`,\n    jsSolution: `\n        // Clone an undirected graph. Each node in the graph contains a label and a list of its neighbors. Nodes are labeled uniquely.\n\n        // You need to return a deep copied graph, which has the same structure as the original graph, and any changes to the new graph will not have any effect on the original graph.\n        \n        // 在线评测地址: https://www.lintcode.com/problem/clone-graph/\n\n\n        从原图给定的点找到所有点\n        复制所有的点\n        复制所有的边\n        /**\n        * 本参考程序来自九章算法，由 @ 提供。版权所有，转发请注明出处。\n        * - 九章算法致力于帮助更多中国人找到好的工作，教师团队均来自硅谷和国内的一线大公司在职工程师。\n        * - 现有的面试培训课程包括：九章算法班，系统设计班，算法强化班，Java入门与基础算法班，Android 项目实战班，\n        * - Big Data 项目实战班，算法面试高频题班, 动态规划专题班\n        * - 更多详情请见官方网站：http://www.jiuzhang.com/?source=code\n        */ \n\n        /**\n         * Definition for undirected graph.\n         * class UndirectedGraphNode {\n         *     int label;\n         *     ArrayList<UndirectedGraphNode> neighbors;\n         *     UndirectedGraphNode(int x) { label = x; neighbors = new ArrayList<UndirectedGraphNode>(); }\n         * };\n         */\n        public class Solution {\n            /**\n             * @param node: A undirected graph node\n             * @return: A undirected graph node\n             */\n            public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) {\n                if (node == null) {\n                    return node;\n                }\n\n                // use bfs algorithm to traverse the graph and get all nodes.\n                ArrayList<UndirectedGraphNode> nodes = getNodes(node);\n\n                // copy nodes, store the old->new mapping information in a hash map\n                HashMap<UndirectedGraphNode, UndirectedGraphNode> mapping = new HashMap<>();\n                for (UndirectedGraphNode n : nodes) {\n                    mapping.put(n, new UndirectedGraphNode(n.label));\n                }\n\n                // copy neighbors(edges)\n                for (UndirectedGraphNode n : nodes) {\n                    UndirectedGraphNode newNode = mapping.get(n);\n                    for (UndirectedGraphNode neighbor : n.neighbors) {\n                        UndirectedGraphNode newNeighbor = mapping.get(neighbor);\n                        newNode.neighbors.add(newNeighbor);\n                    }\n                }\n\n                return mapping.get(node);\n            }\n\n            private ArrayList<UndirectedGraphNode> getNodes(UndirectedGraphNode node) {\n                Queue<UndirectedGraphNode> queue = new LinkedList<UndirectedGraphNode>();\n                HashSet<UndirectedGraphNode> set = new HashSet<>();\n\n                queue.offer(node);\n                set.add(node);\n                while (!queue.isEmpty()) {\n                    UndirectedGraphNode head = queue.poll();\n                    for (UndirectedGraphNode neighbor : head.neighbors) {\n                        if (!set.contains(neighbor)) {\n                            set.add(neighbor);\n                            queue.offer(neighbor);\n                        }\n                    }\n                }\n\n                return new ArrayList<UndirectedGraphNode>(set);\n            }\n        }\n    `\n}\n\nexport default Clone_Graph\n"]},"metadata":{},"sourceType":"module"}