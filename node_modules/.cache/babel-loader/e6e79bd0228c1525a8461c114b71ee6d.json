{"ast":null,"code":"const Combination_Sum = {\n  id: '0035',\n  name: 'Combination_Sum',\n  refLink: ['https://leetcode-cn.com/problems/combination-sum/solution/39-zu-he-zong-he-by-alexer-660/', 'https://www.lintcode.com/problem/combination-sum/description', 'https://www.jiuzhang.com/solution/combination-sum/'],\n  level: 'Easy',\n  tag: [],\n  notes: ``,\n  jsSolution: `\n        // Given a set of candidtate numbers candidates and a target number target. Find all unique combinations in candidates where the numbers sums to target.\n\n        // The same repeated number may be chosen from candidates unlimited number of times.\n        \n        // 在线评测地址: https://www.lintcode.com/problem/combination-sum/\n\n        解法一：递归回溯\n        类似题型\n        46. 全排列\n        递归代码模板\n        参看各类算法模板 - 递归一节 - Python&Java版\n        思路\n        由题可知，原数组\n        元素不重复\n        寻找一个符合条件的组合\n        且原数组的单个元素可以重复使用\n        只要结果中的子组合互不相同即可\n        求解\n        且原数组的单个元素可以重复使用\n        意味着下一个for循环中的元素选取，要从前一个元素开始，因为可以重复使用，不然如果跟着for的自增变量i走，会漏掉可能解\n        将自增变量i传递下去\n        终止条件\n        target 一一减去符合组合的元素，最终为 0 ，才是一个符合题意的组合\n        /**\n         * @param {number[]} candidates\n         * @param {number} target\n         * @return {number[][]}\n         */\n        var combinationSum = function(candidates, target) {\n            let n = candidates.length;\n            let res = [];\n            let tmpPath = [];\n            let backtrack = (tmpPath,target,start) => {\n                if(target < 0){\n                    return;\n                }\n                if(target == 0){\n                    res.push(tmpPath);\n                    return;\n                }\n                for(let i = start;i < n;i++){\n                    tmpPath.push(candidates[i]);\n                    backtrack(tmpPath.slice(),target - candidates[i],i);\n                    tmpPath.pop();\n                }\n            }\n            backtrack(tmpPath,target,0);\n            return res;\n        };\n        解法二：递归回溯 + 减枝\n        类似题型\n        47. 全排列 II - 解法二\n        重复问题\n        [1,3,5,6] target = 8\n        当tmpPath = [1,3]时\n        target = 8 - 1 - 3 = 4\n        此时 4 < 5\n        因此之后比5更大的元素也是不合题意的，对于所有组合中以[1,3]为首的组合无需再进行下一步组合，直接进行下一轮组合\n        当以[1,3]两个元素为尾部或中间部分的可能组合就有可能是正确的\n        结果\n        [[1,1,1,1,1,1,1,1],[1,1,1,1,1,3],[1,1,1,5],[1,1,3,3],[1,1,6],[3,5]]\n        剪枝\n        排序原数组\n        如重复问题示例操作，翻译成代码即可\n        也说明了排序的意义所在\n        /**\n         * @param {number[]} candidates\n         * @param {number} target\n         * @return {number[][]}\n         */\n        var combinationSum = function(candidates, target) {\n            let n = candidates.length;\n            let res = [];\n            let tmpPath = [];\n            candidates = candidates.sort((a,b) => {return a - b})\n            let backtrack = (tmpPath,target,start) => {\n                if(target == 0){\n                    res.push(tmpPath);\n                    return;\n                }\n                for(let i = start;i < n;i++){\n                    if(target < candidates[i]) break;\n                    tmpPath.push(candidates[i]);\n                    backtrack(tmpPath.slice(),target - candidates[i],i);\n                    tmpPath.pop();\n                }\n            }\n            backtrack(tmpPath,target,0);\n            return res;\n        };\n    `\n};\nexport default Combination_Sum;","map":{"version":3,"sources":["/Users/yabao/Documents/githubspace/Jutsai-Lab/src/apps/bao/baoApp/views/examples/JsLeetcode/js/Depth_First_Search/Combination_Sum.js"],"names":["Combination_Sum","id","name","refLink","level","tag","notes","jsSolution"],"mappings":"AAAA,MAAMA,eAAe,GAAG;AACpBC,EAAAA,EAAE,EAAE,MADgB;AAEpBC,EAAAA,IAAI,EAAE,iBAFc;AAGpBC,EAAAA,OAAO,EAAE,CACL,2FADK,EAEL,8DAFK,EAGL,oDAHK,CAHW;AAQpBC,EAAAA,KAAK,EAAE,MARa;AASpBC,EAAAA,GAAG,EAAE,EATe;AAUpBC,EAAAA,KAAK,EAAG,EAVY;AAWpBC,EAAAA,UAAU,EAAG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAXO,CAAxB;AAyGA,eAAeP,eAAf","sourcesContent":["const Combination_Sum = {\n    id: '0035',\n    name: 'Combination_Sum', \n    refLink: [\n        'https://leetcode-cn.com/problems/combination-sum/solution/39-zu-he-zong-he-by-alexer-660/',\n        'https://www.lintcode.com/problem/combination-sum/description',\n        'https://www.jiuzhang.com/solution/combination-sum/'\n    ],\n    level: 'Easy',\n    tag: [],\n    notes: ``,\n    jsSolution: `\n        // Given a set of candidtate numbers candidates and a target number target. Find all unique combinations in candidates where the numbers sums to target.\n\n        // The same repeated number may be chosen from candidates unlimited number of times.\n        \n        // 在线评测地址: https://www.lintcode.com/problem/combination-sum/\n\n        解法一：递归回溯\n        类似题型\n        46. 全排列\n        递归代码模板\n        参看各类算法模板 - 递归一节 - Python&Java版\n        思路\n        由题可知，原数组\n        元素不重复\n        寻找一个符合条件的组合\n        且原数组的单个元素可以重复使用\n        只要结果中的子组合互不相同即可\n        求解\n        且原数组的单个元素可以重复使用\n        意味着下一个for循环中的元素选取，要从前一个元素开始，因为可以重复使用，不然如果跟着for的自增变量i走，会漏掉可能解\n        将自增变量i传递下去\n        终止条件\n        target 一一减去符合组合的元素，最终为 0 ，才是一个符合题意的组合\n        /**\n         * @param {number[]} candidates\n         * @param {number} target\n         * @return {number[][]}\n         */\n        var combinationSum = function(candidates, target) {\n            let n = candidates.length;\n            let res = [];\n            let tmpPath = [];\n            let backtrack = (tmpPath,target,start) => {\n                if(target < 0){\n                    return;\n                }\n                if(target == 0){\n                    res.push(tmpPath);\n                    return;\n                }\n                for(let i = start;i < n;i++){\n                    tmpPath.push(candidates[i]);\n                    backtrack(tmpPath.slice(),target - candidates[i],i);\n                    tmpPath.pop();\n                }\n            }\n            backtrack(tmpPath,target,0);\n            return res;\n        };\n        解法二：递归回溯 + 减枝\n        类似题型\n        47. 全排列 II - 解法二\n        重复问题\n        [1,3,5,6] target = 8\n        当tmpPath = [1,3]时\n        target = 8 - 1 - 3 = 4\n        此时 4 < 5\n        因此之后比5更大的元素也是不合题意的，对于所有组合中以[1,3]为首的组合无需再进行下一步组合，直接进行下一轮组合\n        当以[1,3]两个元素为尾部或中间部分的可能组合就有可能是正确的\n        结果\n        [[1,1,1,1,1,1,1,1],[1,1,1,1,1,3],[1,1,1,5],[1,1,3,3],[1,1,6],[3,5]]\n        剪枝\n        排序原数组\n        如重复问题示例操作，翻译成代码即可\n        也说明了排序的意义所在\n        /**\n         * @param {number[]} candidates\n         * @param {number} target\n         * @return {number[][]}\n         */\n        var combinationSum = function(candidates, target) {\n            let n = candidates.length;\n            let res = [];\n            let tmpPath = [];\n            candidates = candidates.sort((a,b) => {return a - b})\n            let backtrack = (tmpPath,target,start) => {\n                if(target == 0){\n                    res.push(tmpPath);\n                    return;\n                }\n                for(let i = start;i < n;i++){\n                    if(target < candidates[i]) break;\n                    tmpPath.push(candidates[i]);\n                    backtrack(tmpPath.slice(),target - candidates[i],i);\n                    tmpPath.pop();\n                }\n            }\n            backtrack(tmpPath,target,0);\n            return res;\n        };\n    `\n}\n\nexport default Combination_Sum\n"]},"metadata":{},"sourceType":"module"}