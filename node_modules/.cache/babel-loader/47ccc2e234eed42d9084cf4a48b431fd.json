{"ast":null,"code":"var Subtree_with_Maximum_Average={id:'0021',name:'Subtree_with_Maximum_Average',refLink:['https://www.lintcode.com/problem/subtree-with-maximum-average/description','https://www.jiuzhang.com/solution/subtree-with-maximum-average/'],level:'Easy',tag:[],notes:\"JAVA only\",jsSolution:\"\\n        // Given a binary tree, find the subtree with maximum average. Return the root of the subtree.\\n\\n        // \\u5728\\u7EBF\\u8BC4\\u6D4B\\u5730\\u5740: https://www.lintcode.com/problem/subtree-with-maximum-average/\\n\\n        // version 1: Traverse + Divide Conquer\\n        public class Solution {\\n            private class ResultType {\\n                public int sum, size;\\n                public ResultType(int sum, int size) {\\n                    this.sum = sum;\\n                    this.size = size;\\n                }\\n            }\\n            \\n            private TreeNode subtree = null;\\n            private ResultType subtreeResult = null;\\n            \\n            /**\\n             * @param root the root of binary tree\\n             * @return the root of the maximum average of subtree\\n             */\\n            public TreeNode findSubtree2(TreeNode root) {\\n                helper(root);\\n                return subtree;\\n            }\\n            \\n            private ResultType helper(TreeNode root) {\\n                if (root == null) {\\n                    return new ResultType(0, 0);\\n                }\\n                // \\u5206\\u6CBB\\u6CD5\\u8BA1\\u7B97\\u5DE6\\u53F3\\u5B50\\u6811\\u7684\\u5E73\\u5747\\u503C\\n                ResultType left = helper(root.left);\\n                ResultType right = helper(root.right);\\n                // \\u5F53\\u524Dsubtree\\u7684\\u7ED3\\u679C\\u662F\\u5DE6\\u53F3\\u4E24\\u9897\\u5B50\\u6811\\u7684\\u548C\\u7684\\u5E73\\u5747\\u503C\\u52A0\\u4E0A\\u81EA\\u8EAB\\n                ResultType result = new ResultType(\\n                    left.sum + right.sum + root.val,\\n                    left.size + right.size + 1\\n                );\\n                // \\u6253\\u64C2\\u53F0\\u6BD4\\u8F83\\u5F97\\u5230\\u6700\\u5927\\u5E73\\u5747\\u503C\\u7684\\u5B50\\u6811\\n                if (subtree == null ||\\n                    subtreeResult.sum * result.size < result.sum * subtreeResult.size\\n                ) {\\n                    subtree = root;\\n                    subtreeResult = result;\\n                }\\n                return result;\\n            }\\n        }\\n    \"};export default Subtree_with_Maximum_Average;","map":{"version":3,"sources":["/Users/yabao/Documents/githubspace/Jutsai-Lab/src/apps/bao/baoApp/views/examples/JsLeetcode/js/Binary_Tree_Divide_Conquer/Subtree_with_Maximum_Average.js"],"names":["Subtree_with_Maximum_Average","id","name","refLink","level","tag","notes","jsSolution"],"mappings":"AAAA,GAAMA,CAAAA,4BAA4B,CAAG,CACjCC,EAAE,CAAE,MAD6B,CAEjCC,IAAI,CAAE,8BAF2B,CAGjCC,OAAO,CAAE,CACL,2EADK,CAEL,iEAFK,CAHwB,CAOjCC,KAAK,CAAE,MAP0B,CAQjCC,GAAG,CAAE,EAR4B,CASjCC,KAAK,YAT4B,CAUjCC,UAAU,kkEAVuB,CAArC,CA8DA,cAAeP,CAAAA,4BAAf","sourcesContent":["const Subtree_with_Maximum_Average = {\n    id: '0021',\n    name: 'Subtree_with_Maximum_Average',\n    refLink: [\n        'https://www.lintcode.com/problem/subtree-with-maximum-average/description',\n        'https://www.jiuzhang.com/solution/subtree-with-maximum-average/'\n    ],\n    level: 'Easy',\n    tag: [],\n    notes: `JAVA only`,\n    jsSolution: `\n        // Given a binary tree, find the subtree with maximum average. Return the root of the subtree.\n\n        // 在线评测地址: https://www.lintcode.com/problem/subtree-with-maximum-average/\n\n        // version 1: Traverse + Divide Conquer\n        public class Solution {\n            private class ResultType {\n                public int sum, size;\n                public ResultType(int sum, int size) {\n                    this.sum = sum;\n                    this.size = size;\n                }\n            }\n            \n            private TreeNode subtree = null;\n            private ResultType subtreeResult = null;\n            \n            /**\n             * @param root the root of binary tree\n             * @return the root of the maximum average of subtree\n             */\n            public TreeNode findSubtree2(TreeNode root) {\n                helper(root);\n                return subtree;\n            }\n            \n            private ResultType helper(TreeNode root) {\n                if (root == null) {\n                    return new ResultType(0, 0);\n                }\n                // 分治法计算左右子树的平均值\n                ResultType left = helper(root.left);\n                ResultType right = helper(root.right);\n                // 当前subtree的结果是左右两颗子树的和的平均值加上自身\n                ResultType result = new ResultType(\n                    left.sum + right.sum + root.val,\n                    left.size + right.size + 1\n                );\n                // 打擂台比较得到最大平均值的子树\n                if (subtree == null ||\n                    subtreeResult.sum * result.size < result.sum * subtreeResult.size\n                ) {\n                    subtree = root;\n                    subtreeResult = result;\n                }\n                return result;\n            }\n        }\n    `\n}\n\nexport default Subtree_with_Maximum_Average\n"]},"metadata":{},"sourceType":"module"}