{"ast":null,"code":"var Combination_Sum={id:'0035',name:'Combination_Sum',refLink:['https://leetcode-cn.com/problems/combination-sum/solution/39-zu-he-zong-he-by-alexer-660/','https://www.lintcode.com/problem/combination-sum/description','https://www.jiuzhang.com/solution/combination-sum/'],level:'Easy',tag:[],notes:\"\",jsSolution:\"\\n        // Given a set of candidtate numbers candidates and a target number target. Find all unique combinations in candidates where the numbers sums to target.\\n\\n        // The same repeated number may be chosen from candidates unlimited number of times.\\n        \\n        // \\u5728\\u7EBF\\u8BC4\\u6D4B\\u5730\\u5740: https://www.lintcode.com/problem/combination-sum/\\n\\n        \\u89E3\\u6CD5\\u4E00\\uFF1A\\u9012\\u5F52\\u56DE\\u6EAF\\n        \\u7C7B\\u4F3C\\u9898\\u578B\\n        46. \\u5168\\u6392\\u5217\\n        \\u9012\\u5F52\\u4EE3\\u7801\\u6A21\\u677F\\n        \\u53C2\\u770B\\u5404\\u7C7B\\u7B97\\u6CD5\\u6A21\\u677F - \\u9012\\u5F52\\u4E00\\u8282 - Python&Java\\u7248\\n        \\u601D\\u8DEF\\n        \\u7531\\u9898\\u53EF\\u77E5\\uFF0C\\u539F\\u6570\\u7EC4\\n        \\u5143\\u7D20\\u4E0D\\u91CD\\u590D\\n        \\u5BFB\\u627E\\u4E00\\u4E2A\\u7B26\\u5408\\u6761\\u4EF6\\u7684\\u7EC4\\u5408\\n        \\u4E14\\u539F\\u6570\\u7EC4\\u7684\\u5355\\u4E2A\\u5143\\u7D20\\u53EF\\u4EE5\\u91CD\\u590D\\u4F7F\\u7528\\n        \\u53EA\\u8981\\u7ED3\\u679C\\u4E2D\\u7684\\u5B50\\u7EC4\\u5408\\u4E92\\u4E0D\\u76F8\\u540C\\u5373\\u53EF\\n        \\u6C42\\u89E3\\n        \\u4E14\\u539F\\u6570\\u7EC4\\u7684\\u5355\\u4E2A\\u5143\\u7D20\\u53EF\\u4EE5\\u91CD\\u590D\\u4F7F\\u7528\\n        \\u610F\\u5473\\u7740\\u4E0B\\u4E00\\u4E2Afor\\u5FAA\\u73AF\\u4E2D\\u7684\\u5143\\u7D20\\u9009\\u53D6\\uFF0C\\u8981\\u4ECE\\u524D\\u4E00\\u4E2A\\u5143\\u7D20\\u5F00\\u59CB\\uFF0C\\u56E0\\u4E3A\\u53EF\\u4EE5\\u91CD\\u590D\\u4F7F\\u7528\\uFF0C\\u4E0D\\u7136\\u5982\\u679C\\u8DDF\\u7740for\\u7684\\u81EA\\u589E\\u53D8\\u91CFi\\u8D70\\uFF0C\\u4F1A\\u6F0F\\u6389\\u53EF\\u80FD\\u89E3\\n        \\u5C06\\u81EA\\u589E\\u53D8\\u91CFi\\u4F20\\u9012\\u4E0B\\u53BB\\n        \\u7EC8\\u6B62\\u6761\\u4EF6\\n        target \\u4E00\\u4E00\\u51CF\\u53BB\\u7B26\\u5408\\u7EC4\\u5408\\u7684\\u5143\\u7D20\\uFF0C\\u6700\\u7EC8\\u4E3A 0 \\uFF0C\\u624D\\u662F\\u4E00\\u4E2A\\u7B26\\u5408\\u9898\\u610F\\u7684\\u7EC4\\u5408\\n        /**\\n         * @param {number[]} candidates\\n         * @param {number} target\\n         * @return {number[][]}\\n         */\\n        var combinationSum = function(candidates, target) {\\n            let n = candidates.length;\\n            let res = [];\\n            let tmpPath = [];\\n            let backtrack = (tmpPath,target,start) => {\\n                if(target < 0){\\n                    return;\\n                }\\n                if(target == 0){\\n                    res.push(tmpPath);\\n                    return;\\n                }\\n                for(let i = start;i < n;i++){\\n                    tmpPath.push(candidates[i]);\\n                    backtrack(tmpPath.slice(),target - candidates[i],i);\\n                    tmpPath.pop();\\n                }\\n            }\\n            backtrack(tmpPath,target,0);\\n            return res;\\n        };\\n        \\u89E3\\u6CD5\\u4E8C\\uFF1A\\u9012\\u5F52\\u56DE\\u6EAF + \\u51CF\\u679D\\n        \\u7C7B\\u4F3C\\u9898\\u578B\\n        47. \\u5168\\u6392\\u5217 II - \\u89E3\\u6CD5\\u4E8C\\n        \\u91CD\\u590D\\u95EE\\u9898\\n        [1,3,5,6] target = 8\\n        \\u5F53tmpPath = [1,3]\\u65F6\\n        target = 8 - 1 - 3 = 4\\n        \\u6B64\\u65F6 4 < 5\\n        \\u56E0\\u6B64\\u4E4B\\u540E\\u6BD45\\u66F4\\u5927\\u7684\\u5143\\u7D20\\u4E5F\\u662F\\u4E0D\\u5408\\u9898\\u610F\\u7684\\uFF0C\\u5BF9\\u4E8E\\u6240\\u6709\\u7EC4\\u5408\\u4E2D\\u4EE5[1,3]\\u4E3A\\u9996\\u7684\\u7EC4\\u5408\\u65E0\\u9700\\u518D\\u8FDB\\u884C\\u4E0B\\u4E00\\u6B65\\u7EC4\\u5408\\uFF0C\\u76F4\\u63A5\\u8FDB\\u884C\\u4E0B\\u4E00\\u8F6E\\u7EC4\\u5408\\n        \\u5F53\\u4EE5[1,3]\\u4E24\\u4E2A\\u5143\\u7D20\\u4E3A\\u5C3E\\u90E8\\u6216\\u4E2D\\u95F4\\u90E8\\u5206\\u7684\\u53EF\\u80FD\\u7EC4\\u5408\\u5C31\\u6709\\u53EF\\u80FD\\u662F\\u6B63\\u786E\\u7684\\n        \\u7ED3\\u679C\\n        [[1,1,1,1,1,1,1,1],[1,1,1,1,1,3],[1,1,1,5],[1,1,3,3],[1,1,6],[3,5]]\\n        \\u526A\\u679D\\n        \\u6392\\u5E8F\\u539F\\u6570\\u7EC4\\n        \\u5982\\u91CD\\u590D\\u95EE\\u9898\\u793A\\u4F8B\\u64CD\\u4F5C\\uFF0C\\u7FFB\\u8BD1\\u6210\\u4EE3\\u7801\\u5373\\u53EF\\n        \\u4E5F\\u8BF4\\u660E\\u4E86\\u6392\\u5E8F\\u7684\\u610F\\u4E49\\u6240\\u5728\\n        /**\\n         * @param {number[]} candidates\\n         * @param {number} target\\n         * @return {number[][]}\\n         */\\n        var combinationSum = function(candidates, target) {\\n            let n = candidates.length;\\n            let res = [];\\n            let tmpPath = [];\\n            candidates = candidates.sort((a,b) => {return a - b})\\n            let backtrack = (tmpPath,target,start) => {\\n                if(target == 0){\\n                    res.push(tmpPath);\\n                    return;\\n                }\\n                for(let i = start;i < n;i++){\\n                    if(target < candidates[i]) break;\\n                    tmpPath.push(candidates[i]);\\n                    backtrack(tmpPath.slice(),target - candidates[i],i);\\n                    tmpPath.pop();\\n                }\\n            }\\n            backtrack(tmpPath,target,0);\\n            return res;\\n        };\\n    \"};export default Combination_Sum;","map":{"version":3,"sources":["/Users/yabao/Documents/githubspace/Jutsai-Lab/src/apps/bao/baoApp/views/examples/JsLeetcode/js/Depth_First_Search/Combination_Sum.js"],"names":["Combination_Sum","id","name","refLink","level","tag","notes","jsSolution"],"mappings":"AAAA,GAAMA,CAAAA,eAAe,CAAG,CACpBC,EAAE,CAAE,MADgB,CAEpBC,IAAI,CAAE,iBAFc,CAGpBC,OAAO,CAAE,CACL,2FADK,CAEL,8DAFK,CAGL,oDAHK,CAHW,CAQpBC,KAAK,CAAE,MARa,CASpBC,GAAG,CAAE,EATe,CAUpBC,KAAK,GAVe,CAWpBC,UAAU,6oJAXU,CAAxB,CAyGA,cAAeP,CAAAA,eAAf","sourcesContent":["const Combination_Sum = {\n    id: '0035',\n    name: 'Combination_Sum', \n    refLink: [\n        'https://leetcode-cn.com/problems/combination-sum/solution/39-zu-he-zong-he-by-alexer-660/',\n        'https://www.lintcode.com/problem/combination-sum/description',\n        'https://www.jiuzhang.com/solution/combination-sum/'\n    ],\n    level: 'Easy',\n    tag: [],\n    notes: ``,\n    jsSolution: `\n        // Given a set of candidtate numbers candidates and a target number target. Find all unique combinations in candidates where the numbers sums to target.\n\n        // The same repeated number may be chosen from candidates unlimited number of times.\n        \n        // 在线评测地址: https://www.lintcode.com/problem/combination-sum/\n\n        解法一：递归回溯\n        类似题型\n        46. 全排列\n        递归代码模板\n        参看各类算法模板 - 递归一节 - Python&Java版\n        思路\n        由题可知，原数组\n        元素不重复\n        寻找一个符合条件的组合\n        且原数组的单个元素可以重复使用\n        只要结果中的子组合互不相同即可\n        求解\n        且原数组的单个元素可以重复使用\n        意味着下一个for循环中的元素选取，要从前一个元素开始，因为可以重复使用，不然如果跟着for的自增变量i走，会漏掉可能解\n        将自增变量i传递下去\n        终止条件\n        target 一一减去符合组合的元素，最终为 0 ，才是一个符合题意的组合\n        /**\n         * @param {number[]} candidates\n         * @param {number} target\n         * @return {number[][]}\n         */\n        var combinationSum = function(candidates, target) {\n            let n = candidates.length;\n            let res = [];\n            let tmpPath = [];\n            let backtrack = (tmpPath,target,start) => {\n                if(target < 0){\n                    return;\n                }\n                if(target == 0){\n                    res.push(tmpPath);\n                    return;\n                }\n                for(let i = start;i < n;i++){\n                    tmpPath.push(candidates[i]);\n                    backtrack(tmpPath.slice(),target - candidates[i],i);\n                    tmpPath.pop();\n                }\n            }\n            backtrack(tmpPath,target,0);\n            return res;\n        };\n        解法二：递归回溯 + 减枝\n        类似题型\n        47. 全排列 II - 解法二\n        重复问题\n        [1,3,5,6] target = 8\n        当tmpPath = [1,3]时\n        target = 8 - 1 - 3 = 4\n        此时 4 < 5\n        因此之后比5更大的元素也是不合题意的，对于所有组合中以[1,3]为首的组合无需再进行下一步组合，直接进行下一轮组合\n        当以[1,3]两个元素为尾部或中间部分的可能组合就有可能是正确的\n        结果\n        [[1,1,1,1,1,1,1,1],[1,1,1,1,1,3],[1,1,1,5],[1,1,3,3],[1,1,6],[3,5]]\n        剪枝\n        排序原数组\n        如重复问题示例操作，翻译成代码即可\n        也说明了排序的意义所在\n        /**\n         * @param {number[]} candidates\n         * @param {number} target\n         * @return {number[][]}\n         */\n        var combinationSum = function(candidates, target) {\n            let n = candidates.length;\n            let res = [];\n            let tmpPath = [];\n            candidates = candidates.sort((a,b) => {return a - b})\n            let backtrack = (tmpPath,target,start) => {\n                if(target == 0){\n                    res.push(tmpPath);\n                    return;\n                }\n                for(let i = start;i < n;i++){\n                    if(target < candidates[i]) break;\n                    tmpPath.push(candidates[i]);\n                    backtrack(tmpPath.slice(),target - candidates[i],i);\n                    tmpPath.pop();\n                }\n            }\n            backtrack(tmpPath,target,0);\n            return res;\n        };\n    `\n}\n\nexport default Combination_Sum\n"]},"metadata":{},"sourceType":"module"}