{"ast":null,"code":"var Maximum_Depth_of_Binary_Tree={id:'0017',name:'Maximum_Depth_of_Binary_Tree',refLink:['https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/solution/104-er-cha-shu-de-zui-da-shen-du-by-alexer-660/','https://www.lintcode.com/problem/maximum-depth-of-binary-tree/description','https://www.jiuzhang.com/solution/maximum-depth-of-binary-tree/#tag-other'],level:'Easy',tag:[],notes:\"\",jsSolution:\"\\n        // Given a binary tree, find its maximum depth.\\n\\n        // The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\\n        \\n        // \\u5728\\u7EBF\\u8BC4\\u6D4B\\u5730\\u5740: https://www.lintcode.com/problem/maximum-depth-of-binary-tree/\\n\\n\\n        \\u89E3\\u6CD5\\u4E00\\uFF1A\\u9012\\u5F52 DFS\\n        \\u8282\\u70B9\\u7684\\u9AD8\\u5EA6 = Max(\\u5DE6\\u5B50\\u6811\\u7684\\u9AD8\\u5EA6\\uFF0C\\u53F3\\u5B50\\u6811\\u7684\\u9AD8\\u5EA6) + 1\\n        \\u4EE5\\u6B64\\u7C7B\\u63A8\\uFF0C\\u6700\\u540E\\u4E00\\u4E2A\\u5DE6\\u6216\\u53F3\\u8282\\u70B9\\u9AD8\\u5EA6\\u4E3A0 \\u518D\\u53CD\\u8FC7\\u6765\\u76F8\\u52A0\\u56DE\\u53BB\\u5373\\u53EF\\n        \\u65F6\\u95F4\\u590D\\u6742\\u5EA6\\uFF1AO(n)\\n        \\u7A7A\\u95F4\\u590D\\u6742\\u5EA6\\n        \\u6700\\u574F\\u60C5\\u51B5\\u4E0B O(n) \\u9000\\u5316\\u4E3A\\u5355\\u94FE\\u8868\\n        \\u6700\\u597D\\u60C5\\u51B5\\u4E0B O(logn) \\u4E3A\\u5E73\\u8861\\u4E8C\\u53C9\\u6811\\u4E14\\u9AD8\\u5EA6\\u4E3Alogn\\n        /**\\n         * Definition for a binary tree node.\\n         * function TreeNode(val) {\\n         *     this.val = val;\\n         *     this.left = this.right = null;\\n         * }\\n         */\\n        /**\\n         * @param {TreeNode} root\\n         * @return {number}\\n         */\\n        var maxDepth = function(root) {\\n            function getDepth(root,leftSubtreeDepth,rightSubtreeDepth){\\n                if(root != null){\\n                    leftSubtreeDepth = getDepth(root.left);\\n                    rightSubtreeDepth = getDepth(root.right);\\n                    return Math.max(leftSubtreeDepth,rightSubtreeDepth) + 1;   \\n                }else{\\n                    return 0;\\n                }\\n            }\\n            return getDepth(root);\\n        };\\n\\n        \\u89E3\\u6CD5\\u4E8C\\uFF1A\\u961F\\u5217 BFS\\n        \\u5E7F\\u5EA6\\u4F18\\u5148\\u904D\\u5386 BFS\\n        \\u6B64\\u5904\\u5373\\u4E8C\\u53C9\\u6811\\u7684\\u5C42\\u6B21(\\u5E8F)\\u904D\\u5386\\n        \\u6C42\\u6700\\u5927\\u6DF1\\u5EA6 \\u4EA6\\u5373 \\u6C42\\u4E8C\\u53C9\\u6811\\u6709\\u51E0\\u5C42\\n        \\u5E7F\\u5EA6\\u4F18\\u5148\\u4EE3\\u7801\\n        \\u7279\\u70B9\\uFF1A\\\"\\u4ECE\\u5DE6\\u5230\\u53F3\\uFF0C\\u4ECE\\u4E0A\\u5230\\u4E0B\\\"\\n        \\u961F\\u5217\\n        \\u7279\\u70B9\\uFF1A\\\"\\u5148\\u8FDB\\u5148\\u51FA\\\"\\n        \\u961F\\u5217\\u5B9E\\u73B0\\u5E7F\\u5EA6\\u4F18\\u5148\\n        \\u904D\\u5386\\u4E8C\\u53C9\\u6811\\u8282\\u70B9\\uFF0C\\u4F9D\\u6B21\\u5C06\\u5F53\\u524D\\u8282\\u70B9 \\u548C\\u5B83\\u7684\\u5DE6\\u53F3\\u5B50\\u8282\\u70B9\\u5165\\u961F\\uFF0C\\u5E76\\u518D\\u4E00\\u4E00\\u51FA\\u961F\\n        \\u9488\\u5BF9\\u5B50\\u8282\\u70B9\\u7684\\u8282\\u70B9\\u91CD\\u590D\\u4E0A\\u4E00\\u6B65\\u64CD\\u4F5C\\n        \\u521A\\u597D\\u7B26\\u5408\\\"\\u5148\\u8FDB\\u5148\\u51FA\\\" => \\\"\\u5148\\u5165\\u961F\\u518D\\u51FA\\u961F\\\"\\n        \\u6570\\u7EC4\\uFF1Apush -> shift\\n        \\u6240\\u4EE5\\u4E8C\\u53C9\\u6811\\u7684\\u5E7F\\u5EA6\\u4F18\\u5148\\u5373\\u5C42\\u5E8F\\u904D\\u5386\\u7528\\u961F\\u5217\\u5B9E\\u73B0\\u4E3A\\n        /**\\n         * Definition for a binary tree node.\\n         * function TreeNode(val) {\\n         *     this.val = val;\\n         *     this.left = this.right = null;\\n         * }\\n         */\\n        /**\\n         * @param {TreeNode} root\\n         * @return {number}\\n         */\\n        var maxDepth = function(root) {\\n            if(root == null){\\n                return 0;\\n            }\\n            var tmpQueue = [root];\\n            var result = [];\\n            var currNode = null;\\n            while(tmpQueue.length != 0){ --------------------------(1)\\n                currNode = tmpQueue.shift();\\n                result.push(currNode);\\n                if(node.left != null){\\n                    tmpQueue.push(node.left);\\n                }\\n                if(node.right != null){\\n                    tmpQueue.push(node.right);\\n                }\\n            }\\n            return result;\\n        };\\n    \"};export default Maximum_Depth_of_Binary_Tree;","map":{"version":3,"sources":["/Users/yabao/Documents/githubspace/Jutsai-Lab/src/apps/bao/baoApp/views/examples/JsLeetcode/js/Binary_Tree_Divide_Conquer/Maximum_Depth_of_Binary_Tree.js"],"names":["Maximum_Depth_of_Binary_Tree","id","name","refLink","level","tag","notes","jsSolution"],"mappings":"AAAA,GAAMA,CAAAA,4BAA4B,CAAG,CACjCC,EAAE,CAAE,MAD6B,CAEjCC,IAAI,CAAE,8BAF2B,CAGjCC,OAAO,CAAE,CACL,wHADK,CAEL,2EAFK,CAGL,2EAHK,CAHwB,CAQjCC,KAAK,CAAE,MAR0B,CASjCC,GAAG,CAAE,EAT4B,CAUjCC,KAAK,GAV4B,CAWjCC,UAAU,uuHAXuB,CAArC,CAiGA,cAAeP,CAAAA,4BAAf","sourcesContent":["const Maximum_Depth_of_Binary_Tree = {\n    id: '0017',\n    name: 'Maximum_Depth_of_Binary_Tree',\n    refLink: [\n        'https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/solution/104-er-cha-shu-de-zui-da-shen-du-by-alexer-660/',\n        'https://www.lintcode.com/problem/maximum-depth-of-binary-tree/description',\n        'https://www.jiuzhang.com/solution/maximum-depth-of-binary-tree/#tag-other'\n    ],\n    level: 'Easy',\n    tag: [],\n    notes: ``,\n    jsSolution: `\n        // Given a binary tree, find its maximum depth.\n\n        // The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\n        \n        // 在线评测地址: https://www.lintcode.com/problem/maximum-depth-of-binary-tree/\n\n\n        解法一：递归 DFS\n        节点的高度 = Max(左子树的高度，右子树的高度) + 1\n        以此类推，最后一个左或右节点高度为0 再反过来相加回去即可\n        时间复杂度：O(n)\n        空间复杂度\n        最坏情况下 O(n) 退化为单链表\n        最好情况下 O(logn) 为平衡二叉树且高度为logn\n        /**\n         * Definition for a binary tree node.\n         * function TreeNode(val) {\n         *     this.val = val;\n         *     this.left = this.right = null;\n         * }\n         */\n        /**\n         * @param {TreeNode} root\n         * @return {number}\n         */\n        var maxDepth = function(root) {\n            function getDepth(root,leftSubtreeDepth,rightSubtreeDepth){\n                if(root != null){\n                    leftSubtreeDepth = getDepth(root.left);\n                    rightSubtreeDepth = getDepth(root.right);\n                    return Math.max(leftSubtreeDepth,rightSubtreeDepth) + 1;   \n                }else{\n                    return 0;\n                }\n            }\n            return getDepth(root);\n        };\n\n        解法二：队列 BFS\n        广度优先遍历 BFS\n        此处即二叉树的层次(序)遍历\n        求最大深度 亦即 求二叉树有几层\n        广度优先代码\n        特点：\"从左到右，从上到下\"\n        队列\n        特点：\"先进先出\"\n        队列实现广度优先\n        遍历二叉树节点，依次将当前节点 和它的左右子节点入队，并再一一出队\n        针对子节点的节点重复上一步操作\n        刚好符合\"先进先出\" => \"先入队再出队\"\n        数组：push -> shift\n        所以二叉树的广度优先即层序遍历用队列实现为\n        /**\n         * Definition for a binary tree node.\n         * function TreeNode(val) {\n         *     this.val = val;\n         *     this.left = this.right = null;\n         * }\n         */\n        /**\n         * @param {TreeNode} root\n         * @return {number}\n         */\n        var maxDepth = function(root) {\n            if(root == null){\n                return 0;\n            }\n            var tmpQueue = [root];\n            var result = [];\n            var currNode = null;\n            while(tmpQueue.length != 0){ --------------------------(1)\n                currNode = tmpQueue.shift();\n                result.push(currNode);\n                if(node.left != null){\n                    tmpQueue.push(node.left);\n                }\n                if(node.right != null){\n                    tmpQueue.push(node.right);\n                }\n            }\n            return result;\n        };\n    `\n}\n\nexport default Maximum_Depth_of_Binary_Tree\n"]},"metadata":{},"sourceType":"module"}