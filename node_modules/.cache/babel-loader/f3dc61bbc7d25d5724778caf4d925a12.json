{"ast":null,"code":"const N_Queens = {\n  id: '0039',\n  name: 'N_Queens',\n  refLink: ['https://www.lintcode.com/problem/n-queens/description', 'https://www.jiuzhang.com/solution/n-queens/', 'https://leetcode-cn.com/problems/n-queens/solution/jian-ji-de-javascript-dfs-ti-jie-dai-zhu-shi-by-_t/'],\n  level: 'Hard',\n  tag: [],\n  notes: ``,\n  jsSolution: `\n        // The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other(Any two queens can't be in the same row, column, diagonal line).\n\n        // Given an integer n, return all distinct solutions to the n-queens puzzle.\n        \n        // Each solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' each indicate a queen and an empty space respectively.\n        \n        // 在线评测地址: https://www.lintcode.com/problem/n-queens/\n\n        var solveNQueens = function(n) {\n            let res = []\n            dfs(n, [], res)\n            return res\n          }\n          \n          /**\n           * 递归计算 N 皇后的解\n           * @param {number} n\n           * @param {number[]} tmp 长度为 n 的数组，tmp[i] 代表第 i 行的皇后放置的位置\n           * @param {string[]} res\n           */\n          function dfs(n, tmp, res) {\n            // 如果 tmp 长度为 n，代表所有皇后放置完毕\n            if (tmp.length === n) {\n              // 把这种解记录下来\n              res.push(\n                tmp.map(i => {\n                  let strArr = Array(n).fill('.')\n                  strArr.splice(i, 1, 'Q')\n                  return strArr.join('')\n                })\n              )\n              return\n            }\n            // 每次有 n 个选择，该次放置在第几列\n            for (let j = 0; j < n; j++) {\n              // 如果当前列满足条件\n              if (isValid(tmp, j)) {\n                // 记录当前选择\n                tmp.push(j)\n                // 继续下一次的递归\n                dfs(n, tmp, res)\n                // 撤销当前选择\n                tmp.pop()\n              }\n            }\n          }\n          \n          function isValid(tmp, j) {\n            let i = tmp.length\n            for (let x = 0; x < i; x++) {\n              let y = tmp[x]\n              if (y === j || x - y === i - j || x + y === i + j) {\n                return false\n              }\n            }\n            return true\n          }\n    `\n};\nexport default N_Queens;","map":{"version":3,"sources":["/Users/yabao/Documents/githubspace/Jutsai-Lab/src/apps/bao/baoApp/views/examples/JsLeetcode/js/Depth_First_Search/N_Queens.js"],"names":["N_Queens","id","name","refLink","level","tag","notes","jsSolution"],"mappings":"AAAA,MAAMA,QAAQ,GAAG;AACbC,EAAAA,EAAE,EAAE,MADS;AAEbC,EAAAA,IAAI,EAAE,UAFO;AAGbC,EAAAA,OAAO,EAAE,CACL,uDADK,EAEL,6CAFK,EAGL,wGAHK,CAHI;AAQbC,EAAAA,KAAK,EAAE,MARM;AASbC,EAAAA,GAAG,EAAE,EATQ;AAUbC,EAAAA,KAAK,EAAG,EAVK;AAWbC,EAAAA,UAAU,EAAG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAXA,CAAjB;AAwEA,eAAeP,QAAf","sourcesContent":["const N_Queens = {\n    id: '0039',\n    name: 'N_Queens',\n    refLink: [\n        'https://www.lintcode.com/problem/n-queens/description',\n        'https://www.jiuzhang.com/solution/n-queens/',\n        'https://leetcode-cn.com/problems/n-queens/solution/jian-ji-de-javascript-dfs-ti-jie-dai-zhu-shi-by-_t/'\n    ],\n    level: 'Hard',\n    tag: [],\n    notes: ``,\n    jsSolution: `\n        // The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other(Any two queens can't be in the same row, column, diagonal line).\n\n        // Given an integer n, return all distinct solutions to the n-queens puzzle.\n        \n        // Each solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' each indicate a queen and an empty space respectively.\n        \n        // 在线评测地址: https://www.lintcode.com/problem/n-queens/\n\n        var solveNQueens = function(n) {\n            let res = []\n            dfs(n, [], res)\n            return res\n          }\n          \n          /**\n           * 递归计算 N 皇后的解\n           * @param {number} n\n           * @param {number[]} tmp 长度为 n 的数组，tmp[i] 代表第 i 行的皇后放置的位置\n           * @param {string[]} res\n           */\n          function dfs(n, tmp, res) {\n            // 如果 tmp 长度为 n，代表所有皇后放置完毕\n            if (tmp.length === n) {\n              // 把这种解记录下来\n              res.push(\n                tmp.map(i => {\n                  let strArr = Array(n).fill('.')\n                  strArr.splice(i, 1, 'Q')\n                  return strArr.join('')\n                })\n              )\n              return\n            }\n            // 每次有 n 个选择，该次放置在第几列\n            for (let j = 0; j < n; j++) {\n              // 如果当前列满足条件\n              if (isValid(tmp, j)) {\n                // 记录当前选择\n                tmp.push(j)\n                // 继续下一次的递归\n                dfs(n, tmp, res)\n                // 撤销当前选择\n                tmp.pop()\n              }\n            }\n          }\n          \n          function isValid(tmp, j) {\n            let i = tmp.length\n            for (let x = 0; x < i; x++) {\n              let y = tmp[x]\n              if (y === j || x - y === i - j || x + y === i + j) {\n                return false\n              }\n            }\n            return true\n          }\n    `\n}\n\nexport default N_Queens\n"]},"metadata":{},"sourceType":"module"}