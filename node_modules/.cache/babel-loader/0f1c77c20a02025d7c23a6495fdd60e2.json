{"ast":null,"code":"const Balanced_Binary_Tree = {\n  id: '0020',\n  name: 'Balanced_Binary_Tree',\n  refLink: ['https://leetcode-cn.com/problems/balanced-binary-tree/solution/di-gui-pan-duan-ping-heng-er-cha-shu-by-zhu-zhu-xi/', 'https://www.lintcode.com/problem/balanced-binary-tree/description', 'https://www.jiuzhang.com/solution/balanced-binary-tree/'],\n  level: 'Easy',\n  tag: [],\n  notes: ``,\n  jsSolution: `\n        // Given a binary tree, determine if it is height-balanced.\n\n        // For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.\n        \n        // 在线评测地址: https://www.lintcode.com/problem/balanced-binary-tree/\n\n        /**\n         * @param {TreeNode} root\n         * @return {boolean}\n         */\n        var isBalanced = function(root) {\n            // 遍历到底还没有发现高度差超过 1 的左右子树，那么这个子树肯定符合平衡二叉树的规范\n            if (!root) {\n                return true\n            }\n            // 判断左右子树的高度差，如果超过 1 那么立即返回 false\n            if (Math.abs(getHeight(root.left) - getHeight(root.right)) > 1) {\n                return false\n            }\n            // 分别递归左右子树\n            return isBalanced(root.left) && isBalanced(root.right)\n            // 获取某个子树的高度\n            function getHeight (root) {\n                if (!root) {\n                    return 0\n                }\n                return Math.max(getHeight(root.left), getHeight(root.right)) + 1\n            }\n        };\n    `\n};\nexport default Balanced_Binary_Tree;","map":{"version":3,"sources":["/Users/yabao/Documents/githubspace/Jutsai-Lab/src/apps/bao/baoApp/views/examples/JsLeetcode/js/Binary_Tree_Divide_Conquer/Balanced_Binary_Tree.js"],"names":["Balanced_Binary_Tree","id","name","refLink","level","tag","notes","jsSolution"],"mappings":"AAAA,MAAMA,oBAAoB,GAAG;AACzBC,EAAAA,EAAE,EAAE,MADqB;AAEzBC,EAAAA,IAAI,EAAE,sBAFmB;AAGzBC,EAAAA,OAAO,EAAE,CACL,oHADK,EAEL,mEAFK,EAGL,yDAHK,CAHgB;AAQzBC,EAAAA,KAAK,EAAE,MARkB;AASzBC,EAAAA,GAAG,EAAE,EAToB;AAUzBC,EAAAA,KAAK,EAAG,EAViB;AAWzBC,EAAAA,UAAU,EAAG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAXY,CAA7B;AA4CA,eAAeP,oBAAf","sourcesContent":["const Balanced_Binary_Tree = {\n    id: '0020',\n    name: 'Balanced_Binary_Tree',\n    refLink: [\n        'https://leetcode-cn.com/problems/balanced-binary-tree/solution/di-gui-pan-duan-ping-heng-er-cha-shu-by-zhu-zhu-xi/',\n        'https://www.lintcode.com/problem/balanced-binary-tree/description',\n        'https://www.jiuzhang.com/solution/balanced-binary-tree/'\n    ],\n    level: 'Easy',\n    tag: [],\n    notes: ``,\n    jsSolution: `\n        // Given a binary tree, determine if it is height-balanced.\n\n        // For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.\n        \n        // 在线评测地址: https://www.lintcode.com/problem/balanced-binary-tree/\n\n        /**\n         * @param {TreeNode} root\n         * @return {boolean}\n         */\n        var isBalanced = function(root) {\n            // 遍历到底还没有发现高度差超过 1 的左右子树，那么这个子树肯定符合平衡二叉树的规范\n            if (!root) {\n                return true\n            }\n            // 判断左右子树的高度差，如果超过 1 那么立即返回 false\n            if (Math.abs(getHeight(root.left) - getHeight(root.right)) > 1) {\n                return false\n            }\n            // 分别递归左右子树\n            return isBalanced(root.left) && isBalanced(root.right)\n            // 获取某个子树的高度\n            function getHeight (root) {\n                if (!root) {\n                    return 0\n                }\n                return Math.max(getHeight(root.left), getHeight(root.right)) + 1\n            }\n        };\n    `\n}\n\nexport default Balanced_Binary_Tree\n"]},"metadata":{},"sourceType":"module"}