{"ast":null,"code":"const Search_in_a_Big_Sorted_Array = {\n  id: '0012',\n  name: 'Search_in_a_Big_Sorted_Array',\n  refLink: ['https://www.lintcode.com/problem/search-in-a-big-sorted-array/', 'https://www.lintcode.com/problem/search-in-a-big-sorted-array/description'],\n  level: 'Easy',\n  tag: ['Binary Search'],\n  notes: `JAVA`,\n  jsSolution: `\n        // Given a big sorted array with non-negative integers sorted by non-decreasing order. \n        // The array is so big so that you can not get the length of the whole array directly, \n        // and you can only access the kth number by ArrayReader.get(k) (or ArrayReader->get(k) for C++).\n\n        // Find the first index of a target number. \n        // Your algorithm should be in O(log k), where k is the first index of the target number.\n        \n        // Return -1, if the number doesn't exist in the array.\n        \n        // 在线评测地址: https://www.lintcode.com/problem/search-in-a-big-sorted-array/\n\n        public class Solution {\n            /*\n             * @param reader: An instance of ArrayReader.\n             * @param target: An integer\n             * @return: An integer which is the first index of target.\n             */\n            public int searchBigSortedArray(ArrayReader reader, int target) {\n                int firstElement = reader.get(0);\n                if (firstElement == target) \n                    return 0;\n                else if (firstElement > target)\n                    return -1;\n                \n                int idx = 0, jump = 1;\n                while (jump != 0) {\n                    while (jump != 0 && reader.get(idx + jump) >= target)   // 越界时返回INT_MAX, 必然不小于target\n                        jump >>= 1;\n                    idx += jump;\n                    jump <<= 1;     // 当jump为0时, 左移一位不影响它的值, 不影响循环结束\n                }\n                \n                if (reader.get(idx + 1) == target)\n                    return idx + 1;\n                else\n                    return -1;\n            }\n        }\n        \n        /////////////// 方法2 二分\n        \n        /**\n         * Definition of ArrayReader:\n         * \n         * public class ArrayReader {\n         * public int get(int index) {\n         *          // return the number on given index, \n         *          // return 2147483647 if the index is invalid.\n         *     }\n         * };\n         */\n        public class Solution {\n            /*\n             * @param reader: An instance of ArrayReader.\n             * @param target: An integer\n             * @return: An integer which is the first index of target.\n             */\n            public int searchBigSortedArray(ArrayReader reader, int target) {\n                int l = 0, r = 1, mid;\n                while (reader.get(r) < target)     // 越界返回INT_MAX, 必然大于target, 所以没有关系\n                    r <<= 1;\n                \n                while (l < r) {\n                    mid = (l + r) >> 1;\n                    if (reader.get(mid) >= target)\n                        r = mid;\n                    else\n                        l = mid + 1;\n                }\n                \n                if (reader.get(l) == target)\n                    return l;\n                else\n                    return -1;\n            }\n        }\n    `\n};\nexport default Search_in_a_Big_Sorted_Array;","map":{"version":3,"sources":["/Users/yabao/Documents/githubspace/Jutsai-Lab/src/apps/bao/baoApp/views/examples/JsLeetcode/js/Binary_Search/Search_in_a_Big_Sorted_Array.js"],"names":["Search_in_a_Big_Sorted_Array","id","name","refLink","level","tag","notes","jsSolution"],"mappings":"AAAA,MAAMA,4BAA4B,GAAG;AACjCC,EAAAA,EAAE,EAAE,MAD6B;AAEjCC,EAAAA,IAAI,EAAE,8BAF2B;AAGjCC,EAAAA,OAAO,EAAE,CACL,gEADK,EAEL,2EAFK,CAHwB;AAOjCC,EAAAA,KAAK,EAAE,MAP0B;AAQjCC,EAAAA,GAAG,EAAE,CACD,eADC,CAR4B;AAWjCC,EAAAA,KAAK,EAAG,MAXyB;AAYjCC,EAAAA,UAAU,EAAG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAZoB,CAArC;AA4FA,eAAeP,4BAAf","sourcesContent":["const Search_in_a_Big_Sorted_Array = {\n    id: '0012',\n    name: 'Search_in_a_Big_Sorted_Array',\n    refLink: [\n        'https://www.lintcode.com/problem/search-in-a-big-sorted-array/',\n        'https://www.lintcode.com/problem/search-in-a-big-sorted-array/description',\n    ],\n    level: 'Easy',\n    tag: [\n        'Binary Search',\n    ],\n    notes: `JAVA`,\n    jsSolution: `\n        // Given a big sorted array with non-negative integers sorted by non-decreasing order. \n        // The array is so big so that you can not get the length of the whole array directly, \n        // and you can only access the kth number by ArrayReader.get(k) (or ArrayReader->get(k) for C++).\n\n        // Find the first index of a target number. \n        // Your algorithm should be in O(log k), where k is the first index of the target number.\n        \n        // Return -1, if the number doesn't exist in the array.\n        \n        // 在线评测地址: https://www.lintcode.com/problem/search-in-a-big-sorted-array/\n\n        public class Solution {\n            /*\n             * @param reader: An instance of ArrayReader.\n             * @param target: An integer\n             * @return: An integer which is the first index of target.\n             */\n            public int searchBigSortedArray(ArrayReader reader, int target) {\n                int firstElement = reader.get(0);\n                if (firstElement == target) \n                    return 0;\n                else if (firstElement > target)\n                    return -1;\n                \n                int idx = 0, jump = 1;\n                while (jump != 0) {\n                    while (jump != 0 && reader.get(idx + jump) >= target)   // 越界时返回INT_MAX, 必然不小于target\n                        jump >>= 1;\n                    idx += jump;\n                    jump <<= 1;     // 当jump为0时, 左移一位不影响它的值, 不影响循环结束\n                }\n                \n                if (reader.get(idx + 1) == target)\n                    return idx + 1;\n                else\n                    return -1;\n            }\n        }\n        \n        /////////////// 方法2 二分\n        \n        /**\n         * Definition of ArrayReader:\n         * \n         * public class ArrayReader {\n         * public int get(int index) {\n         *          // return the number on given index, \n         *          // return 2147483647 if the index is invalid.\n         *     }\n         * };\n         */\n        public class Solution {\n            /*\n             * @param reader: An instance of ArrayReader.\n             * @param target: An integer\n             * @return: An integer which is the first index of target.\n             */\n            public int searchBigSortedArray(ArrayReader reader, int target) {\n                int l = 0, r = 1, mid;\n                while (reader.get(r) < target)     // 越界返回INT_MAX, 必然大于target, 所以没有关系\n                    r <<= 1;\n                \n                while (l < r) {\n                    mid = (l + r) >> 1;\n                    if (reader.get(mid) >= target)\n                        r = mid;\n                    else\n                        l = mid + 1;\n                }\n                \n                if (reader.get(l) == target)\n                    return l;\n                else\n                    return -1;\n            }\n        }\n    `,\n}\n\nexport default Search_in_a_Big_Sorted_Array"]},"metadata":{},"sourceType":"module"}