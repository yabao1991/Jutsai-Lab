{"ast":null,"code":"var Clone_Graph={id:'0029',name:'Clone_Graph',refLink:['https://www.lintcode.com/problem/clone-graph/description','https://www.jiuzhang.com/solution/clone-graph/','https://leetcode-cn.com/problems/clone-graph/solution/jsshen-du-bian-li-jian-ji-ban-ben-by-armin/'],level:'Medium',tag:[''],notes:\"JAVA only\",jsSolution:\"\\n        // Clone an undirected graph. Each node in the graph contains a label and a list of its neighbors. Nodes are labeled uniquely.\\n\\n        // You need to return a deep copied graph, which has the same structure as the original graph, and any changes to the new graph will not have any effect on the original graph.\\n        \\n        // \\u5728\\u7EBF\\u8BC4\\u6D4B\\u5730\\u5740: https://www.lintcode.com/problem/clone-graph/\\n\\n\\n        \\u4ECE\\u539F\\u56FE\\u7ED9\\u5B9A\\u7684\\u70B9\\u627E\\u5230\\u6240\\u6709\\u70B9\\n        \\u590D\\u5236\\u6240\\u6709\\u7684\\u70B9\\n        \\u590D\\u5236\\u6240\\u6709\\u7684\\u8FB9\\n        /**\\n        * \\u672C\\u53C2\\u8003\\u7A0B\\u5E8F\\u6765\\u81EA\\u4E5D\\u7AE0\\u7B97\\u6CD5\\uFF0C\\u7531 @ \\u63D0\\u4F9B\\u3002\\u7248\\u6743\\u6240\\u6709\\uFF0C\\u8F6C\\u53D1\\u8BF7\\u6CE8\\u660E\\u51FA\\u5904\\u3002\\n        * - \\u4E5D\\u7AE0\\u7B97\\u6CD5\\u81F4\\u529B\\u4E8E\\u5E2E\\u52A9\\u66F4\\u591A\\u4E2D\\u56FD\\u4EBA\\u627E\\u5230\\u597D\\u7684\\u5DE5\\u4F5C\\uFF0C\\u6559\\u5E08\\u56E2\\u961F\\u5747\\u6765\\u81EA\\u7845\\u8C37\\u548C\\u56FD\\u5185\\u7684\\u4E00\\u7EBF\\u5927\\u516C\\u53F8\\u5728\\u804C\\u5DE5\\u7A0B\\u5E08\\u3002\\n        * - \\u73B0\\u6709\\u7684\\u9762\\u8BD5\\u57F9\\u8BAD\\u8BFE\\u7A0B\\u5305\\u62EC\\uFF1A\\u4E5D\\u7AE0\\u7B97\\u6CD5\\u73ED\\uFF0C\\u7CFB\\u7EDF\\u8BBE\\u8BA1\\u73ED\\uFF0C\\u7B97\\u6CD5\\u5F3A\\u5316\\u73ED\\uFF0CJava\\u5165\\u95E8\\u4E0E\\u57FA\\u7840\\u7B97\\u6CD5\\u73ED\\uFF0CAndroid \\u9879\\u76EE\\u5B9E\\u6218\\u73ED\\uFF0C\\n        * - Big Data \\u9879\\u76EE\\u5B9E\\u6218\\u73ED\\uFF0C\\u7B97\\u6CD5\\u9762\\u8BD5\\u9AD8\\u9891\\u9898\\u73ED, \\u52A8\\u6001\\u89C4\\u5212\\u4E13\\u9898\\u73ED\\n        * - \\u66F4\\u591A\\u8BE6\\u60C5\\u8BF7\\u89C1\\u5B98\\u65B9\\u7F51\\u7AD9\\uFF1Ahttp://www.jiuzhang.com/?source=code\\n        */ \\n\\n        /**\\n         * Definition for undirected graph.\\n         * class UndirectedGraphNode {\\n         *     int label;\\n         *     ArrayList<UndirectedGraphNode> neighbors;\\n         *     UndirectedGraphNode(int x) { label = x; neighbors = new ArrayList<UndirectedGraphNode>(); }\\n         * };\\n         */\\n        public class Solution {\\n            /**\\n             * @param node: A undirected graph node\\n             * @return: A undirected graph node\\n             */\\n            public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) {\\n                if (node == null) {\\n                    return node;\\n                }\\n\\n                // use bfs algorithm to traverse the graph and get all nodes.\\n                ArrayList<UndirectedGraphNode> nodes = getNodes(node);\\n\\n                // copy nodes, store the old->new mapping information in a hash map\\n                HashMap<UndirectedGraphNode, UndirectedGraphNode> mapping = new HashMap<>();\\n                for (UndirectedGraphNode n : nodes) {\\n                    mapping.put(n, new UndirectedGraphNode(n.label));\\n                }\\n\\n                // copy neighbors(edges)\\n                for (UndirectedGraphNode n : nodes) {\\n                    UndirectedGraphNode newNode = mapping.get(n);\\n                    for (UndirectedGraphNode neighbor : n.neighbors) {\\n                        UndirectedGraphNode newNeighbor = mapping.get(neighbor);\\n                        newNode.neighbors.add(newNeighbor);\\n                    }\\n                }\\n\\n                return mapping.get(node);\\n            }\\n\\n            private ArrayList<UndirectedGraphNode> getNodes(UndirectedGraphNode node) {\\n                Queue<UndirectedGraphNode> queue = new LinkedList<UndirectedGraphNode>();\\n                HashSet<UndirectedGraphNode> set = new HashSet<>();\\n\\n                queue.offer(node);\\n                set.add(node);\\n                while (!queue.isEmpty()) {\\n                    UndirectedGraphNode head = queue.poll();\\n                    for (UndirectedGraphNode neighbor : head.neighbors) {\\n                        if (!set.contains(neighbor)) {\\n                            set.add(neighbor);\\n                            queue.offer(neighbor);\\n                        }\\n                    }\\n                }\\n\\n                return new ArrayList<UndirectedGraphNode>(set);\\n            }\\n        }\\n    \"};export default Clone_Graph;","map":{"version":3,"sources":["/Users/yabao/Documents/githubspace/Jutsai-Lab/src/apps/bao/baoApp/views/examples/JsLeetcode/js/Breadth_First_Search/Clone_Graph.js"],"names":["Clone_Graph","id","name","refLink","level","tag","notes","jsSolution"],"mappings":"AAAA,GAAMA,CAAAA,WAAW,CAAG,CAChBC,EAAE,CAAE,MADY,CAEhBC,IAAI,CAAE,aAFU,CAGhBC,OAAO,CAAE,CACL,0DADK,CAEL,gDAFK,CAGL,mGAHK,CAHO,CAQhBC,KAAK,CAAE,QARS,CAShBC,GAAG,CAAE,CACD,EADC,CATW,CAYhBC,KAAK,YAZW,CAahBC,UAAU,uhIAbM,CAApB,CA6FA,cAAeP,CAAAA,WAAf","sourcesContent":["const Clone_Graph = {\n    id: '0029',\n    name: 'Clone_Graph',\n    refLink: [\n        'https://www.lintcode.com/problem/clone-graph/description',\n        'https://www.jiuzhang.com/solution/clone-graph/',\n        'https://leetcode-cn.com/problems/clone-graph/solution/jsshen-du-bian-li-jian-ji-ban-ben-by-armin/'\n    ],\n    level: 'Medium',\n    tag: [\n        ''\n    ],\n    notes: `JAVA only`,\n    jsSolution: `\n        // Clone an undirected graph. Each node in the graph contains a label and a list of its neighbors. Nodes are labeled uniquely.\n\n        // You need to return a deep copied graph, which has the same structure as the original graph, and any changes to the new graph will not have any effect on the original graph.\n        \n        // 在线评测地址: https://www.lintcode.com/problem/clone-graph/\n\n\n        从原图给定的点找到所有点\n        复制所有的点\n        复制所有的边\n        /**\n        * 本参考程序来自九章算法，由 @ 提供。版权所有，转发请注明出处。\n        * - 九章算法致力于帮助更多中国人找到好的工作，教师团队均来自硅谷和国内的一线大公司在职工程师。\n        * - 现有的面试培训课程包括：九章算法班，系统设计班，算法强化班，Java入门与基础算法班，Android 项目实战班，\n        * - Big Data 项目实战班，算法面试高频题班, 动态规划专题班\n        * - 更多详情请见官方网站：http://www.jiuzhang.com/?source=code\n        */ \n\n        /**\n         * Definition for undirected graph.\n         * class UndirectedGraphNode {\n         *     int label;\n         *     ArrayList<UndirectedGraphNode> neighbors;\n         *     UndirectedGraphNode(int x) { label = x; neighbors = new ArrayList<UndirectedGraphNode>(); }\n         * };\n         */\n        public class Solution {\n            /**\n             * @param node: A undirected graph node\n             * @return: A undirected graph node\n             */\n            public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) {\n                if (node == null) {\n                    return node;\n                }\n\n                // use bfs algorithm to traverse the graph and get all nodes.\n                ArrayList<UndirectedGraphNode> nodes = getNodes(node);\n\n                // copy nodes, store the old->new mapping information in a hash map\n                HashMap<UndirectedGraphNode, UndirectedGraphNode> mapping = new HashMap<>();\n                for (UndirectedGraphNode n : nodes) {\n                    mapping.put(n, new UndirectedGraphNode(n.label));\n                }\n\n                // copy neighbors(edges)\n                for (UndirectedGraphNode n : nodes) {\n                    UndirectedGraphNode newNode = mapping.get(n);\n                    for (UndirectedGraphNode neighbor : n.neighbors) {\n                        UndirectedGraphNode newNeighbor = mapping.get(neighbor);\n                        newNode.neighbors.add(newNeighbor);\n                    }\n                }\n\n                return mapping.get(node);\n            }\n\n            private ArrayList<UndirectedGraphNode> getNodes(UndirectedGraphNode node) {\n                Queue<UndirectedGraphNode> queue = new LinkedList<UndirectedGraphNode>();\n                HashSet<UndirectedGraphNode> set = new HashSet<>();\n\n                queue.offer(node);\n                set.add(node);\n                while (!queue.isEmpty()) {\n                    UndirectedGraphNode head = queue.poll();\n                    for (UndirectedGraphNode neighbor : head.neighbors) {\n                        if (!set.contains(neighbor)) {\n                            set.add(neighbor);\n                            queue.offer(neighbor);\n                        }\n                    }\n                }\n\n                return new ArrayList<UndirectedGraphNode>(set);\n            }\n        }\n    `\n}\n\nexport default Clone_Graph\n"]},"metadata":{},"sourceType":"module"}