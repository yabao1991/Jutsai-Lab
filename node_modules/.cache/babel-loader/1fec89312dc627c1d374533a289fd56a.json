{"ast":null,"code":"var Topological_Sorting={id:'0031',name:'Topological_Sorting',refLink:['https://www.jiuzhang.com/solution/topological-sorting/#tag-highlight','https://www.lintcode.com/problem/topological-sorting/description'],level:'Medium',tag:['JAVA'],notes:\"JAVA only\",jsSolution:\"\\n        // Given an directed graph, a topological order of the graph nodes is defined as follow:\\n\\n        // For each directed edge A -> B in graph, A must before B in the order list.\\n        // The first node in the order can be any node in the graph with no nodes direct to it.\\n        // Find any topological order for the given graph.\\n        \\n        // \\u5728\\u7EBF\\u8BC4\\u6D4B\\u5730\\u5740: https://www.lintcode.com/problem/topological-sorting/\\n\\n\\n        public class Solution {\\n            /**\\n             * @param graph: A list of Directed graph node\\n             * @return: Any topological order for the given graph.\\n             */    \\n            public ArrayList<DirectedGraphNode> topSort(ArrayList<DirectedGraphNode> graph) {\\n                // write your code here\\n                ArrayList<DirectedGraphNode> result = new ArrayList<DirectedGraphNode>();\\n                HashMap<DirectedGraphNode, Integer> map = new HashMap();\\n                for (DirectedGraphNode node : graph) {\\n                    for (DirectedGraphNode neighbor : node.neighbors) {\\n                        if (map.containsKey(neighbor)) {\\n                            map.put(neighbor, map.get(neighbor) + 1);\\n                        } else {\\n                            map.put(neighbor, 1); \\n                        }\\n                    }\\n                }\\n                Queue<DirectedGraphNode> q = new LinkedList<DirectedGraphNode>();\\n                for (DirectedGraphNode node : graph) {\\n                    if (!map.containsKey(node)) {\\n                        q.offer(node);\\n                        result.add(node);\\n                    }\\n                }\\n                while (!q.isEmpty()) {\\n                    DirectedGraphNode node = q.poll();\\n                    for (DirectedGraphNode n : node.neighbors) {\\n                        map.put(n, map.get(n) - 1);\\n                        if (map.get(n) == 0) {\\n                            result.add(n);\\n                            q.offer(n);\\n                        }\\n                    }\\n                }\\n                return result;\\n            }\\n        }\\n    \"};export default Topological_Sorting;","map":{"version":3,"sources":["/Users/yabao/Documents/githubspace/Jutsai-Lab/src/apps/bao/baoApp/views/examples/JsLeetcode/js/Breadth_First_Search/Topological_Sorting.js"],"names":["Topological_Sorting","id","name","refLink","level","tag","notes","jsSolution"],"mappings":"AAAA,GAAMA,CAAAA,mBAAmB,CAAG,CACxBC,EAAE,CAAE,MADoB,CAExBC,IAAI,CAAE,qBAFkB,CAGxBC,OAAO,CAAE,CACL,sEADK,CAEL,kEAFK,CAHe,CAOxBC,KAAK,CAAE,QAPiB,CAQxBC,GAAG,CAAE,CACD,MADC,CARmB,CAWxBC,KAAK,YAXmB,CAYxBC,UAAU,8nEAZc,CAA5B,CA+DA,cAAeP,CAAAA,mBAAf","sourcesContent":["const Topological_Sorting = {\n    id: '0031',\n    name: 'Topological_Sorting',\n    refLink: [\n        'https://www.jiuzhang.com/solution/topological-sorting/#tag-highlight',\n        'https://www.lintcode.com/problem/topological-sorting/description'\n    ],\n    level: 'Medium',\n    tag: [\n        'JAVA'\n    ],\n    notes: `JAVA only`,\n    jsSolution: `\n        // Given an directed graph, a topological order of the graph nodes is defined as follow:\n\n        // For each directed edge A -> B in graph, A must before B in the order list.\n        // The first node in the order can be any node in the graph with no nodes direct to it.\n        // Find any topological order for the given graph.\n        \n        // 在线评测地址: https://www.lintcode.com/problem/topological-sorting/\n\n\n        public class Solution {\n            /**\n             * @param graph: A list of Directed graph node\n             * @return: Any topological order for the given graph.\n             */    \n            public ArrayList<DirectedGraphNode> topSort(ArrayList<DirectedGraphNode> graph) {\n                // write your code here\n                ArrayList<DirectedGraphNode> result = new ArrayList<DirectedGraphNode>();\n                HashMap<DirectedGraphNode, Integer> map = new HashMap();\n                for (DirectedGraphNode node : graph) {\n                    for (DirectedGraphNode neighbor : node.neighbors) {\n                        if (map.containsKey(neighbor)) {\n                            map.put(neighbor, map.get(neighbor) + 1);\n                        } else {\n                            map.put(neighbor, 1); \n                        }\n                    }\n                }\n                Queue<DirectedGraphNode> q = new LinkedList<DirectedGraphNode>();\n                for (DirectedGraphNode node : graph) {\n                    if (!map.containsKey(node)) {\n                        q.offer(node);\n                        result.add(node);\n                    }\n                }\n                while (!q.isEmpty()) {\n                    DirectedGraphNode node = q.poll();\n                    for (DirectedGraphNode n : node.neighbors) {\n                        map.put(n, map.get(n) - 1);\n                        if (map.get(n) == 0) {\n                            result.add(n);\n                            q.offer(n);\n                        }\n                    }\n                }\n                return result;\n            }\n        }\n    `\n}\n\nexport default Topological_Sorting\n"]},"metadata":{},"sourceType":"module"}