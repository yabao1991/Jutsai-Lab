{"ast":null,"code":"var Word_Ladder={id:'0040',name:'Word_Ladder',refLink:['https://www.jiuzhang.com/solution/word-ladder/#tag-other-lang-javascript','https://www.lintcode.com/problem/word-ladder/description','https://leetcode-cn.com/problems/word-ladder/solution/127-dan-ci-jie-long-by-alexer-660/'],level:'Medium',tag:[],notes:\"\",jsSolution:\"\\n        // Given two words (start and end), and a dictionary, find the shortest transformation sequence from start to end, output the length of the sequence.\\n        // Transformation rule such that:\\n        \\n        // Only one letter can be changed at a time\\n        // Each intermediate word must exist in the dictionary. (Start and end words do not need to appear in the dictionary )\\n        // \\u5728\\u7EBF\\u8BC4\\u6D4B\\u5730\\u5740: https://www.lintcode.com/problem/word-ladder/\\n\\n        var ladderLength = function(beginWord, endWord, wordList) {\\n            let queue = [beginWord];\\n            let visitedMap  = {};\\n            let count = 0;\\n            while(queue.length != 0){\\n                count ++;\\n                const length = queue.length;\\n                for(let i = 0; i < length; i ++){\\n                    let node = queue.pop();\\n                    if(node == endWord){\\n                        return count;\\n                    }\\n                    const nextList = findNext(node, wordList, visitedMap);\\n                    for(let j = 0; j < nextList.length; j ++){\\n                        if(nextList[j] == endWord){\\n                            return count + 1;\\n                        }\\n                        visitedMap[nextList[j]] = true;\\n                        queue.unshift(nextList[j]);\\n                    }\\n                }\\n            }\\n            return 0;\\n        };\\n        function findNext(word, arr, visitedMap){\\n            let result = [];\\n            for(let i = 0;i < arr.length; i ++){\\n                let ele = arr[i];\\n                if(visitedMap[ele]){\\n                    continue;\\n                }\\n                let diff = 0;\\n                for(let j = 0;j < word.length; j ++){\\n                    if(word.charAt(j) != ele.charAt(j)){\\n                        diff ++;\\n                    }\\n                }\\n                if(diff == 1){\\n                    result.push(ele);\\n                }\\n            }\\n            return result;\\n        }\\n\\n        \\u89E3\\u6CD5\\u4E00\\uFF1ABFS\\n        \\u65F6\\u95F4\\u590D\\u6742\\u5EA6\\uFF1AO(M * N) ,M\\u4E3A\\u5355\\u8BCD\\u957F\\u5EA6\\uFF0C,N\\u4E3A\\u5355\\u8BCD\\u5217\\u8868\\u957F\\u5EA6\\n        \\u7A7A\\u95F4\\u590D\\u6742\\u5EA6\\uFF1AO(M * N) ,M\\u957F\\u5EA6\\u7684\\u5355\\u8BCD\\u5316\\u4E3A\\u90BB\\u63A5\\u5355\\u8BCD\\u5F62\\u5F0F\\u65F6\\u9700\\u8981M\\uFF0CN\\u540C\\u4E0A\\n        \\u7528\\u5E7F\\u5EA6\\u4F18\\u5148\\u641C\\u7D22\\u641C\\u7D22\\u4ECEbeginWord\\u5230endWord\\u7684\\u6700\\u77ED\\u8DEF\\u5F84\\u95EE\\u9898\\n        \\u601D\\u8DEF\\u5206\\u6790\\n        \\u4E00\\u4E2A\\u6700\\u77ED\\u8F6C\\u6362\\u5E8F\\u5217\\u662F \\\"hit\\\" -> \\\"hot\\\" -> \\\"dot\\\" -> \\\"dog\\\" -> \\\"cog\\\",\\n\\n        \\u4ECE\\u8D77\\u70B9\\\"hit\\\"\\u53D8\\u6362\\u5230\\u7EC8\\u70B9\\\"cog\\\"\\n        \\u6BCF\\u6B21\\u53D8\\u6362\\n        \\u53EA\\u80FD\\u53D8\\u52A8\\u5176\\u4E2D\\u4E00\\u4E2A\\u5355\\u8BCD\\n        \\u4E14\\u5FC5\\u987B\\u5728\\u5B57\\u5178\\u4E2D\\n        \\u56E0\\u6B64\\u6BCF\\u6B21\\u53D8\\u6362\\uFF0C\\u5176\\u5B9E\\u5C31\\u662F\\u8D70\\u4E86\\u4E00\\u6B65\\n        \\u6BCF\\u6B21\\u53D8\\u6362\\u524D\\u540E\\u7684\\u5355\\u8BCD\\u5DEE\\u5F02\\u53EA\\u6709\\u5176\\u4E2D\\u4E00\\u4E2A\\u5B57\\u7B26\\n        \\u8BBE\\u552F\\u4E00\\u4E0D\\u540C\\u7684\\u5B57\\u7B26\\u4E3A*\\n        \\\"hit\\\" -> \\\"hot\\\" -> \\\"dot\\\" -> \\\"dog\\\" -> \\\"cog\\\"\\n\\n        hit ----> h*t <-----hot\\n        dot ----> *ot <-----hot\\n        dot ----> do* <-----dog\\n        dog ----> *og <-----cog\\n        \\u6211\\u4EEC\\u628A\\u76F8\\u5DEE\\u552F\\u4E00\\u4E00\\u4E2A\\u5B57\\u7B26\\u7684\\u4E24\\u4E2A\\u5355\\u8BCD\\u79F0\\u4E3A\\u90BB\\u63A5\\u5355\\u8BCD\\n        \\u56E0\\u6B64 \\u5355\\u8BCD'xyz'\\u7684\\u6240\\u6709\\u90BB\\u63A5\\u5355\\u8BCD\\u4E3A\\n        '*yz'\\n        'x*z'\\n        'xy*'\\n        \\u56E0\\u4E3A\\u5355\\u8BCD\\u7684\\u4E0B\\u4E00\\u4E2A\\u53D8\\u6362\\u5355\\u8BCD\\u5373\\u662F\\u90BB\\u63A5\\u5355\\u8BCD\\n        \\u4F8B\\u5982\\u6211\\u4EEC\\u8981\\u4ECE'hit'\\u53D8\\u6362\\u5230'hot'\\n        hit\\u7684\\u90BB\\u63A5\\u5355\\u8BCD\\u5F62\\u5F0F\\u6709\\n        *it\\n        h*t\\n        hi*\\n        hot\\u7684\\u90BB\\u63A5\\u5355\\u8BCD\\u5F62\\u5F0F\\u6709\\n        *ot\\n        h*t\\n        ho*\\n        \\u6211\\u4EEC\\u5BFB\\u627E\\u4ED6\\u4EEC\\u76F8\\u540C\\u7684\\u90BB\\u63A5\\u5355\\u8BCD\\u5F62\\u5F0F\\n        \\u4E3Ah*t\\n        \\u53CD\\u8FC7\\u6765\\n        \\u7B26\\u5408h*t\\u5F62\\u5F0F\\u7684\\u5355\\u8BCD\\u6709\\n        hit\\n        hot\\n        \\u56E0\\u6B64\\u5728\\u4EE3\\u7801\\u4E2D\\uFF0C\\u6B64\\u5904\\u4FBF\\u662F\\u5BFB\\u627E\\u4E0B\\u4E00\\u90BB\\u63A5\\u5355\\u8BCD\\u7684\\u5173\\u952E\\u903B\\u8F91\\n        \\u4EE3\\u7801\\u903B\\u8F91\\n        \\u6C42\\u51FAwordList\\u4E2D\\u7684\\u6240\\u6709\\u5355\\u8BCD\\u7684\\u6240\\u6709\\u90BB\\u63A5\\u5355\\u8BCD\\u5F62\\u5F0F\\n        \\u5C06\\u5177\\u6709\\u76F8\\u540C\\u90BB\\u63A5\\u5355\\u8BCD\\u5F62\\u5F0F\\u7684\\u5355\\u8BCD\\u653E\\u5728\\u4E00\\u4E2A\\u96C6\\u5408\\u91CC\\n        \\u5F62\\u5982 hash[\\u90BB\\u63A5\\u5355\\u8BCD\\u5F62\\u5F0F] = [\\u5355\\u8BCD1,\\u5355\\u8BCD2,...,\\u5355\\u8BCDn]\\n        \\u5F53\\u6211\\u4EEC\\u5728\\u5BFB\\u627E\\u4E0B\\u4E00\\u4E2A\\u90BB\\u63A5\\u5355\\u8BCD\\u662F\\u8C01\\u65F6\\uFF0C\\u6211\\u4EEC\\u901A\\u8FC7\\u6C42\\u5F53\\u524D\\u5355\\u8BCD\\u7684\\u90BB\\u63A5\\u5355\\u8BCD\\u7684\\u5F62\\u5F0F\\uFF0C\\u53BB\\u679A\\u4E3E\\u4E0A\\u4E00\\u6B65\\u7684\\u6240\\u6709\\u90BB\\u63A5\\u5355\\u8BCD\\u5F62\\u5F0F\\u7684\\u96C6\\u5408\\n        \\u5B58\\u5728\\u5219\\u5728\\u90BB\\u63A5\\u5355\\u8BCD\\u5F62\\u5F0F\\u5BF9\\u5E94\\u7684\\u5355\\u8BCD\\u96C6\\u5408\\u91CC\\uFF0C\\u904D\\u5386\\u5BFB\\u627E\\u7B26\\u5408\\u7684\\u76EE\\u6807\\u5355\\u8BCD\\n        \\u627E\\u5230\\uFF0C\\u5219\\u8FD4\\u56DE\\n        \\u6CA1\\u627E\\u5230\\uFF0C\\u5F53\\u524D\\u5BFB\\u5740\\u6B65\\u6570++\\uFF0C\\u7EE7\\u7EED\\u5BFB\\u5740\\n        \\u6211\\u4EEC\\u5C06\\u4ECE\\u8D77\\u70B9 beginWord --> endWord \\u7684\\u5BFB\\u5740\\u8DEF\\u7EBF\\uFF0C\\u62BD\\u8C61\\u4E3A\\u961F\\u5217\\n        \\u521D\\u59CB\\u503C\\u662F\\u8D77\\u70B9\\uFF0C\\u5165\\u961F\\n        \\u51FA\\u961F\\uFF0C\\u901A\\u8FC7\\u90BB\\u63A5\\u5355\\u8BCD\\u5F62\\u5F0F\\u53D8\\u6362\\u5BFB\\u5740\\uFF0C\\u903B\\u8F91\\u5982\\u4E0A\\n        \\u6838\\u5FC3\\u903B\\u8F91\\u5728\\u7B2C\\u4E00\\u6B65\\n        \\u89E3\\u9898\\u6280\\u5DE7\\n        \\u6BCF\\u4E2A\\u90BB\\u63A5\\u5355\\u8BCD\\u5F62\\u5F0F\\u5BF9\\u5E94\\u7684\\u5355\\u8BCD\\u65E2\\u6709\\u53EF\\u80FD\\u76F8\\u540C\\uFF0C\\u4F1A\\u51FA\\u73B0\\u5FAA\\u73AF\\u5BFB\\u5740\\u5373\\u73AF\\u7684\\u5F62\\u5F0F\\n        \\u4F8B\\u5982 h*t -> hot\\u3001*ot -> hot\\n        \\u56E0\\u6B64\\u7EF4\\u62A4\\u4E00\\u4E2A\\u8BBF\\u95EE\\u8BB0\\u5F55\\u6570\\u7EC4\\uFF0C\\u8BBF\\u95EE\\u6BD4\\u8F83\\u8FC7\\u7684\\u5355\\u8BCD\\uFF0C\\u4E0B\\u6B21\\u4E0D\\u518D\\u8BBF\\u95EE\\n        /**\\n         * @param {string} beginWord\\n         * @param {string} endWord\\n         * @param {string[]} wordList\\n         * @return {number}\\n         */\\n        var ladderLength = function(beginWord, endWord, wordList) {\\n            if(!endWord || wordList.indexOf(endWord) == -1){\\n                return 0;\\n            }\\n            // \\u5404\\u4E2A\\u901A\\u7528\\u72B6\\u6001\\u5BF9\\u5E94\\u6240\\u6709\\u5355\\u8BCD\\n            var comboDicts = {};\\n            var len = beginWord.length;\\n            for(var i = 0;i<wordList.length;i++){\\n                for(var r = 0;r<len;r++){\\n                    var newWord = wordList[i].substring(0,r)+'*'+wordList[i].substring(r+1,len);\\n                    (!comboDicts[newWord]) && (comboDicts[newWord] = []);\\n                    comboDicts[newWord].push(wordList[i]);\\n                }\\n            }\\n            // Queue for BFS\\n            var queue = [[beginWord,1]];\\n            // visited\\n            var visited = {beginWord:true};\\n            while(queue.length > 0){\\n                var currNode = queue.shift();\\n                var currWord = currNode[0];\\n                var currLevel = currNode[1];\\n                for(var i = 0;i < len;i++){\\n                    // \\u901A\\u7528\\u72B6\\u6001\\n                    var newWord = currWord.substring(0,i)+'*'+currWord.substring(i+1,len);\\n                    if(newWord in comboDicts){\\n                        var tmpWords = comboDicts[newWord];\\n                        for(var z = 0;z<tmpWords.length;z++){\\n                            if(tmpWords[z] == endWord){\\n                                return currLevel + 1;\\n                            }\\n                            if(!visited[tmpWords[z]]){\\n                                visited[tmpWords[z]] = true;\\n                                queue.push([tmpWords[z],currLevel+1]);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            return 0;\\n        };\\n        \\u89E3\\u6CD5\\u4E8C\\uFF1ADFS\\n        \\u601D\\u8DEF\\u540C433. \\u6700\\u5C0F\\u57FA\\u56E0\\u53D8\\u5316-\\u89E3\\u6CD5\\u4E09\\n        \\u8FD9\\u4E2A\\u65B9\\u6CD5\\u4F1A\\u8D85\\u65F6\\n        /**\\n         * @param {string} beginWord\\n         * @param {string} endWord\\n         * @param {string[]} wordList\\n         * @return {number}\\n         */\\n        var ladderLength = function(beginWord, endWord, wordList) {\\n            if(!endWord || wordList.indexOf(endWord) == -1){\\n                return 0;\\n            }\\n            var visited = {};\\n            var minLevel = Number.MAX_SAFE_INTEGER;\\n            var level = 1;\\n            function recurse(beginWord,level){\\n                if(beginWord == endWord){\\n                    minLevel = Math.min(minLevel,level);\\n                }\\n                for(var i = 0;i<wordList.length;i++){\\n                    var tmpWord = wordList[i];\\n                    var diff = 0;\\n                    for(var r = 0;r<tmpWord.length;r++){\\n                        if(beginWord[r] != tmpWord[r]){\\n                            diff++;\\n                            if(diff > 1){\\n                                break;\\n                            }\\n                        }\\n                    }\\n                    if(diff == 1 && !visited[tmpWord]){\\n                        visited[tmpWord] = true;\\n                        recurse(tmpWord,level+1);\\n                        visited[tmpWord] = false;\\n                    }\\n                }\\n            }\\n            recurse(beginWord,level);\\n            return (minLevel ^ Number.MAX_SAFE_INTEGER) == 0 ? 0 : minLevel;\\n        };\\n        \\u89E3\\u6CD5\\u4E09\\uFF1A\\u53CC\\u7AEFBFS\\n        \\u65F6\\u95F4\\u590D\\u6742\\u5EA6\\uFF1AO(M*N)\\n        \\u7A7A\\u95F4\\u590D\\u6742\\u5EA6\\uFF1AO(M*N)\\n        \\u6838\\u5FC3\\u601D\\u60F3\\u662F\\u89E3\\u6CD5\\u4E00\\n        \\u7C7B\\u4F3C\\u53CC\\u6307\\u9488\\u7684\\u601D\\u60F3\\n        \\u540C\\u65F6\\u4ECE\\u5934\\u5C3E\\u4E24\\u4E2A\\u90E8\\u5206\\u641C\\u7D22\\u904D\\u5386\\n        \\u641C\\u7D22\\u7EC8\\u6B62\\u6761\\u4EF6\\u4E3A\\n        \\u4E00\\u4E2A\\u8282\\u70B9\\u88AB\\u4E24\\u4E2A\\u4EBA\\u641C\\u7D22\\u8FC7\\n        \\u7C7B\\u4F3C\\u76F8\\u9047\\u95EE\\u9898\\n        /**\\n         * @param {string} beginWord\\n         * @param {string} endWord\\n         * @param {string[]} wordList\\n         * @return {number}\\n         */\\n        var ladderLength = function(beginWord, endWord, wordList) {\\n            if(!endWord || wordList.indexOf(endWord) == -1){\\n                return 0;\\n            }\\n            // \\u5404\\u4E2A\\u901A\\u7528\\u72B6\\u6001\\u5BF9\\u5E94\\u6240\\u6709\\u5355\\u8BCD\\n            var comboDicts = {};\\n            var len = beginWord.length;\\n            for(var i = 0;i<wordList.length;i++){\\n                for(var r = 0;r<len;r++){\\n                    var newWord = wordList[i].substring(0,r)+'*'+wordList[i].substring(r+1,len);\\n                    (!comboDicts[newWord]) && (comboDicts[newWord] = []);\\n                    comboDicts[newWord].push(wordList[i]);\\n                }\\n            }\\n            \\n            function visitWord(currQueue,currVisited,othersVisited){\\n                var currNode = currQueue.shift();\\n                var currWord = currNode[0];\\n                var currLevel = currNode[1];\\n                for(var i = 0;i < len;i++){\\n                    // \\u901A\\u7528\\u72B6\\u6001\\n                    var newWord = currWord.substring(0,i)+'*'+currWord.substring(i+1,len);\\n                    if(newWord in comboDicts){\\n                        var tmpWords = comboDicts[newWord];\\n                        for(var z = 0;z<tmpWords.length;z++){\\n                            if(othersVisited[tmpWords[z]] != undefined){\\n                                return currLevel + othersVisited[tmpWords[z]];\\n                            }\\n                            if(currVisited[tmpWords[z]] == undefined){\\n                                currVisited[tmpWords[z]] = currLevel + 1;\\n                                currQueue.push([tmpWords[z],currLevel+1]);\\n                            }\\n                        }\\n                    }\\n                }\\n                return -1;\\n            }\\n            \\n            // Queue for BFS from beginWord\\n            var queueBegin = [[beginWord,1]];\\n            // Queue for BFS from endWord\\n            var queueEnd  = [[endWord,1]];\\n            // visited begin and end\\n            var visitedBegin = {};\\n            visitedBegin[beginWord] = 1;\\n            var visitedEnd = {};\\n            visitedEnd[endWord] = 1;\\n            while(queueBegin.length > 0 && queueEnd.length > 0){\\n                // fromBegin\\n                var ans = visitWord(queueBegin,visitedBegin,visitedEnd);\\n                if(ans > -1){\\n                    return ans;\\n                }\\n                // formEnd\\n                ans = visitWord(queueEnd,visitedEnd,visitedBegin);\\n                if(ans > -1){\\n                    return ans;\\n                }\\n            }\\n            return 0;\\n        };\\n        \\u89E3\\u6CD5\\u56DB\\uFF1ABFS-2\\n        \\u601D\\u8DEF\\u540C433. \\u6700\\u5C0F\\u57FA\\u56E0\\u53D8\\u5316-\\u89E3\\u6CD5\\u4E00\\n        /**\\n         * @param {string} beginWord\\n         * @param {string} endWord\\n         * @param {string[]} wordList\\n         * @return {number}\\n         */\\n        var ladderLength = function(beginWord, endWord, wordList) {\\n            if(!endWord || wordList.indexOf(endWord) == -1){\\n                return 0;\\n            }\\n            var wordListHash = {};\\n            for(var i = 0;i<wordList.length;i++){\\n                wordListHash[wordList[i]] = true;\\n            }\\n            var genes = 'abcdefghigklmnopqrstuvwxyz';\\n            var level = 0;\\n            var queue = [[beginWord,1]];\\n            while(queue.length != 0){\\n                var curr = queue.pop();\\n                level = curr[1]\\n                if(curr[0] == endWord){\\n                    return level;\\n                }\\n                var arrCurr = curr[0];\\n                for(var i = 0;i<arrCurr.length;i++){\\n                    for(var r = 0;r<genes.length;r++){\\n                        if(genes[r] != arrCurr[i]){\\n                            var strCurr = (arrCurr.slice(0,i))+genes[r]+(arrCurr.slice(i+1));\\n                            if(wordListHash[strCurr]){\\n                                queue.unshift([strCurr,level+1]);\\n                                wordListHash[strCurr] = false;\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            return 0;\\n        };\\n        \\u6216\\u8005\\u8FD9\\u6837\\u5199\\u4E5F\\u53EF\\n        /**\\n        * @param {string} beginWord\\n        * @param {string} endWord\\n        * @param {string[]} wordList\\n        * @return {number}\\n        */\\n        var ladderLength = function(beginWord, endWord, wordList) {\\n            let comboDicts = new Set(wordList);\\n            if(!comboDicts.has(endWord)){\\n                return 0;\\n            }\\n            let level = 0;\\n            let queue = [[beginWord,1]];\\n            while(queue.length != 0){\\n                let currNode = queue.pop();\\n                let currLeter = currNode[0];\\n                level = currNode[1];\\n                if(currNode[0] == endWord){\\n                    return level;\\n                }\\n                for(let i = 0;i < currLeter.length;i++){\\n                    for(r = 0;r < 26;r++){\\n                        let genTmp = String.fromCharCode(97+r);\\n                        if( genTmp != currLeter[i]){\\n                            let str = currLeter.slice(0,i)+genTmp+currLeter.slice(i+1);\\n                            if(comboDicts.has(str)){\\n                                queue.unshift([str,level+1]);\\n                                comboDicts.delete(str);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            return 0;\\n        }; \\n        \\u89E3\\u6CD5\\u4E94\\uFF1A\\u53CC\\u7AEFBFS\\u5347\\u7EA7\\u7248\\n        \\u6B64\\u89E3\\u6CD5\\u65F6\\u95F4\\u590D\\u6742\\u5EA6\\u6BD4\\u4EE5\\u4E0A\\u66F4\\u4F4E\\n        \\u89E3\\u6CD5\\u4E00\\u548C\\u89E3\\u6CD5\\u4E8C\\u5171\\u540C\\u7684\\u6838\\u5FC3\\u601D\\u60F3\\n        \\u7528\\u90BB\\u63A5\\u5355\\u8BCD\\u5F62\\u5F0F\\u3010yz\\u3001xz\\u3001xy*\\u3011\\u4F5C\\u4E3A\\u952E\\n        \\u7528\\u7B26\\u5408\\u90BB\\u63A5\\u5355\\u8BCD\\u5F62\\u5F0F\\u7684\\u5355\\u8BCD\\u4F5C\\u4E3A\\u503C\\n        \\u5BFB\\u5740\\u5171\\u540C\\u7684\\u90BB\\u63A5\\u5355\\u8BCD\\u5F62\\u5F0F\\u4E3A\\u524D\\u63D0\\uFF0C\\u904D\\u5386\\u5BF9\\u5E94\\u7684\\u503C\\n        \\u627E\\u5230\\u8FD4\\u56DE\\u524D\\u4E00\\u6B65\\u6B65\\u6570\\u52A01\\n        \\u6CA1\\u627E\\u5230\\u7EE7\\u7EED\\u904D\\u5386\\n        \\u6B64\\u89E3\\u6CD5\\u7684\\u6838\\u5FC3\\u601D\\u60F3\\n        \\u501F\\u7528\\u4E86433. \\u6700\\u5C0F\\u57FA\\u56E0\\u53D8\\u5316-\\u89E3\\u6CD5\\u4E00 \\u7684\\u601D\\u8DEF\\n        \\u901A\\u8FC7\\u76F4\\u63A5\\u91CD\\u65B0\\u7EC4\\u5408\\u4E0A\\u4E00\\u6B65\\u5355\\u8BCD\\n        \\u4E0B\\u4E00\\u6B65\\u53D8\\u6362\\u4E3A\\u53EF\\u80FD\\u4E14\\u7B26\\u5408\\u6761\\u4EF6\\u7684\\u5355\\u8BCD\\uFF0C\\u5728\\u5176\\u4E2D\\u904D\\u5386\\u5BFB\\u627E\\n        \\u627E\\u5230\\u8FD4\\u56DE...\\n        \\u6CA1\\u627E\\u5230\\u6B65\\u6570++\\uFF0C\\u7EE7\\u7EED\\u904D\\u5386\\n        \\u5355\\u7AEF\\u4EA6\\u53EF\\u4EE5\\u7528\\u6B64\\u601D\\u8DEF\\n        \\u53CC\\u7AEF\\u5219\\u9700\\u8981\\u52A0\\u4E0A\\u672C\\u9898\\u89E3\\u6CD5\\u4E09\\u7684\\u601D\\u8DEF\\n        \\u5408\\u5E76\\u4E24\\u9053\\u9898\\u89E3\\u7684\\u601D\\u8DEF\\u5373\\u4E3A\\u5982\\u4E0B\\u89E3\\u6CD5\\n        /**\\n         * @param {string} beginWord\\n         * @param {string} endWord\\n         * @param {string[]} wordList\\n         * @return {number}\\n         */\\n        var ladderLength = function(beginWord, endWord, wordList) {\\n            var comboDicts = new Set(wordList);\\n            if(!comboDicts.has(endWord)){\\n                return 0;\\n            }\\n            var len = beginWord.length;\\n            \\n            function gens(word){\\n                var result = [];\\n                var len = word.length;\\n                for(var i = 0;i<len;i++){\\n                    for(var j = 0;j < 26;j++){\\n                        var newWord = word.substring(0,i)+String.fromCharCode(j+97)+word.substring(i+1);\\n                        if(comboDicts.has(newWord) && newWord != word){\\n                            result.push(newWord);\\n                        }\\n                    }\\n                }\\n                return result;\\n            }\\n            \\n            function visitWord(currQueue,currVisited,othersVisited){\\n                var currNode = currQueue.shift();\\n                var tmpWords = gens(currNode[0]);\\n                var currLevel = currNode[1];\\n                var tmpLen = tmpWords.length;\\n                for(var i = 0;i< tmpLen;i++){\\n                    if(othersVisited[tmpWords[i]] != undefined){\\n                        return currLevel + othersVisited[tmpWords[i]];\\n                    }\\n                    if(currVisited[tmpWords[i]] == undefined){\\n                        currVisited[tmpWords[i]] = currLevel + 1;\\n                        currQueue.push([tmpWords[i],currLevel + 1])\\n                    }\\n                } \\n                return -1;\\n            }\\n            \\n            // Queue for BFS from beginWord\\n            var queueBegin = [[beginWord,1]];\\n            // Queue for BFS from endWord\\n            var queueEnd  = [[endWord,1]];\\n            // visited begin and end\\n            var visitedBegin = {};\\n            visitedBegin[beginWord] = 1;\\n            var visitedEnd = {};\\n            visitedEnd[endWord] = 1;\\n            while(queueBegin.length > 0 && queueEnd.length > 0){\\n                // fromBegin\\n                var ans = visitWord(queueBegin,visitedBegin,visitedEnd);\\n                if(ans > -1){\\n                    return ans;\\n                }\\n                // formEnd\\n                ans = visitWord(queueEnd,visitedEnd,visitedBegin);\\n                if(ans > -1){\\n                    return ans;\\n                }\\n            }\\n            return 0;\\n        };\\n        \\u89E3\\u6CD5\\u516D\\uFF1A\\u53CC\\u7AEFBFS\\u5F3A\\u5316\\u7248\\n        \\u5176\\u5B9E\\u662F\\u89E3\\u6CD5\\u56DB\\uFF1ABFS-2 \\u7B2C\\u4E8C\\u79CD\\u5199\\u6CD5\\u7684\\u53E6\\u7C7B\\u7248\\n        \\u5C06queue\\u6362\\u6210set\\n        Set \\u5BF9\\u8C61\\u641C\\u7D22\\u3001\\u5220\\u9664\\u3001\\u63D2\\u5165\\u65F6\\u95F4\\u590D\\u6742\\u5EA6\\u4E3AO(1)\\n        beginSet\\u3001endSet\\u5404\\u81EA\\u5411\\u4E00\\u8FB9\\u6269\\u6563\\n        visited\\uFF1A\\u8282\\u70B9\\u662F\\u5426\\u5DF2\\u7ECF\\u8BBF\\u95EE\\u8FC7\\n        BFS\\n        beginSet\\u3001endSet\\u76F8\\u5F53\\u4E8E\\u4E24\\u4E2Aqueue\\n        \\u6269\\u6563\\u8FC7\\u7A0B\\u4E2D\\uFF0C\\u4F18\\u5148\\u9009\\u62E9\\u5C0F\\u7684set\\n        \\u4EA4\\u6362set\\n        \\u56E0\\u4E0A\\u9762\\u4F5C\\u4E86\\u4EA4\\u6362\\uFF0C\\u6BCF\\u6B21\\u53EA\\u9700\\u4ECEbeginSet\\u5F00\\u59CB\\u6269\\u6563\\u5373\\u53EF\\n        \\u5B9A\\u4E49\\u4E00\\u4E2Atemp Set\\n        \\u76F8\\u5F53\\u4E8E\\u5411queue\\u4E0D\\u65AD\\u52A0\\u5165\\u6269\\u6563\\u4E2D\\u88AB\\u9009\\u4E2D\\u7684\\u5143\\u7D20\\n        \\u56E0\\u6B64\\u4E00\\u8F6E\\u904D\\u5386\\u5B8C\\uFF0C\\u76F4\\u63A5\\u5C06beginSet\\u66FF\\u6362\\u4E3Atemp\\u5373\\u53EF\\n        \\u6BCF\\u6B21\\u904D\\u5386\\u5230\\u4E00\\u4E2A\\u5355\\u8BCD\\n        \\u904D\\u5386\\u5355\\u8BCD\\u7684\\u6BCF\\u4E2A\\u5B57\\u7B26\\uFF0C\\u5E76\\u5C1D\\u8BD5\\u66FF\\u6362\\u4E3A\\u4E0E\\u5F53\\u524D\\u4E0D\\u76F8\\u540C\\u7684\\u5176\\u4F5925\\u4E2A\\u5B57\\u7B26\\n        \\u5982\\u679C\\u4ECE\\u5C3E\\u90E8\\u6269\\u6563\\u51FA\\u7684endSet\\u6709\\u4E86\\u65B0\\u7EC4\\u5408\\u7684\\u5355\\u8BCD\\n        \\u8BF4\\u660E\\u9996\\u5C3E\\u76F8\\u9047\\uFF0C\\u76F4\\u63A5\\u8FD4\\u56DE\\u5F53\\u524Dlevel+1\\u5373\\u53EF\\n        \\u5426\\u5219\\uFF0C\\u5982\\u679C\\u65B0\\u7EC4\\u5408\\u5355\\u8BCD\\u672A\\u5728\\u8BBF\\u95EE\\u5907\\u5FD8\\u5F55visited\\u4E2D\\u51FA\\u73B0\\uFF0C\\u4E14\\u51FA\\u73B0\\u5728\\u5355\\u8BCD\\u5E93wordList\\u4E2D\\u65F6\\n        \\u52A0\\u5165tempSet\\uFF0C\\u7528\\u4E8E\\u4E0B\\u4E00\\u8F6E\\u6269\\u6563\\u5355\\u8BCD\\u904D\\u5386\\u7EC4\\u5408\\u64CD\\u4F5C\\n        \\u5E76\\u4E14\\u52A0\\u5165\\u5907\\u5FD8\\u5F55visited\\n        \\u7EE7\\u7EED\\u4E0B\\u4E00\\u8F6Equeue temp set\\u904D\\u5386\\n        /**\\n         * @param {string} beginWord\\n         * @param {string} endWord\\n         * @param {string[]} wordList\\n         * @return {number}\\n         */\\n        let ladderLength = function(beginWord, endWord, wordList) {\\n            let wordListSet = new Set(wordList);\\n            if(!wordListSet.has(endWord)){\\n                return 0;\\n            }\\n            let beginSet = new Set();\\n            beginSet.add(beginWord);\\n            let endSet = new Set();\\n            endSet.add(endWord)\\n            let visited = new Set();\\n            let level = 1;\\n            // BFS\\n            while (beginSet.size > 0 && endSet.size > 0) {\\n                if(beginSet.size > endSet.size){\\n                    let tmp = beginSet;\\n                    beginSet = endSet;\\n                    endSet = tmp;\\n                }\\n                let temp = new Set();\\n                for(let key of beginSet){\\n                    for(let i = 0;i < key.length;i++){\\n                        for(let j = 0;j < 26;j++){\\n                        let tmp = key.slice(0,i)+String.fromCharCode(97+j)+key.slice(i+1);\\n                        if(endSet.has(tmp)){\\n                            return level + 1;\\n                        }\\n                        if(!visited.has(tmp) && wordListSet.has(tmp)){\\n                                temp.add(tmp);\\n                                visited.add(tmp);\\n                        }\\n                        }\\n                    }\\n                }\\n                beginSet = temp;\\n                level++;\\n            }\\n            return 0;\\n        }\\n        \\u89E3\\u6CD5\\u4E03\\uFF1A\\u53CC\\u7AEFBFS\\u7EC8\\u6781\\u7248\\n        \\u5C06\\u89E3\\u6CD5\\u516D\\u7684visited\\u53BB\\u6389\\uFF0C\\u76F4\\u63A5\\u64CD\\u4F5C\\u539F\\u6570\\u7EC4\\n        \\u5E76\\u5BF9\\u90E8\\u5206\\u53D8\\u91CF\\u547D\\u540D\\u4F5C\\u4E86\\u8BED\\u4E49\\u5316\\u5904\\u7406\\uFF0C\\u66F4\\u5BB9\\u6613\\u7406\\u89E3\\n        \\u6B64\\u89E3\\u6CD5\\u662F\\u6240\\u6709\\u89E3\\u6CD5\\u4E2D\\u6700\\u5FEB\\u7684\\n        /**\\n         * @param {string} beginWord\\n         * @param {string} endWord\\n         * @param {string[]} wordList\\n         * @return {number}\\n         */\\n        let ladderLength = function(beginWord, endWord, wordList) {\\n            let wordListSet = new Set(wordList);\\n            if(!wordListSet.has(endWord)){\\n                return 0;\\n            }\\n            let beginSet = new Set();\\n            beginSet.add(beginWord);\\n            let endSet = new Set();\\n            endSet.add(endWord)\\n            let level = 1;\\n            // BFS\\n            while (beginSet.size > 0) {\\n                let next_beginSet = new Set();\\n                for(let key of beginSet){\\n                    for(let i = 0;i < key.length;i++){\\n                        for(let j = 0;j < 26;j++){\\n                        let s =  String.fromCharCode(97+j);\\n                        if(s != key[i]){\\n                                let new_word = key.slice(0,i)+s+key.slice(i+1);\\n                                if(endSet.has(new_word)){\\n                                    return level + 1;\\n                                }\\n                                if(wordListSet.has(new_word)){\\n                                    next_beginSet.add(new_word);\\n                                    wordListSet.delete(new_word);\\n                                }\\n                        }\\n                        }\\n                    }\\n                }\\n                beginSet = next_beginSet;\\n                level++;\\n                if(beginSet.size > endSet.size){\\n                    let tmp = beginSet;\\n                    beginSet = endSet;\\n                    endSet = tmp;\\n                }\\n            }\\n            return 0;\\n        }\\n        \\u89E3\\u6CD5\\u516B\\uFF1A\\u53CC\\u7AEFBFS\\u706D\\u4E16\\u7248\\n        \\u89E3\\u6CD5\\u4E03\\u7684\\u4EA4\\u6362\\u64CD\\u4F5C\\u53BB\\u6389\\u4E2D\\u95F4\\u53D8\\u91CF\\u7F13\\u5B58\\uFF0C\\u76F4\\u63A5\\u7528ES6\\u7684\\u4EA4\\u6362\\u8BED\\u6CD5\\u7CD6\\n        \\u6240\\u5E78\\u6027\\u80FD\\u76F4\\u63A5\\u98D9\\u5347\\uFF0C\\u51FB\\u8D25\\u767E\\u5206\\u767E\\u3002\\n        \\u622A\\u5C4F2019-11-23\\u4E0B\\u534811.47.38.png\\n        /**\\n         * @param {string} beginWord\\n         * @param {string} endWord\\n         * @param {string[]} wordList\\n         * @return {number}\\n         */\\n        let ladderLength = function(beginWord, endWord, wordList) {\\n            let wordListSet = new Set(wordList);\\n            if(!wordListSet.has(endWord)){\\n                return 0;\\n            }\\n            let beginSet = new Set();\\n            beginSet.add(beginWord);\\n            let endSet = new Set();\\n            endSet.add(endWord)\\n            let level = 1;\\n            // BFS\\n            while (beginSet.size > 0) {\\n                let next_beginSet = new Set();\\n                for(let key of beginSet){\\n                    for(let i = 0;i < key.length;i++){\\n                        for(let j = 0;j < 26;j++){\\n                        let s =  String.fromCharCode(97+j);\\n                        if(s != key[i]){\\n                                let new_word = key.slice(0,i)+s+key.slice(i+1);\\n                                if(endSet.has(new_word)){\\n                                    return level + 1;\\n                                }\\n                                if(wordListSet.has(new_word)){\\n                                    next_beginSet.add(new_word);\\n                                    wordListSet.delete(new_word);\\n                                }\\n                        }\\n                        }\\n                    }\\n                }\\n                beginSet = next_beginSet;\\n                level++;\\n                if(beginSet.size > endSet.size){\\n                    [beginSet,endSet] = [endSet,beginSet]\\n                }\\n            }\\n            return 0;\\n        }\\n    \"};export default Word_Ladder;","map":{"version":3,"sources":["/Users/yabao/Documents/githubspace/Jutsai-Lab/src/apps/bao/baoApp/views/examples/JsLeetcode/js/Depth_First_Search/Word_Ladder.js"],"names":["Word_Ladder","id","name","refLink","level","tag","notes","jsSolution"],"mappings":"AAAA,GAAMA,CAAAA,WAAW,CAAG,CAChBC,EAAE,CAAE,MADY,CAEhBC,IAAI,CAAE,aAFU,CAGhBC,OAAO,CAAE,CACL,0EADK,CAEL,0DAFK,CAGL,0FAHK,CAHO,CAQhBC,KAAK,CAAE,QARS,CAShBC,GAAG,CAAE,EATW,CAUhBC,KAAK,GAVW,CAWhBC,UAAU,ix3BAXM,CAApB,CAomBA,cAAeP,CAAAA,WAAf","sourcesContent":["const Word_Ladder = {\n    id: '0040',\n    name: 'Word_Ladder',\n    refLink: [\n        'https://www.jiuzhang.com/solution/word-ladder/#tag-other-lang-javascript',\n        'https://www.lintcode.com/problem/word-ladder/description',\n        'https://leetcode-cn.com/problems/word-ladder/solution/127-dan-ci-jie-long-by-alexer-660/'\n    ],\n    level: 'Medium',\n    tag: [],\n    notes: ``,\n    jsSolution: `\n        // Given two words (start and end), and a dictionary, find the shortest transformation sequence from start to end, output the length of the sequence.\n        // Transformation rule such that:\n        \n        // Only one letter can be changed at a time\n        // Each intermediate word must exist in the dictionary. (Start and end words do not need to appear in the dictionary )\n        // 在线评测地址: https://www.lintcode.com/problem/word-ladder/\n\n        var ladderLength = function(beginWord, endWord, wordList) {\n            let queue = [beginWord];\n            let visitedMap  = {};\n            let count = 0;\n            while(queue.length != 0){\n                count ++;\n                const length = queue.length;\n                for(let i = 0; i < length; i ++){\n                    let node = queue.pop();\n                    if(node == endWord){\n                        return count;\n                    }\n                    const nextList = findNext(node, wordList, visitedMap);\n                    for(let j = 0; j < nextList.length; j ++){\n                        if(nextList[j] == endWord){\n                            return count + 1;\n                        }\n                        visitedMap[nextList[j]] = true;\n                        queue.unshift(nextList[j]);\n                    }\n                }\n            }\n            return 0;\n        };\n        function findNext(word, arr, visitedMap){\n            let result = [];\n            for(let i = 0;i < arr.length; i ++){\n                let ele = arr[i];\n                if(visitedMap[ele]){\n                    continue;\n                }\n                let diff = 0;\n                for(let j = 0;j < word.length; j ++){\n                    if(word.charAt(j) != ele.charAt(j)){\n                        diff ++;\n                    }\n                }\n                if(diff == 1){\n                    result.push(ele);\n                }\n            }\n            return result;\n        }\n\n        解法一：BFS\n        时间复杂度：O(M * N) ,M为单词长度，,N为单词列表长度\n        空间复杂度：O(M * N) ,M长度的单词化为邻接单词形式时需要M，N同上\n        用广度优先搜索搜索从beginWord到endWord的最短路径问题\n        思路分析\n        一个最短转换序列是 \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\",\n\n        从起点\"hit\"变换到终点\"cog\"\n        每次变换\n        只能变动其中一个单词\n        且必须在字典中\n        因此每次变换，其实就是走了一步\n        每次变换前后的单词差异只有其中一个字符\n        设唯一不同的字符为*\n        \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\"\n\n        hit ----> h*t <-----hot\n        dot ----> *ot <-----hot\n        dot ----> do* <-----dog\n        dog ----> *og <-----cog\n        我们把相差唯一一个字符的两个单词称为邻接单词\n        因此 单词'xyz'的所有邻接单词为\n        '*yz'\n        'x*z'\n        'xy*'\n        因为单词的下一个变换单词即是邻接单词\n        例如我们要从'hit'变换到'hot'\n        hit的邻接单词形式有\n        *it\n        h*t\n        hi*\n        hot的邻接单词形式有\n        *ot\n        h*t\n        ho*\n        我们寻找他们相同的邻接单词形式\n        为h*t\n        反过来\n        符合h*t形式的单词有\n        hit\n        hot\n        因此在代码中，此处便是寻找下一邻接单词的关键逻辑\n        代码逻辑\n        求出wordList中的所有单词的所有邻接单词形式\n        将具有相同邻接单词形式的单词放在一个集合里\n        形如 hash[邻接单词形式] = [单词1,单词2,...,单词n]\n        当我们在寻找下一个邻接单词是谁时，我们通过求当前单词的邻接单词的形式，去枚举上一步的所有邻接单词形式的集合\n        存在则在邻接单词形式对应的单词集合里，遍历寻找符合的目标单词\n        找到，则返回\n        没找到，当前寻址步数++，继续寻址\n        我们将从起点 beginWord --> endWord 的寻址路线，抽象为队列\n        初始值是起点，入队\n        出队，通过邻接单词形式变换寻址，逻辑如上\n        核心逻辑在第一步\n        解题技巧\n        每个邻接单词形式对应的单词既有可能相同，会出现循环寻址即环的形式\n        例如 h*t -> hot、*ot -> hot\n        因此维护一个访问记录数组，访问比较过的单词，下次不再访问\n        /**\n         * @param {string} beginWord\n         * @param {string} endWord\n         * @param {string[]} wordList\n         * @return {number}\n         */\n        var ladderLength = function(beginWord, endWord, wordList) {\n            if(!endWord || wordList.indexOf(endWord) == -1){\n                return 0;\n            }\n            // 各个通用状态对应所有单词\n            var comboDicts = {};\n            var len = beginWord.length;\n            for(var i = 0;i<wordList.length;i++){\n                for(var r = 0;r<len;r++){\n                    var newWord = wordList[i].substring(0,r)+'*'+wordList[i].substring(r+1,len);\n                    (!comboDicts[newWord]) && (comboDicts[newWord] = []);\n                    comboDicts[newWord].push(wordList[i]);\n                }\n            }\n            // Queue for BFS\n            var queue = [[beginWord,1]];\n            // visited\n            var visited = {beginWord:true};\n            while(queue.length > 0){\n                var currNode = queue.shift();\n                var currWord = currNode[0];\n                var currLevel = currNode[1];\n                for(var i = 0;i < len;i++){\n                    // 通用状态\n                    var newWord = currWord.substring(0,i)+'*'+currWord.substring(i+1,len);\n                    if(newWord in comboDicts){\n                        var tmpWords = comboDicts[newWord];\n                        for(var z = 0;z<tmpWords.length;z++){\n                            if(tmpWords[z] == endWord){\n                                return currLevel + 1;\n                            }\n                            if(!visited[tmpWords[z]]){\n                                visited[tmpWords[z]] = true;\n                                queue.push([tmpWords[z],currLevel+1]);\n                            }\n                        }\n                    }\n                }\n            }\n            return 0;\n        };\n        解法二：DFS\n        思路同433. 最小基因变化-解法三\n        这个方法会超时\n        /**\n         * @param {string} beginWord\n         * @param {string} endWord\n         * @param {string[]} wordList\n         * @return {number}\n         */\n        var ladderLength = function(beginWord, endWord, wordList) {\n            if(!endWord || wordList.indexOf(endWord) == -1){\n                return 0;\n            }\n            var visited = {};\n            var minLevel = Number.MAX_SAFE_INTEGER;\n            var level = 1;\n            function recurse(beginWord,level){\n                if(beginWord == endWord){\n                    minLevel = Math.min(minLevel,level);\n                }\n                for(var i = 0;i<wordList.length;i++){\n                    var tmpWord = wordList[i];\n                    var diff = 0;\n                    for(var r = 0;r<tmpWord.length;r++){\n                        if(beginWord[r] != tmpWord[r]){\n                            diff++;\n                            if(diff > 1){\n                                break;\n                            }\n                        }\n                    }\n                    if(diff == 1 && !visited[tmpWord]){\n                        visited[tmpWord] = true;\n                        recurse(tmpWord,level+1);\n                        visited[tmpWord] = false;\n                    }\n                }\n            }\n            recurse(beginWord,level);\n            return (minLevel ^ Number.MAX_SAFE_INTEGER) == 0 ? 0 : minLevel;\n        };\n        解法三：双端BFS\n        时间复杂度：O(M*N)\n        空间复杂度：O(M*N)\n        核心思想是解法一\n        类似双指针的思想\n        同时从头尾两个部分搜索遍历\n        搜索终止条件为\n        一个节点被两个人搜索过\n        类似相遇问题\n        /**\n         * @param {string} beginWord\n         * @param {string} endWord\n         * @param {string[]} wordList\n         * @return {number}\n         */\n        var ladderLength = function(beginWord, endWord, wordList) {\n            if(!endWord || wordList.indexOf(endWord) == -1){\n                return 0;\n            }\n            // 各个通用状态对应所有单词\n            var comboDicts = {};\n            var len = beginWord.length;\n            for(var i = 0;i<wordList.length;i++){\n                for(var r = 0;r<len;r++){\n                    var newWord = wordList[i].substring(0,r)+'*'+wordList[i].substring(r+1,len);\n                    (!comboDicts[newWord]) && (comboDicts[newWord] = []);\n                    comboDicts[newWord].push(wordList[i]);\n                }\n            }\n            \n            function visitWord(currQueue,currVisited,othersVisited){\n                var currNode = currQueue.shift();\n                var currWord = currNode[0];\n                var currLevel = currNode[1];\n                for(var i = 0;i < len;i++){\n                    // 通用状态\n                    var newWord = currWord.substring(0,i)+'*'+currWord.substring(i+1,len);\n                    if(newWord in comboDicts){\n                        var tmpWords = comboDicts[newWord];\n                        for(var z = 0;z<tmpWords.length;z++){\n                            if(othersVisited[tmpWords[z]] != undefined){\n                                return currLevel + othersVisited[tmpWords[z]];\n                            }\n                            if(currVisited[tmpWords[z]] == undefined){\n                                currVisited[tmpWords[z]] = currLevel + 1;\n                                currQueue.push([tmpWords[z],currLevel+1]);\n                            }\n                        }\n                    }\n                }\n                return -1;\n            }\n            \n            // Queue for BFS from beginWord\n            var queueBegin = [[beginWord,1]];\n            // Queue for BFS from endWord\n            var queueEnd  = [[endWord,1]];\n            // visited begin and end\n            var visitedBegin = {};\n            visitedBegin[beginWord] = 1;\n            var visitedEnd = {};\n            visitedEnd[endWord] = 1;\n            while(queueBegin.length > 0 && queueEnd.length > 0){\n                // fromBegin\n                var ans = visitWord(queueBegin,visitedBegin,visitedEnd);\n                if(ans > -1){\n                    return ans;\n                }\n                // formEnd\n                ans = visitWord(queueEnd,visitedEnd,visitedBegin);\n                if(ans > -1){\n                    return ans;\n                }\n            }\n            return 0;\n        };\n        解法四：BFS-2\n        思路同433. 最小基因变化-解法一\n        /**\n         * @param {string} beginWord\n         * @param {string} endWord\n         * @param {string[]} wordList\n         * @return {number}\n         */\n        var ladderLength = function(beginWord, endWord, wordList) {\n            if(!endWord || wordList.indexOf(endWord) == -1){\n                return 0;\n            }\n            var wordListHash = {};\n            for(var i = 0;i<wordList.length;i++){\n                wordListHash[wordList[i]] = true;\n            }\n            var genes = 'abcdefghigklmnopqrstuvwxyz';\n            var level = 0;\n            var queue = [[beginWord,1]];\n            while(queue.length != 0){\n                var curr = queue.pop();\n                level = curr[1]\n                if(curr[0] == endWord){\n                    return level;\n                }\n                var arrCurr = curr[0];\n                for(var i = 0;i<arrCurr.length;i++){\n                    for(var r = 0;r<genes.length;r++){\n                        if(genes[r] != arrCurr[i]){\n                            var strCurr = (arrCurr.slice(0,i))+genes[r]+(arrCurr.slice(i+1));\n                            if(wordListHash[strCurr]){\n                                queue.unshift([strCurr,level+1]);\n                                wordListHash[strCurr] = false;\n                            }\n                        }\n                    }\n                }\n            }\n            return 0;\n        };\n        或者这样写也可\n        /**\n        * @param {string} beginWord\n        * @param {string} endWord\n        * @param {string[]} wordList\n        * @return {number}\n        */\n        var ladderLength = function(beginWord, endWord, wordList) {\n            let comboDicts = new Set(wordList);\n            if(!comboDicts.has(endWord)){\n                return 0;\n            }\n            let level = 0;\n            let queue = [[beginWord,1]];\n            while(queue.length != 0){\n                let currNode = queue.pop();\n                let currLeter = currNode[0];\n                level = currNode[1];\n                if(currNode[0] == endWord){\n                    return level;\n                }\n                for(let i = 0;i < currLeter.length;i++){\n                    for(r = 0;r < 26;r++){\n                        let genTmp = String.fromCharCode(97+r);\n                        if( genTmp != currLeter[i]){\n                            let str = currLeter.slice(0,i)+genTmp+currLeter.slice(i+1);\n                            if(comboDicts.has(str)){\n                                queue.unshift([str,level+1]);\n                                comboDicts.delete(str);\n                            }\n                        }\n                    }\n                }\n            }\n            return 0;\n        }; \n        解法五：双端BFS升级版\n        此解法时间复杂度比以上更低\n        解法一和解法二共同的核心思想\n        用邻接单词形式【yz、xz、xy*】作为键\n        用符合邻接单词形式的单词作为值\n        寻址共同的邻接单词形式为前提，遍历对应的值\n        找到返回前一步步数加1\n        没找到继续遍历\n        此解法的核心思想\n        借用了433. 最小基因变化-解法一 的思路\n        通过直接重新组合上一步单词\n        下一步变换为可能且符合条件的单词，在其中遍历寻找\n        找到返回...\n        没找到步数++，继续遍历\n        单端亦可以用此思路\n        双端则需要加上本题解法三的思路\n        合并两道题解的思路即为如下解法\n        /**\n         * @param {string} beginWord\n         * @param {string} endWord\n         * @param {string[]} wordList\n         * @return {number}\n         */\n        var ladderLength = function(beginWord, endWord, wordList) {\n            var comboDicts = new Set(wordList);\n            if(!comboDicts.has(endWord)){\n                return 0;\n            }\n            var len = beginWord.length;\n            \n            function gens(word){\n                var result = [];\n                var len = word.length;\n                for(var i = 0;i<len;i++){\n                    for(var j = 0;j < 26;j++){\n                        var newWord = word.substring(0,i)+String.fromCharCode(j+97)+word.substring(i+1);\n                        if(comboDicts.has(newWord) && newWord != word){\n                            result.push(newWord);\n                        }\n                    }\n                }\n                return result;\n            }\n            \n            function visitWord(currQueue,currVisited,othersVisited){\n                var currNode = currQueue.shift();\n                var tmpWords = gens(currNode[0]);\n                var currLevel = currNode[1];\n                var tmpLen = tmpWords.length;\n                for(var i = 0;i< tmpLen;i++){\n                    if(othersVisited[tmpWords[i]] != undefined){\n                        return currLevel + othersVisited[tmpWords[i]];\n                    }\n                    if(currVisited[tmpWords[i]] == undefined){\n                        currVisited[tmpWords[i]] = currLevel + 1;\n                        currQueue.push([tmpWords[i],currLevel + 1])\n                    }\n                } \n                return -1;\n            }\n            \n            // Queue for BFS from beginWord\n            var queueBegin = [[beginWord,1]];\n            // Queue for BFS from endWord\n            var queueEnd  = [[endWord,1]];\n            // visited begin and end\n            var visitedBegin = {};\n            visitedBegin[beginWord] = 1;\n            var visitedEnd = {};\n            visitedEnd[endWord] = 1;\n            while(queueBegin.length > 0 && queueEnd.length > 0){\n                // fromBegin\n                var ans = visitWord(queueBegin,visitedBegin,visitedEnd);\n                if(ans > -1){\n                    return ans;\n                }\n                // formEnd\n                ans = visitWord(queueEnd,visitedEnd,visitedBegin);\n                if(ans > -1){\n                    return ans;\n                }\n            }\n            return 0;\n        };\n        解法六：双端BFS强化版\n        其实是解法四：BFS-2 第二种写法的另类版\n        将queue换成set\n        Set 对象搜索、删除、插入时间复杂度为O(1)\n        beginSet、endSet各自向一边扩散\n        visited：节点是否已经访问过\n        BFS\n        beginSet、endSet相当于两个queue\n        扩散过程中，优先选择小的set\n        交换set\n        因上面作了交换，每次只需从beginSet开始扩散即可\n        定义一个temp Set\n        相当于向queue不断加入扩散中被选中的元素\n        因此一轮遍历完，直接将beginSet替换为temp即可\n        每次遍历到一个单词\n        遍历单词的每个字符，并尝试替换为与当前不相同的其余25个字符\n        如果从尾部扩散出的endSet有了新组合的单词\n        说明首尾相遇，直接返回当前level+1即可\n        否则，如果新组合单词未在访问备忘录visited中出现，且出现在单词库wordList中时\n        加入tempSet，用于下一轮扩散单词遍历组合操作\n        并且加入备忘录visited\n        继续下一轮queue temp set遍历\n        /**\n         * @param {string} beginWord\n         * @param {string} endWord\n         * @param {string[]} wordList\n         * @return {number}\n         */\n        let ladderLength = function(beginWord, endWord, wordList) {\n            let wordListSet = new Set(wordList);\n            if(!wordListSet.has(endWord)){\n                return 0;\n            }\n            let beginSet = new Set();\n            beginSet.add(beginWord);\n            let endSet = new Set();\n            endSet.add(endWord)\n            let visited = new Set();\n            let level = 1;\n            // BFS\n            while (beginSet.size > 0 && endSet.size > 0) {\n                if(beginSet.size > endSet.size){\n                    let tmp = beginSet;\n                    beginSet = endSet;\n                    endSet = tmp;\n                }\n                let temp = new Set();\n                for(let key of beginSet){\n                    for(let i = 0;i < key.length;i++){\n                        for(let j = 0;j < 26;j++){\n                        let tmp = key.slice(0,i)+String.fromCharCode(97+j)+key.slice(i+1);\n                        if(endSet.has(tmp)){\n                            return level + 1;\n                        }\n                        if(!visited.has(tmp) && wordListSet.has(tmp)){\n                                temp.add(tmp);\n                                visited.add(tmp);\n                        }\n                        }\n                    }\n                }\n                beginSet = temp;\n                level++;\n            }\n            return 0;\n        }\n        解法七：双端BFS终极版\n        将解法六的visited去掉，直接操作原数组\n        并对部分变量命名作了语义化处理，更容易理解\n        此解法是所有解法中最快的\n        /**\n         * @param {string} beginWord\n         * @param {string} endWord\n         * @param {string[]} wordList\n         * @return {number}\n         */\n        let ladderLength = function(beginWord, endWord, wordList) {\n            let wordListSet = new Set(wordList);\n            if(!wordListSet.has(endWord)){\n                return 0;\n            }\n            let beginSet = new Set();\n            beginSet.add(beginWord);\n            let endSet = new Set();\n            endSet.add(endWord)\n            let level = 1;\n            // BFS\n            while (beginSet.size > 0) {\n                let next_beginSet = new Set();\n                for(let key of beginSet){\n                    for(let i = 0;i < key.length;i++){\n                        for(let j = 0;j < 26;j++){\n                        let s =  String.fromCharCode(97+j);\n                        if(s != key[i]){\n                                let new_word = key.slice(0,i)+s+key.slice(i+1);\n                                if(endSet.has(new_word)){\n                                    return level + 1;\n                                }\n                                if(wordListSet.has(new_word)){\n                                    next_beginSet.add(new_word);\n                                    wordListSet.delete(new_word);\n                                }\n                        }\n                        }\n                    }\n                }\n                beginSet = next_beginSet;\n                level++;\n                if(beginSet.size > endSet.size){\n                    let tmp = beginSet;\n                    beginSet = endSet;\n                    endSet = tmp;\n                }\n            }\n            return 0;\n        }\n        解法八：双端BFS灭世版\n        解法七的交换操作去掉中间变量缓存，直接用ES6的交换语法糖\n        所幸性能直接飙升，击败百分百。\n        截屏2019-11-23下午11.47.38.png\n        /**\n         * @param {string} beginWord\n         * @param {string} endWord\n         * @param {string[]} wordList\n         * @return {number}\n         */\n        let ladderLength = function(beginWord, endWord, wordList) {\n            let wordListSet = new Set(wordList);\n            if(!wordListSet.has(endWord)){\n                return 0;\n            }\n            let beginSet = new Set();\n            beginSet.add(beginWord);\n            let endSet = new Set();\n            endSet.add(endWord)\n            let level = 1;\n            // BFS\n            while (beginSet.size > 0) {\n                let next_beginSet = new Set();\n                for(let key of beginSet){\n                    for(let i = 0;i < key.length;i++){\n                        for(let j = 0;j < 26;j++){\n                        let s =  String.fromCharCode(97+j);\n                        if(s != key[i]){\n                                let new_word = key.slice(0,i)+s+key.slice(i+1);\n                                if(endSet.has(new_word)){\n                                    return level + 1;\n                                }\n                                if(wordListSet.has(new_word)){\n                                    next_beginSet.add(new_word);\n                                    wordListSet.delete(new_word);\n                                }\n                        }\n                        }\n                    }\n                }\n                beginSet = next_beginSet;\n                level++;\n                if(beginSet.size > endSet.size){\n                    [beginSet,endSet] = [endSet,beginSet]\n                }\n            }\n            return 0;\n        }\n    `\n}\n\nexport default Word_Ladder\n"]},"metadata":{},"sourceType":"module"}