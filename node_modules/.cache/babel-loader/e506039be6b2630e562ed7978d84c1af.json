{"ast":null,"code":"const subarray_sum_closest = {\n  id: '0051',\n  name: 'subarray_sum_closest',\n  refLink: ['https://www.jiuzhang.com/solution/subarray-sum-closest/', 'https://www.lintcode.com/problem/subarray-sum-closest/description'],\n  level: 'Hard',\n  tag: [],\n  notes: `JAVA only`,\n  jsSolution: `\n        // Given an integer array, find a subarray with sum closest to zero. Return the indexes of the first number and last number.\n\n        // 在线评测地址: https://www.lintcode.com/problem/subarray-sum-closest/\n        \n        class Pair {\n            int sum;\n            int index;\n            public Pair(int s, int i) {\n                sum = s;\n                index = i;\n            }\n        }\n            \n        public class Solution {\n            /**\n             * @param nums: A list of integers\n             * @return: A list of integers includes the index of the first number \n             *          and the index of the last number\n             */\n            public int[] subarraySumClosest(int[] nums) {\n                int[] res = new int[2];\n                if (nums == null || nums.length == 0) {\n                    return res;\n                } \n                \n                int len = nums.length;\n                if(len == 1) {\n                    res[0] = res[1] = 0;\n                    return res;\n                }\n                Pair[] sums = new Pair[len+1];\n                int prev = 0;\n                sums[0] = new Pair(0, 0);\n                for (int i = 1; i <= len; i++) {\n                    sums[i] = new Pair(prev + nums[i-1], i);\n                    prev = sums[i].sum;\n                }\n                Arrays.sort(sums, new Comparator<Pair>() {\n                   public int compare(Pair a, Pair b) {\n                       return a.sum - b.sum;\n                   } \n                });\n                int ans = Integer.MAX_VALUE;\n                for (int i = 1; i <= len; i++) {\n                    \n                    if (ans > sums[i].sum - sums[i-1].sum) {\n                        ans = sums[i].sum - sums[i-1].sum;\n                        int[] temp = new int[]{sums[i].index - 1, sums[i - 1].index - 1};\n                        Arrays.sort(temp);\n                        res[0] = temp[0] + 1;\n                        res[1] = temp[1];\n                    }\n                }\n                \n                return res;\n            }\n        }\n        \n        \n        /*\n        问：为什么需要一个 (0,0) 的初始 Pair?\n        答：\n        我们首先需要回顾一下，在 subarray 这节课里，我们讲过一个重要的知识点，叫做 Prefix Sum\n        比如对于数组 [1,2,3,4]，他的 Prefix Sum 是 [1,3,6,10]\n        分别表示 前1个数之和，前2个数之和，前3个数之和，前4个数之和\n        这个时候如果你想要知道 子数组 从下标  1 到下标 2 的这一段的和(2+3)，就用前 3个数之和 减去 前1个数之和 = PrefixSum[2] - PrefixSum[0] = 6 - 1 = 5\n        你可以看到这里的 前 x 个数，和具体对应的下标之间，存在 +-1 的问题\n        第 x 个数的下标是 x - 1，反之 下标 x 是第 x + 1 个数\n        那么问题来了，如果要计算 下标从 0~2 这一段呢？也就是第1个数到第3个数，因为那样会访问到 PrefixSum[-1]\n        所以我们把 PrefixSum 整体往后面移动一位，把第0位空出来表示前0个数之和，也就是0. => [0,1,3,6,10]\n        那么此时就用 PrefixSum[3] - PrefixSum[0] ，这样计算就更方便了。\n        此时，PrefixSum[i] 代表 前i个数之和，也就是 下标区间在 0 ~ i-1 这一段的和\n        \n        那么回过头来看看，为什么我们需要一个 (0,0) 的 pair 呢？\n        因为 这个 0,0 代表的就是前0个数之和为0\n        一个 n 个数的数组， 变成了 prefix Sum 数组之后，会多一个数出来\n        */\n    `\n};\nexport default subarray_sum_closest;","map":{"version":3,"sources":["/Users/yabao/Documents/githubspace/Jutsai-Lab/src/apps/bao/baoApp/views/examples/JsLeetcode/js/Linked_List_Array/subarray_sum_closest.js"],"names":["subarray_sum_closest","id","name","refLink","level","tag","notes","jsSolution"],"mappings":"AAAA,MAAMA,oBAAoB,GAAG;AACzBC,EAAAA,EAAE,EAAE,MADqB;AAEzBC,EAAAA,IAAI,EAAE,sBAFmB;AAGzBC,EAAAA,OAAO,EAAE,CACL,yDADK,EAEL,mEAFK,CAHgB;AAOzBC,EAAAA,KAAK,EAAE,MAPkB;AAQzBC,EAAAA,GAAG,EAAE,EARoB;AASzBC,EAAAA,KAAK,EAAG,WATiB;AAUzBC,EAAAA,UAAU,EAAG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAVY,CAA7B;AA2FA,eAAeP,oBAAf","sourcesContent":["const subarray_sum_closest = {\n    id: '0051',\n    name: 'subarray_sum_closest', \n    refLink: [\n        'https://www.jiuzhang.com/solution/subarray-sum-closest/',\n        'https://www.lintcode.com/problem/subarray-sum-closest/description'\n    ],\n    level: 'Hard',\n    tag: [],\n    notes: `JAVA only`,\n    jsSolution: `\n        // Given an integer array, find a subarray with sum closest to zero. Return the indexes of the first number and last number.\n\n        // 在线评测地址: https://www.lintcode.com/problem/subarray-sum-closest/\n        \n        class Pair {\n            int sum;\n            int index;\n            public Pair(int s, int i) {\n                sum = s;\n                index = i;\n            }\n        }\n            \n        public class Solution {\n            /**\n             * @param nums: A list of integers\n             * @return: A list of integers includes the index of the first number \n             *          and the index of the last number\n             */\n            public int[] subarraySumClosest(int[] nums) {\n                int[] res = new int[2];\n                if (nums == null || nums.length == 0) {\n                    return res;\n                } \n                \n                int len = nums.length;\n                if(len == 1) {\n                    res[0] = res[1] = 0;\n                    return res;\n                }\n                Pair[] sums = new Pair[len+1];\n                int prev = 0;\n                sums[0] = new Pair(0, 0);\n                for (int i = 1; i <= len; i++) {\n                    sums[i] = new Pair(prev + nums[i-1], i);\n                    prev = sums[i].sum;\n                }\n                Arrays.sort(sums, new Comparator<Pair>() {\n                   public int compare(Pair a, Pair b) {\n                       return a.sum - b.sum;\n                   } \n                });\n                int ans = Integer.MAX_VALUE;\n                for (int i = 1; i <= len; i++) {\n                    \n                    if (ans > sums[i].sum - sums[i-1].sum) {\n                        ans = sums[i].sum - sums[i-1].sum;\n                        int[] temp = new int[]{sums[i].index - 1, sums[i - 1].index - 1};\n                        Arrays.sort(temp);\n                        res[0] = temp[0] + 1;\n                        res[1] = temp[1];\n                    }\n                }\n                \n                return res;\n            }\n        }\n        \n        \n        /*\n        问：为什么需要一个 (0,0) 的初始 Pair?\n        答：\n        我们首先需要回顾一下，在 subarray 这节课里，我们讲过一个重要的知识点，叫做 Prefix Sum\n        比如对于数组 [1,2,3,4]，他的 Prefix Sum 是 [1,3,6,10]\n        分别表示 前1个数之和，前2个数之和，前3个数之和，前4个数之和\n        这个时候如果你想要知道 子数组 从下标  1 到下标 2 的这一段的和(2+3)，就用前 3个数之和 减去 前1个数之和 = PrefixSum[2] - PrefixSum[0] = 6 - 1 = 5\n        你可以看到这里的 前 x 个数，和具体对应的下标之间，存在 +-1 的问题\n        第 x 个数的下标是 x - 1，反之 下标 x 是第 x + 1 个数\n        那么问题来了，如果要计算 下标从 0~2 这一段呢？也就是第1个数到第3个数，因为那样会访问到 PrefixSum[-1]\n        所以我们把 PrefixSum 整体往后面移动一位，把第0位空出来表示前0个数之和，也就是0. => [0,1,3,6,10]\n        那么此时就用 PrefixSum[3] - PrefixSum[0] ，这样计算就更方便了。\n        此时，PrefixSum[i] 代表 前i个数之和，也就是 下标区间在 0 ~ i-1 这一段的和\n        \n        那么回过头来看看，为什么我们需要一个 (0,0) 的 pair 呢？\n        因为 这个 0,0 代表的就是前0个数之和为0\n        一个 n 个数的数组， 变成了 prefix Sum 数组之后，会多一个数出来\n        */\n    `\n}\n\nexport default subarray_sum_closest\n"]},"metadata":{},"sourceType":"module"}