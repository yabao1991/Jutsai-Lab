{"ast":null,"code":"var Number_of_Islands={id:'0032',name:'Number_of_Islands',refLink:['https://leetcode-cn.com/problems/number-of-islands/solution/200-dao-yu-shu-liang-by-alexer-660/','https://www.lintcode.com/problem/number-of-islands/description','https://www.jiuzhang.com/solution/number-of-islands/#tag-other'],level:'Medium',tag:[''],notes:\"\",jsSolution:\"\\n        // Given a boolean 2D matrix, 0 is represented as the sea, 1 is represented as the island. If two 1 is adjacent, we consider them in the same island. We only consider up/down/left/right adjacent.\\n\\n        // Find the number of islands.\\n        \\n        // \\u5728\\u7EBF\\u8BC4\\u6D4B\\u5730\\u5740: https://www.lintcode.com/problem/number-of-islands/\\n\\n\\n        \\u89E3\\u6CD5\\u4E00\\uFF1ADFS\\n        /**\\n         * @param {character[][]} grid\\n         * @return {number}\\n         */\\n        var numIslands = function(grid) {\\n            if(!grid || grid.length == 0){\\n                return 0;\\n            }\\n            var len = grid.length;\\n            var size = grid[0].length;\\n            var island = 0;\\n            function sink(i,j){\\n                // terminator\\n                if(grid[i][j] == '0'){\\n                    return 0;\\n                }\\n                // process\\n                grid[i][j] = '0';\\n                // drill down\\n                if(i+1<len && grid[i+1][j] == '1'){\\n                    sink(i+1,j);\\n                } \\n                if(i-1 >= 0 && grid[i-1][j] == '1'){\\n                    sink(i-1,j);\\n                } \\n                if(j+1 < size && grid[i][j+1] == '1'){\\n                    sink(i,j+1);\\n                } \\n                if(j-1 >= 0 && grid[i][j-1] == '1'){\\n                    sink(i,j-1);\\n                }\\n                return 1;\\n            }\\n            for(var i = 0;i<len;i++){\\n                for(var r = 0;r<grid[i].length;r++){\\n                    if(grid[i][r] == '1'){\\n                        island += sink(i,r);\\n                    }\\n                }\\n            }\\n            return island;\\n        };\\n        \\u4F18\\u5316\\u7248\\n        \\u5224\\u65AD\\u5E76\\u63A8\\u5E73\\u5C9B\\u5C7F\\u51FD\\u6570\\u65F6 \\u7528\\u65B9\\u5411\\u5411\\u91CF\\u66FF\\u4EE3x+1,x-1,y+1,y-1\\u56DB\\u79CD\\u60C5\\u51B5\\n        /**\\n         * @param {character[][]} grid\\n         * @return {number}\\n         */\\n        var numIslands = function(grid) {\\n            if(!grid || grid.length == 0){\\n                return 0;\\n            }\\n            var len = grid.length;\\n            var size = grid[0].length;\\n            var island = 0;\\n            // \\u65B9\\u5411\\u5411\\u91CF\\n            var dx = [-1,1,0,0];\\n            var dy = [0,0,-1,1];\\n            // dfs \\u63A8\\u5E73\\n            function sink(i,j){\\n                // terminator\\n                if(grid[i][j] == '0'){\\n                    return 0;\\n                }\\n                // process\\n                grid[i][j] = '0';\\n                // drill down\\n                for(var k = 0;k< dx.length;k++){\\n                    var x = i + dx[k];\\n                    var y = j + dy[k];\\n                    if(x >= 0 && x < grid.length && y >=0 && y<grid[i].length){\\n                        if(grid[x][y] == '1'){\\n                            sink(x,y)\\n                        }\\n                    }\\n                }\\n                return 1;\\n            }\\n            for(var i = 0;i<len;i++){\\n                for(var r = 0;r<grid[i].length;r++){\\n                    if(grid[i][r] == 1){\\n                        island += sink(i,r);\\n                    }\\n                }\\n            }\\n            return island;\\n        };\\n        \\u89E3\\u6CD5\\u4E8C\\uFF1ABFS\\n        /**\\n         * @param {character[][]} grid\\n         * @return {number}\\n         */\\n        var numIslands = function(grid) {\\n            if(!grid || grid.length == 0){\\n                return 0;\\n            }\\n            var len = grid.length;\\n            var size = grid[0].length;\\n            var island = 0;\\n            // \\u4ECE\\u53F3\\u5230\\u5DE6 \\u961F\\u5217\\n            var queue = [];\\n            // \\u65B9\\u5411\\u5411\\u91CF\\n            var dx = [-1,1,0,0];\\n            var dy = [0,0,-1,1];\\n            // dfs \\u63A8\\u5E73\\n            function sink(i,j){\\n                // terminator\\n                if(grid[i][j] == '0'){\\n                    return 0;\\n                }\\n                // process\\n                grid[i][j] = '0';\\n                // drill down\\n                for(var k = 0;k< dx.length;k++){\\n                    var x = i + dx[k];\\n                    var y = j + dy[k];\\n                    if(x >= 0 && x < grid.length && y >=0 && y<grid[i].length){\\n                        if(grid[x][y] == '1'){\\n                            queue.push([x,y]);\\n                        }\\n                    }\\n                }\\n                return 1;\\n            }\\n            for(var i = 0;i<len;i++){\\n                for(var r = 0;r<grid[i].length;r++){\\n                    if(grid[i][r] == 1){\\n                        island++;\\n                        queue.push([i,r])\\n                        while(queue.length>0){\\n                            var tmpIsland = queue.shift();\\n                            sink(tmpIsland[0],tmpIsland[1]);\\n                        }\\n                    }\\n                }\\n            }\\n            return island;\\n        };\\n        \\u89E3\\u6CD5\\u4E09\\uFF1A\\u5E76\\u67E5\\u96C6\\n        \\u7C7B\\u4F3C\\u9898\\u578B\\n        547. \\u670B\\u53CB\\u5708\\n        \\u533A\\u522B\\n        \\u6B64\\u9898\\u662Fm * n\\u7684\\u77E9\\u9635\\uFF0C\\u4E0D\\u662Fn * n\\u7684\\u77E9\\u9635\\n        parent\\u548Crank\\u6570\\u7EC4\\u5143\\u7D20\\u547D\\u540D\\u8981\\u5C06i\\u548Cj\\u8054\\u7CFB\\u8D77\\u6765\\n        union\\u67E5\\u627E\\u5408\\u5E76\\u7684\\u65F6\\u5019\\uFF0C\\u4E5F\\u8981\\u628A\\u4E24\\u4E2A\\u662F\\u9646\\u5730\\u7684\\u5143\\u7D20\\u4F20\\u8FDB\\u53BB\\n        /**\\n         * @param {character[][]} grid\\n         * @return {number}\\n         */\\n        var numIslands = function(grid) {\\n            let m = grid.length;\\n            if(m == 0){\\n                return 0;\\n            }\\n            let n = grid[0].length;\\n            let count = 0;\\n            let parent = [];\\n            let rank = [];\\n\\n\\n            let find = (p) => {\\n                while(p != parent[p]){\\n                    parent[p] = parent[parent[p]];\\n                    p = parent[p];\\n                }\\n                return p;\\n            }\\n            let union = (p,q) => {\\n                let rootP = find(p);\\n                let rootQ = find(q);\\n                if(rootP == rootQ){\\n                    return;\\n                }\\n                if(rank[rootP] > rank[rootQ]){\\n                    parent[rootQ] = rootP;\\n                }else if(rank[rootP] < rank[rootQ]){\\n                    parent[rootP] = rootQ;\\n                }else{\\n                    parent[rootP] = rootQ;\\n                    rank[rootQ]++;\\n                }\\n                count--;\\n            }\\n\\n            for(let i = 0;i < m;i++){\\n                for(let j = 0;j < n;j++){\\n                    if(grid[i][j] == 1){\\n                        parent[i * n + j] = i * n + j;\\n                        count++;\\n                    }\\n                    rank[i * n + j] = 0;\\n                }\\n            }\\n\\n            for(var i = 0;i<m;i++){\\n                for(var j = 0;j<n;j++){\\n                    if(grid[i][j] == 1){\\n                        grid[i][j] = 0;\\n                        i-1>=0 && grid[i-1][j] == 1 && union(i*n + j,(i-1)*n + j);\\n                        j-1>=0 && grid[i][j-1] == 1 && union(i*n + j,i*n + j-1);\\n                        i+1<m && grid[i+1][j] == 1 && union(i*n + j,(i+1)*n + j);\\n                        j+1<n && grid[i][j+1] == 1 && union(i*n + j,i*n + j+1);\\n                    }\\n                }\\n            }\\n            return count;\\n        };\\n    \"};export default Number_of_Islands;","map":{"version":3,"sources":["/Users/yabao/Documents/githubspace/Jutsai-Lab/src/apps/bao/baoApp/views/examples/JsLeetcode/js/Breadth_First_Search/Number_of_Islands.js"],"names":["Number_of_Islands","id","name","refLink","level","tag","notes","jsSolution"],"mappings":"AAAA,GAAMA,CAAAA,iBAAiB,CAAG,CACtBC,EAAE,CAAE,MADkB,CAEtBC,IAAI,CAAE,mBAFgB,CAGtBC,OAAO,CAAE,CACL,iGADK,CAEL,gEAFK,CAGL,gEAHK,CAHa,CAQtBC,KAAK,CAAE,QARe,CAStBC,GAAG,CAAE,CACD,EADC,CATiB,CAYtBC,KAAK,GAZiB,CAatBC,UAAU,m8OAbY,CAA1B,CAwOA,cAAeP,CAAAA,iBAAf","sourcesContent":["const Number_of_Islands = {\n    id: '0032',\n    name: 'Number_of_Islands',\n    refLink: [\n        'https://leetcode-cn.com/problems/number-of-islands/solution/200-dao-yu-shu-liang-by-alexer-660/',\n        'https://www.lintcode.com/problem/number-of-islands/description',\n        'https://www.jiuzhang.com/solution/number-of-islands/#tag-other'\n    ],\n    level: 'Medium',\n    tag: [\n        ''\n    ],\n    notes: ``,\n    jsSolution: `\n        // Given a boolean 2D matrix, 0 is represented as the sea, 1 is represented as the island. If two 1 is adjacent, we consider them in the same island. We only consider up/down/left/right adjacent.\n\n        // Find the number of islands.\n        \n        // 在线评测地址: https://www.lintcode.com/problem/number-of-islands/\n\n\n        解法一：DFS\n        /**\n         * @param {character[][]} grid\n         * @return {number}\n         */\n        var numIslands = function(grid) {\n            if(!grid || grid.length == 0){\n                return 0;\n            }\n            var len = grid.length;\n            var size = grid[0].length;\n            var island = 0;\n            function sink(i,j){\n                // terminator\n                if(grid[i][j] == '0'){\n                    return 0;\n                }\n                // process\n                grid[i][j] = '0';\n                // drill down\n                if(i+1<len && grid[i+1][j] == '1'){\n                    sink(i+1,j);\n                } \n                if(i-1 >= 0 && grid[i-1][j] == '1'){\n                    sink(i-1,j);\n                } \n                if(j+1 < size && grid[i][j+1] == '1'){\n                    sink(i,j+1);\n                } \n                if(j-1 >= 0 && grid[i][j-1] == '1'){\n                    sink(i,j-1);\n                }\n                return 1;\n            }\n            for(var i = 0;i<len;i++){\n                for(var r = 0;r<grid[i].length;r++){\n                    if(grid[i][r] == '1'){\n                        island += sink(i,r);\n                    }\n                }\n            }\n            return island;\n        };\n        优化版\n        判断并推平岛屿函数时 用方向向量替代x+1,x-1,y+1,y-1四种情况\n        /**\n         * @param {character[][]} grid\n         * @return {number}\n         */\n        var numIslands = function(grid) {\n            if(!grid || grid.length == 0){\n                return 0;\n            }\n            var len = grid.length;\n            var size = grid[0].length;\n            var island = 0;\n            // 方向向量\n            var dx = [-1,1,0,0];\n            var dy = [0,0,-1,1];\n            // dfs 推平\n            function sink(i,j){\n                // terminator\n                if(grid[i][j] == '0'){\n                    return 0;\n                }\n                // process\n                grid[i][j] = '0';\n                // drill down\n                for(var k = 0;k< dx.length;k++){\n                    var x = i + dx[k];\n                    var y = j + dy[k];\n                    if(x >= 0 && x < grid.length && y >=0 && y<grid[i].length){\n                        if(grid[x][y] == '1'){\n                            sink(x,y)\n                        }\n                    }\n                }\n                return 1;\n            }\n            for(var i = 0;i<len;i++){\n                for(var r = 0;r<grid[i].length;r++){\n                    if(grid[i][r] == 1){\n                        island += sink(i,r);\n                    }\n                }\n            }\n            return island;\n        };\n        解法二：BFS\n        /**\n         * @param {character[][]} grid\n         * @return {number}\n         */\n        var numIslands = function(grid) {\n            if(!grid || grid.length == 0){\n                return 0;\n            }\n            var len = grid.length;\n            var size = grid[0].length;\n            var island = 0;\n            // 从右到左 队列\n            var queue = [];\n            // 方向向量\n            var dx = [-1,1,0,0];\n            var dy = [0,0,-1,1];\n            // dfs 推平\n            function sink(i,j){\n                // terminator\n                if(grid[i][j] == '0'){\n                    return 0;\n                }\n                // process\n                grid[i][j] = '0';\n                // drill down\n                for(var k = 0;k< dx.length;k++){\n                    var x = i + dx[k];\n                    var y = j + dy[k];\n                    if(x >= 0 && x < grid.length && y >=0 && y<grid[i].length){\n                        if(grid[x][y] == '1'){\n                            queue.push([x,y]);\n                        }\n                    }\n                }\n                return 1;\n            }\n            for(var i = 0;i<len;i++){\n                for(var r = 0;r<grid[i].length;r++){\n                    if(grid[i][r] == 1){\n                        island++;\n                        queue.push([i,r])\n                        while(queue.length>0){\n                            var tmpIsland = queue.shift();\n                            sink(tmpIsland[0],tmpIsland[1]);\n                        }\n                    }\n                }\n            }\n            return island;\n        };\n        解法三：并查集\n        类似题型\n        547. 朋友圈\n        区别\n        此题是m * n的矩阵，不是n * n的矩阵\n        parent和rank数组元素命名要将i和j联系起来\n        union查找合并的时候，也要把两个是陆地的元素传进去\n        /**\n         * @param {character[][]} grid\n         * @return {number}\n         */\n        var numIslands = function(grid) {\n            let m = grid.length;\n            if(m == 0){\n                return 0;\n            }\n            let n = grid[0].length;\n            let count = 0;\n            let parent = [];\n            let rank = [];\n\n\n            let find = (p) => {\n                while(p != parent[p]){\n                    parent[p] = parent[parent[p]];\n                    p = parent[p];\n                }\n                return p;\n            }\n            let union = (p,q) => {\n                let rootP = find(p);\n                let rootQ = find(q);\n                if(rootP == rootQ){\n                    return;\n                }\n                if(rank[rootP] > rank[rootQ]){\n                    parent[rootQ] = rootP;\n                }else if(rank[rootP] < rank[rootQ]){\n                    parent[rootP] = rootQ;\n                }else{\n                    parent[rootP] = rootQ;\n                    rank[rootQ]++;\n                }\n                count--;\n            }\n\n            for(let i = 0;i < m;i++){\n                for(let j = 0;j < n;j++){\n                    if(grid[i][j] == 1){\n                        parent[i * n + j] = i * n + j;\n                        count++;\n                    }\n                    rank[i * n + j] = 0;\n                }\n            }\n\n            for(var i = 0;i<m;i++){\n                for(var j = 0;j<n;j++){\n                    if(grid[i][j] == 1){\n                        grid[i][j] = 0;\n                        i-1>=0 && grid[i-1][j] == 1 && union(i*n + j,(i-1)*n + j);\n                        j-1>=0 && grid[i][j-1] == 1 && union(i*n + j,i*n + j-1);\n                        i+1<m && grid[i+1][j] == 1 && union(i*n + j,(i+1)*n + j);\n                        j+1<n && grid[i][j+1] == 1 && union(i*n + j,i*n + j+1);\n                    }\n                }\n            }\n            return count;\n        };\n    `\n}\n\nexport default Number_of_Islands\n"]},"metadata":{},"sourceType":"module"}