{"ast":null,"code":"const Subtree_with_Maximum_Average = {\n  id: '0021',\n  name: 'Subtree_with_Maximum_Average',\n  refLink: ['https://www.lintcode.com/problem/subtree-with-maximum-average/description', 'https://www.jiuzhang.com/solution/subtree-with-maximum-average/'],\n  level: 'Easy',\n  tag: [],\n  notes: `JAVA only`,\n  jsSolution: `\n        // Given a binary tree, find the subtree with maximum average. Return the root of the subtree.\n\n        // 在线评测地址: https://www.lintcode.com/problem/subtree-with-maximum-average/\n\n        // version 1: Traverse + Divide Conquer\n        public class Solution {\n            private class ResultType {\n                public int sum, size;\n                public ResultType(int sum, int size) {\n                    this.sum = sum;\n                    this.size = size;\n                }\n            }\n            \n            private TreeNode subtree = null;\n            private ResultType subtreeResult = null;\n            \n            /**\n             * @param root the root of binary tree\n             * @return the root of the maximum average of subtree\n             */\n            public TreeNode findSubtree2(TreeNode root) {\n                helper(root);\n                return subtree;\n            }\n            \n            private ResultType helper(TreeNode root) {\n                if (root == null) {\n                    return new ResultType(0, 0);\n                }\n                // 分治法计算左右子树的平均值\n                ResultType left = helper(root.left);\n                ResultType right = helper(root.right);\n                // 当前subtree的结果是左右两颗子树的和的平均值加上自身\n                ResultType result = new ResultType(\n                    left.sum + right.sum + root.val,\n                    left.size + right.size + 1\n                );\n                // 打擂台比较得到最大平均值的子树\n                if (subtree == null ||\n                    subtreeResult.sum * result.size < result.sum * subtreeResult.size\n                ) {\n                    subtree = root;\n                    subtreeResult = result;\n                }\n                return result;\n            }\n        }\n    `\n};\nexport default Subtree_with_Maximum_Average;","map":{"version":3,"sources":["/Users/yabao/Documents/githubspace/Jutsai-Lab/src/apps/bao/baoApp/views/examples/JsLeetcode/js/Binary_Tree_Divide_Conquer/Subtree_with_Maximum_Average.js"],"names":["Subtree_with_Maximum_Average","id","name","refLink","level","tag","notes","jsSolution"],"mappings":"AAAA,MAAMA,4BAA4B,GAAG;AACjCC,EAAAA,EAAE,EAAE,MAD6B;AAEjCC,EAAAA,IAAI,EAAE,8BAF2B;AAGjCC,EAAAA,OAAO,EAAE,CACL,2EADK,EAEL,iEAFK,CAHwB;AAOjCC,EAAAA,KAAK,EAAE,MAP0B;AAQjCC,EAAAA,GAAG,EAAE,EAR4B;AASjCC,EAAAA,KAAK,EAAG,WATyB;AAUjCC,EAAAA,UAAU,EAAG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAVoB,CAArC;AA8DA,eAAeP,4BAAf","sourcesContent":["const Subtree_with_Maximum_Average = {\n    id: '0021',\n    name: 'Subtree_with_Maximum_Average',\n    refLink: [\n        'https://www.lintcode.com/problem/subtree-with-maximum-average/description',\n        'https://www.jiuzhang.com/solution/subtree-with-maximum-average/'\n    ],\n    level: 'Easy',\n    tag: [],\n    notes: `JAVA only`,\n    jsSolution: `\n        // Given a binary tree, find the subtree with maximum average. Return the root of the subtree.\n\n        // 在线评测地址: https://www.lintcode.com/problem/subtree-with-maximum-average/\n\n        // version 1: Traverse + Divide Conquer\n        public class Solution {\n            private class ResultType {\n                public int sum, size;\n                public ResultType(int sum, int size) {\n                    this.sum = sum;\n                    this.size = size;\n                }\n            }\n            \n            private TreeNode subtree = null;\n            private ResultType subtreeResult = null;\n            \n            /**\n             * @param root the root of binary tree\n             * @return the root of the maximum average of subtree\n             */\n            public TreeNode findSubtree2(TreeNode root) {\n                helper(root);\n                return subtree;\n            }\n            \n            private ResultType helper(TreeNode root) {\n                if (root == null) {\n                    return new ResultType(0, 0);\n                }\n                // 分治法计算左右子树的平均值\n                ResultType left = helper(root.left);\n                ResultType right = helper(root.right);\n                // 当前subtree的结果是左右两颗子树的和的平均值加上自身\n                ResultType result = new ResultType(\n                    left.sum + right.sum + root.val,\n                    left.size + right.size + 1\n                );\n                // 打擂台比较得到最大平均值的子树\n                if (subtree == null ||\n                    subtreeResult.sum * result.size < result.sum * subtreeResult.size\n                ) {\n                    subtree = root;\n                    subtreeResult = result;\n                }\n                return result;\n            }\n        }\n    `\n}\n\nexport default Subtree_with_Maximum_Average\n"]},"metadata":{},"sourceType":"module"}