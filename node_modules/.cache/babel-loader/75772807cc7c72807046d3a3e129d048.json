{"ast":null,"code":"const Linked_List_Cycle = {\n  id: '0044',\n  name: 'Linked_List_Cycle',\n  refLink: ['https://leetcode-cn.com/problems/linked-list-cycle/solution/shuang-jie-fa-floydsuan-fa-ha-xi-biao-javascriptsh/', 'https://www.lintcode.com/problem/linked-list-cycle/desciption', 'https://www.jiuzhang.com/solution/linked-list-cycle/#tag-highlight'],\n  level: 'Medium',\n  tag: [],\n  notes: `TEST with issue`,\n  jsSolution: `\n        // Given a linked list, determine if it has a cycle in it.\n\n        // 在线评测地址: https://www.lintcode.com/problem/linked-list-cycle/\n\n        解法 1：Floyd 判圈算法\n        Floyd 判圈算法类似龟兔赛跑，需要用到快指针 fast 和慢指针 slow。算法流程是：\n\n        slow 每次移动 1 不，fast 移动 2 步\n        一直移动下去，若 slow、fast 相遇，那么必有环；若 slow 或 fast 抵达边界，那么不存在环。\n        代码实现如下：\n\n        // ac地址：https://leetcode-cn.com/problems/linked-list-cycle/\n        // 原文地址：https://xxoo521.com/2020-03-03-linked-list-cycle/\n\n        /**\n         * @param {ListNode} head\n         * @return {boolean}\n         */\n        var hasCycle = function(head) {\n            let slow = head;\n            let fast = head;\n\n            while (slow && fast && fast.next) {\n                slow = slow.next;\n                fast = fast.next.next;\n                if (slow === fast) return true;\n            }\n            return false;\n        };\n        解法 2: 哈希表\n        这种解法比较容易想到，使用哈希表来记录节点是否出现过。若存在环，那么一直向下访问，一定会回到环的入口处。\n\n        代码实现如下：\n\n        // ac地址：https://leetcode-cn.com/problems/linked-list-cycle/\n        // 原文地址：https://xxoo521.com/2020-03-03-linked-list-cycle/\n\n        /**\n         * @param {ListNode} head\n         * @return {boolean}\n         */\n        var hasCycle = function(head) {\n            if (!head) return false;\n\n            const map = new Map();\n            let node = head;\n            map.set(node, true);\n\n            while (node.next) {\n                if (map.get(node.next)) {\n                    // map.clear() // 节省时间可以去掉\n                    return true;\n                }\n                map.set(node.next, true);\n                node = node.next;\n            }\n            // map.clear()\n            return false;\n        };\n    `\n};\nexport default Linked_List_Cycle;","map":{"version":3,"sources":["/Users/yabao/Documents/githubspace/Jutsai-Lab/src/apps/bao/baoApp/views/examples/JsLeetcode/js/Linked_List_Array/Linked_List_Cycle.js"],"names":["Linked_List_Cycle","id","name","refLink","level","tag","notes","jsSolution"],"mappings":"AAAA,MAAMA,iBAAiB,GAAG;AACtBC,EAAAA,EAAE,EAAE,MADkB;AAEtBC,EAAAA,IAAI,EAAE,mBAFgB;AAGtBC,EAAAA,OAAO,EAAE,CACL,iHADK,EAEL,+DAFK,EAGL,oEAHK,CAHa;AAQtBC,EAAAA,KAAK,EAAE,QARe;AAStBC,EAAAA,GAAG,EAAE,EATiB;AAUtBC,EAAAA,KAAK,EAAG,iBAVc;AAWtBC,EAAAA,UAAU,EAAG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAXS,CAA1B;AA0EA,eAAeP,iBAAf","sourcesContent":["const Linked_List_Cycle = {\n    id: '0044',\n    name: 'Linked_List_Cycle',\n    refLink: [\n        'https://leetcode-cn.com/problems/linked-list-cycle/solution/shuang-jie-fa-floydsuan-fa-ha-xi-biao-javascriptsh/',\n        'https://www.lintcode.com/problem/linked-list-cycle/desciption',\n        'https://www.jiuzhang.com/solution/linked-list-cycle/#tag-highlight'\n    ],\n    level: 'Medium',\n    tag: [],\n    notes: `TEST with issue`,\n    jsSolution: `\n        // Given a linked list, determine if it has a cycle in it.\n\n        // 在线评测地址: https://www.lintcode.com/problem/linked-list-cycle/\n\n        解法 1：Floyd 判圈算法\n        Floyd 判圈算法类似龟兔赛跑，需要用到快指针 fast 和慢指针 slow。算法流程是：\n\n        slow 每次移动 1 不，fast 移动 2 步\n        一直移动下去，若 slow、fast 相遇，那么必有环；若 slow 或 fast 抵达边界，那么不存在环。\n        代码实现如下：\n\n        // ac地址：https://leetcode-cn.com/problems/linked-list-cycle/\n        // 原文地址：https://xxoo521.com/2020-03-03-linked-list-cycle/\n\n        /**\n         * @param {ListNode} head\n         * @return {boolean}\n         */\n        var hasCycle = function(head) {\n            let slow = head;\n            let fast = head;\n\n            while (slow && fast && fast.next) {\n                slow = slow.next;\n                fast = fast.next.next;\n                if (slow === fast) return true;\n            }\n            return false;\n        };\n        解法 2: 哈希表\n        这种解法比较容易想到，使用哈希表来记录节点是否出现过。若存在环，那么一直向下访问，一定会回到环的入口处。\n\n        代码实现如下：\n\n        // ac地址：https://leetcode-cn.com/problems/linked-list-cycle/\n        // 原文地址：https://xxoo521.com/2020-03-03-linked-list-cycle/\n\n        /**\n         * @param {ListNode} head\n         * @return {boolean}\n         */\n        var hasCycle = function(head) {\n            if (!head) return false;\n\n            const map = new Map();\n            let node = head;\n            map.set(node, true);\n\n            while (node.next) {\n                if (map.get(node.next)) {\n                    // map.clear() // 节省时间可以去掉\n                    return true;\n                }\n                map.set(node.next, true);\n                node = node.next;\n            }\n            // map.clear()\n            return false;\n        };\n    `\n}\n\nexport default Linked_List_Cycle\n"]},"metadata":{},"sourceType":"module"}